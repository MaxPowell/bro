// This file was automatically generated by bifcl from /home/ubuntu/bro/src/analyzer/protocol/mysql/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr mysql_command_request; 
void BifEvent::generate_mysql_command_request(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t command, StringVal* arg)
	{
	// Note that it is intentional that here we do not
	// check if ::mysql_command_request is NULL, which should happen *before*
	// BifEvent::generate_mysql_command_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(command, TYPE_COUNT));
	vl->append(arg);

	mgr.QueueEvent(::mysql_command_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr mysql_error; 
void BifEvent::generate_mysql_error(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t code, StringVal* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::mysql_error is NULL, which should happen *before*
	// BifEvent::generate_mysql_error is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(code, TYPE_COUNT));
	vl->append(msg);

	mgr.QueueEvent(::mysql_error, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr mysql_ok; 
void BifEvent::generate_mysql_ok(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t affected_rows)
	{
	// Note that it is intentional that here we do not
	// check if ::mysql_ok is NULL, which should happen *before*
	// BifEvent::generate_mysql_ok is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(affected_rows, TYPE_COUNT));

	mgr.QueueEvent(::mysql_ok, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr mysql_server_version; 
void BifEvent::generate_mysql_server_version(analyzer::Analyzer* analyzer, Connection* c, StringVal* ver)
	{
	// Note that it is intentional that here we do not
	// check if ::mysql_server_version is NULL, which should happen *before*
	// BifEvent::generate_mysql_server_version is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(ver);

	mgr.QueueEvent(::mysql_server_version, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr mysql_handshake; 
void BifEvent::generate_mysql_handshake(analyzer::Analyzer* analyzer, Connection* c, StringVal* username)
	{
	// Note that it is intentional that here we do not
	// check if ::mysql_handshake is NULL, which should happen *before*
	// BifEvent::generate_mysql_handshake is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(username);

	mgr.QueueEvent(::mysql_handshake, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
