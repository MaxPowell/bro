// This file is automatically generated from /home/ubuntu/bro/src/analyzer/protocol/mysql/mysql.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/ubuntu/bro/my_build_dir/src/analyzer/protocol/mysql/mysql_pac.h"

namespace binpac {







namespace MySQL {
ContextMySQL::ContextMySQL(MySQL_Conn * connection, MySQL_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextMySQL::~ContextMySQL()
	{
	}

MySQL_Conn::MySQL_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new MySQL_Flow(this, true);
	downflow_ = new MySQL_Flow(this, false);
	bro_analyzer_ = bro_analyzer;

		version_ = 0;
		state_ = CONNECTION_PHASE;
		expected_ = EXPECT_STATUS;
		col_count_ = 0;
	
	}

MySQL_Conn::~MySQL_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void MySQL_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void MySQL_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void MySQL_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

uint8 MySQL_Conn::get_version()
	{

		return version_;
		
	}

bool MySQL_Conn::set_version(uint8 v)
	{

		version_ = v;
		return true;
		
	}

int MySQL_Conn::get_state()
	{

		return state_;
		
	}

bool MySQL_Conn::update_state(state s)
	{

		state_ = s;
		return true;
		
	}

Expected MySQL_Conn::get_expectation()
	{

		return expected_;
		
	}

bool MySQL_Conn::set_next_expected(Expected e)
	{

		expected_ = e;
		return true;
		
	}

uint32 MySQL_Conn::get_col_count()
	{

		return col_count_;
		
	}

bool MySQL_Conn::set_col_count(uint32 i)
	{

		col_count_ = i;
		return true;
		
	}

uint24le::uint24le()
	{
	byte3_ = 0;
	byte2_ = 0;
	byte1_ = 0;
	}

uint24le::~uint24le()
	{
	}

int uint24le::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "uint24le"
	if ( t_begin_of_data + (3) > t_end_of_data || t_begin_of_data + (3) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("uint24le",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte3"
	byte3_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte2"
	byte2_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte1"
	byte1_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

LengthEncodedInteger::LengthEncodedInteger()
	{
	length_ = 0;
	integer_ = 0;
	}

LengthEncodedInteger::~LengthEncodedInteger()
	{
	delete integer_;
	integer_ = 0;
	}

int LengthEncodedInteger::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "LengthEncodedInteger:length"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("LengthEncodedInteger:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "integer"
	integer_ = new LengthEncodedIntegerLookahead(length());
	int t_integer__size;
	t_integer__size = integer_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_LengthEncodedInteger__size;
	const_byteptr const t_dataptr_after_integer = (t_begin_of_data + 1) + (t_integer__size);
	BINPAC_ASSERT(t_dataptr_after_integer <= t_end_of_data);
	t_LengthEncodedInteger__size = t_dataptr_after_integer - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_LengthEncodedInteger__size) <= t_end_of_data);
	return t_LengthEncodedInteger__size;
	}

LengthEncodedIntegerLookahead::LengthEncodedIntegerLookahead(uint8 length)
	{
	val_case_index_ = -1;
	i2_ = 0;
	i3_ = 0;
	i4_ = 0;
	length_ = length;
	}

LengthEncodedIntegerLookahead::~LengthEncodedIntegerLookahead()
	{
	switch ( val_case_index() )
		{
		case 251:
			// Clean up "i0"
			{
			}
			break;
		case 252:
			// Clean up "i2"
			{
			}
			break;
		case 253:
			// Clean up "i3"
			{
			delete i3_;
			i3_ = 0;
			}
			break;
		case 254:
			// Clean up "i4"
			{
			}
			break;
		case 255:
			// Clean up "err_packet"
			{
			}
			break;
		default:
			// Clean up "one"
			{
			}
			break;
		}
	}

int LengthEncodedIntegerLookahead::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "val"
	int t_val__size;
	val_case_index_ = length();
	switch ( val_case_index() )
		{
		case 251:
			// Parse "i0"
			{
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		case 252:
			// Parse "i2"
			{
			// Checking out-of-bound for "LengthEncodedIntegerLookahead:i2"
			if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("LengthEncodedIntegerLookahead:i2",
					(0) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			i2_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 2;
			}
			break;
		case 253:
			// Parse "i3"
			{
			i3_ = new uint24le();
			i3_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 3;
			}
			break;
		case 254:
			// Parse "i4"
			{
			// Checking out-of-bound for "LengthEncodedIntegerLookahead:i4"
			if ( t_begin_of_data + (8) > t_end_of_data || t_begin_of_data + (8) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("LengthEncodedIntegerLookahead:i4",
					(0) + (8), 
					(t_end_of_data) - (t_begin_of_data));
				}
			i4_ = FixByteOrder(t_byteorder, *((uint64 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 8;
			}
			break;
		case 255:
			// Parse "err_packet"
			{
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		default:
			// Parse "one"
			{
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_LengthEncodedIntegerLookahead__size;
	const_byteptr const t_dataptr_after_val = t_begin_of_data + (t_val__size);
	BINPAC_ASSERT(t_dataptr_after_val <= t_end_of_data);
	t_LengthEncodedIntegerLookahead__size = t_dataptr_after_val - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_LengthEncodedIntegerLookahead__size) <= t_end_of_data);
	return t_LengthEncodedIntegerLookahead__size;
	}

LengthEncodedString::LengthEncodedString()
	{
	len_ = 0;
	}

LengthEncodedString::~LengthEncodedString()
	{
	delete len_;
	len_ = 0;
	val_.free();
	}

int LengthEncodedString::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "len"
	len_ = new LengthEncodedInteger();
	int t_len__size;
	t_len__size = len_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_len = t_begin_of_data + (t_len__size);
	BINPAC_ASSERT(t_dataptr_after_len <= t_end_of_data);
	// Parse "val"
	int t_val__size;
	t_val__size = to_int()(len());
	// Checking out-of-bound for "LengthEncodedString:val"
	if ( t_dataptr_after_len + (t_val__size) > t_end_of_data || t_dataptr_after_len + (t_val__size) < t_dataptr_after_len )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("LengthEncodedString:val",
			((t_dataptr_after_len - t_begin_of_data)) + (t_val__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_len + t_val__size;
	int t_val_string_length;
	t_val_string_length = to_int()(len());
	// check for negative sizes
	if ( t_val_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:33", t_val_string_length);
	val_.init(t_dataptr_after_len, t_val_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_LengthEncodedString__size;
	const_byteptr const t_dataptr_after_val = t_dataptr_after_len + (t_val__size);
	BINPAC_ASSERT(t_dataptr_after_val <= t_end_of_data);
	t_LengthEncodedString__size = t_dataptr_after_val - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_LengthEncodedString__size) <= t_end_of_data);
	return t_LengthEncodedString__size;
	}

RegExMatcher NUL_String_re_001("[^\\0]*");

MySQL_PDU::MySQL_PDU(bool is_orig)
	{
	hdr_ = 0;
	msg_case_index_ = -1;
	server_msg_ = 0;
	client_msg_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	state_ = 0;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

MySQL_PDU::~MySQL_PDU()
	{
	delete hdr_;
	hdr_ = 0;
	switch ( msg_case_index() )
		{
		case 0:
			// Clean up "server_msg"
			{
			delete server_msg_;
			server_msg_ = 0;
			}
			break;
		case 1:
			// Clean up "client_msg"
			{
			delete client_msg_;
			client_msg_ = 0;
			}
			break;
		}
	}

bool MySQL_PDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextMySQL * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(4, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			// Checking out-of-bound for "MySQL_PDU:hdr"
			if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("MySQL_PDU:hdr",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "hdr"
			hdr_ = new Header();
			hdr_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_flow_buffer->GrowFrame(hdr()->len());
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				
				// Parse "msg"
				state_ = t_context->connection()->get_state();
				int t_msg__size;
				msg_case_index_ = is_orig();
				switch ( msg_case_index() )
					{
					case 0:
						// Parse "server_msg"
						{
						server_msg_ = new Server_Message(hdr()->seq_id());
						int t_server_msg__size;
						t_server_msg__size = server_msg_->Parse((t_begin_of_data + 4), t_end_of_data, t_context, byteorder());
						// Evaluate 'let' and 'withinput' fields
						t_msg__size = t_server_msg__size;
						}
						break;
					case 1:
						// Parse "client_msg"
						{
						client_msg_ = new Client_Message(state());
						int t_client_msg__size;
						t_client_msg__size = client_msg_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_msg__size = t_client_msg__size;
						}
						break;
					default:
						throw binpac::ExceptionInvalidCaseIndex("MySQL_PDU", msg_case_index());
						break;
					}
				// Evaluate 'let' and 'withinput' fields
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

Header::Header()
	{
	le_len_ = 0;
	seq_id_ = 0;
	len_ = 0;
	}

Header::~Header()
	{
	delete le_len_;
	le_len_ = 0;
	}

int Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Header"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Header",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 4;
	// Checking out-of-bound for "Header:seq_id"
	if ( (t_begin_of_data + 3) + (1) > t_end_of_data || (t_begin_of_data + 3) + (1) < (t_begin_of_data + 3) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Header:seq_id",
			(3) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "le_len"
	le_len_ = new uint24le();
	le_len_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "seq_id"
	seq_id_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	len_ = to_int()(le_len()) + 4;
	}
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Server_Message::Server_Message(uint8 seq_id)
	{
	val_case_index_ = -1;
	initial_handshake_ = 0;
	command_response_ = 0;
	seq_id_ = seq_id;
	}

Server_Message::~Server_Message()
	{
	switch ( val_case_index() )
		{
		case 0:
			// Clean up "initial_handshake"
			{
			delete initial_handshake_;
			initial_handshake_ = 0;
			}
			break;
		default:
			// Clean up "command_response"
			{
			delete command_response_;
			command_response_ = 0;
			}
			break;
		}
	}

int Server_Message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = seq_id();
	switch ( val_case_index() )
		{
		case 0:
			// Parse "initial_handshake"
			{
			initial_handshake_ = new Initial_Handshake_Packet();
			int t_initial_handshake__size;
			t_initial_handshake__size = initial_handshake_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_initial_handshake__size;
			}
			break;
		default:
			// Parse "command_response"
			{
			command_response_ = new Command_Response();
			int t_command_response__size;
			t_command_response__size = command_response_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_command_response__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Client_Message::Client_Message(int state)
	{
	val_case_index_ = -1;
	connection_phase_ = 0;
	command_phase_ = 0;
	state_ = state;
	}

Client_Message::~Client_Message()
	{
	switch ( val_case_index() )
		{
		case 0:
			// Clean up "connection_phase"
			{
			delete connection_phase_;
			connection_phase_ = 0;
			}
			break;
		case 1:
			// Clean up "command_phase"
			{
			delete command_phase_;
			command_phase_ = 0;
			}
			break;
		}
	}

int Client_Message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context)
	{
	int t_val__size;
	val_case_index_ = state();
	switch ( val_case_index() )
		{
		case 0:
			// Parse "connection_phase"
			{
			connection_phase_ = new Handshake_Response_Packet();
			int t_connection_phase__size;
			t_connection_phase__size = connection_phase_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_connection_phase__size;
			}
			break;
		case 1:
			// Parse "command_phase"
			{
			command_phase_ = new Command_Request_Packet();
			int t_command_phase__size;
			t_command_phase__size = command_phase_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_command_phase__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("Client_Message", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Initial_Handshake_Packet::Initial_Handshake_Packet()
	{
	version_ = 0;
	pkt_case_index_ = -1;
	handshake10_ = 0;
	handshake9_ = 0;
	error_ = 0;
	set_version_ = 0;
	proc_ = 0;
	}

Initial_Handshake_Packet::~Initial_Handshake_Packet()
	{
	switch ( pkt_case_index() )
		{
		case 10:
			// Clean up "handshake10"
			{
			delete handshake10_;
			handshake10_ = 0;
			}
			break;
		case 9:
			// Clean up "handshake9"
			{
			delete handshake9_;
			handshake9_ = 0;
			}
			break;
		default:
			// Clean up "error"
			{
			delete error_;
			error_ = 0;
			}
			break;
		}
	}

int Initial_Handshake_Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "Initial_Handshake_Packet:version"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Initial_Handshake_Packet:version",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "version"
	version_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pkt"
	int t_pkt__size;
	pkt_case_index_ = version();
	switch ( pkt_case_index() )
		{
		case 10:
			// Parse "handshake10"
			{
			handshake10_ = new Handshake_v10();
			int t_handshake10__size;
			t_handshake10__size = handshake10_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_pkt__size = t_handshake10__size;
			}
			break;
		case 9:
			// Parse "handshake9"
			{
			handshake9_ = new Handshake_v9();
			int t_handshake9__size;
			t_handshake9__size = handshake9_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_pkt__size = t_handshake9__size;
			}
			break;
		default:
			// Parse "error"
			{
			error_ = new ERR_Packet();
			int t_error__size;
			t_error__size = error_->Parse((t_begin_of_data + 1), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_pkt__size = t_error__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Initial_Handshake_Packet__size;
	const_byteptr const t_dataptr_after_pkt = (t_begin_of_data + 1) + (t_pkt__size);
	BINPAC_ASSERT(t_dataptr_after_pkt <= t_end_of_data);
	t_Initial_Handshake_Packet__size = t_dataptr_after_pkt - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	set_version_ = t_context->connection()->set_version(version());
	proc_ = t_context->flow()->proc_mysql_initial_handshake_packet(this);
	BINPAC_ASSERT(t_begin_of_data + (t_Initial_Handshake_Packet__size) <= t_end_of_data);
	return t_Initial_Handshake_Packet__size;
	}

Handshake_v10::Handshake_v10()
	{
	connection_id_ = 0;
	filler_1_ = 0;
	capability_flag_1_ = 0;
	character_set_ = 0;
	status_flags_ = 0;
	capability_flags_2_ = 0;
	auth_plugin_data_len_ = 0;
	}

Handshake_v10::~Handshake_v10()
	{
	server_version_.free();
	auth_plugin_data_part_1_.free();
	auth_plugin_name_.free();
	}

int Handshake_v10::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "server_version"
	int t_server_version_string_length;
	t_server_version_string_length = 
		NUL_String_re_001.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_server_version_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:174", "[^\\0]*", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_server_version__size;
	t_server_version__size = t_server_version_string_length;
	// check for negative sizes
	if ( t_server_version_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:174", t_server_version_string_length);
	server_version_.init(t_begin_of_data, t_server_version_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_server_version = t_begin_of_data + (t_server_version__size);
	BINPAC_ASSERT(t_dataptr_after_server_version <= t_end_of_data);
	// Checking out-of-bound for "Handshake_v10:connection_id"
	if ( t_dataptr_after_server_version + (4) > t_end_of_data || t_dataptr_after_server_version + (4) < t_dataptr_after_server_version )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake_v10:connection_id",
			((t_dataptr_after_server_version - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "connection_id"
	connection_id_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_server_version)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "auth_plugin_data_part_1"
	// Checking out-of-bound for "Handshake_v10:auth_plugin_data_part_1"
	if ( (t_dataptr_after_server_version + 4) + (8) > t_end_of_data || (t_dataptr_after_server_version + 4) + (8) < (t_dataptr_after_server_version + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake_v10:auth_plugin_data_part_1",
			(((t_dataptr_after_server_version + 4) - t_begin_of_data)) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_server_version + 4) + 8;
	int t_auth_plugin_data_part_1_string_length;
	t_auth_plugin_data_part_1_string_length = 8;
	int t_auth_plugin_data_part_1__size;
	t_auth_plugin_data_part_1__size = t_auth_plugin_data_part_1_string_length;
	auth_plugin_data_part_1_.init((t_dataptr_after_server_version + 4), t_auth_plugin_data_part_1_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_auth_plugin_data_part_1 = (t_dataptr_after_server_version + 4) + (8);
	BINPAC_ASSERT(t_dataptr_after_auth_plugin_data_part_1 <= t_end_of_data);
	// Checking out-of-bound for "Handshake_v10:auth_plugin_data_len"
	if ( (t_dataptr_after_auth_plugin_data_part_1 + 8) + (1) > t_end_of_data || (t_dataptr_after_auth_plugin_data_part_1 + 8) + (1) < (t_dataptr_after_auth_plugin_data_part_1 + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake_v10:auth_plugin_data_len",
			(((t_dataptr_after_auth_plugin_data_part_1 + 8) - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "filler_1"
	filler_1_ = *((uint8 const *) (t_dataptr_after_auth_plugin_data_part_1));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "capability_flag_1"
	capability_flag_1_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_auth_plugin_data_part_1 + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "character_set"
	character_set_ = *((uint8 const *) ((t_dataptr_after_auth_plugin_data_part_1 + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_flags"
	status_flags_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_auth_plugin_data_part_1 + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "capability_flags_2"
	capability_flags_2_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_auth_plugin_data_part_1 + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "auth_plugin_data_len"
	auth_plugin_data_len_ = *((uint8 const *) ((t_dataptr_after_auth_plugin_data_part_1 + 8)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "auth_plugin_name"
	int t_auth_plugin_name_string_length;
	t_auth_plugin_name_string_length = 
		NUL_String_re_001.MatchPrefix(
			(t_dataptr_after_auth_plugin_data_part_1 + 9),
			t_end_of_data - (t_dataptr_after_auth_plugin_data_part_1 + 9));
	if ( t_auth_plugin_name_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:183", "[^\\0]*", string((const char *) ((t_dataptr_after_auth_plugin_data_part_1 + 9)), (const char *) t_end_of_data).c_str());
		}
	int t_auth_plugin_name__size;
	t_auth_plugin_name__size = t_auth_plugin_name_string_length;
	// check for negative sizes
	if ( t_auth_plugin_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:183", t_auth_plugin_name_string_length);
	auth_plugin_name_.init((t_dataptr_after_auth_plugin_data_part_1 + 9), t_auth_plugin_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Handshake_v10__size;
	const_byteptr const t_dataptr_after_auth_plugin_name = (t_dataptr_after_auth_plugin_data_part_1 + 9) + (t_auth_plugin_name__size);
	BINPAC_ASSERT(t_dataptr_after_auth_plugin_name <= t_end_of_data);
	t_Handshake_v10__size = t_dataptr_after_auth_plugin_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Handshake_v10__size) <= t_end_of_data);
	return t_Handshake_v10__size;
	}

Handshake_v9::Handshake_v9()
	{
	connection_id_ = 0;
	}

Handshake_v9::~Handshake_v9()
	{
	server_version_.free();
	scramble_.free();
	}

int Handshake_v9::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "server_version"
	int t_server_version_string_length;
	t_server_version_string_length = 
		NUL_String_re_001.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_server_version_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:187", "[^\\0]*", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_server_version__size;
	t_server_version__size = t_server_version_string_length;
	// check for negative sizes
	if ( t_server_version_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:187", t_server_version_string_length);
	server_version_.init(t_begin_of_data, t_server_version_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_server_version = t_begin_of_data + (t_server_version__size);
	BINPAC_ASSERT(t_dataptr_after_server_version <= t_end_of_data);
	// Checking out-of-bound for "Handshake_v9:connection_id"
	if ( t_dataptr_after_server_version + (4) > t_end_of_data || t_dataptr_after_server_version + (4) < t_dataptr_after_server_version )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake_v9:connection_id",
			((t_dataptr_after_server_version - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "connection_id"
	connection_id_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_server_version)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "scramble"
	int t_scramble_string_length;
	t_scramble_string_length = 
		NUL_String_re_001.MatchPrefix(
			(t_dataptr_after_server_version + 4),
			t_end_of_data - (t_dataptr_after_server_version + 4));
	if ( t_scramble_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:189", "[^\\0]*", string((const char *) ((t_dataptr_after_server_version + 4)), (const char *) t_end_of_data).c_str());
		}
	int t_scramble__size;
	t_scramble__size = t_scramble_string_length;
	// check for negative sizes
	if ( t_scramble_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:189", t_scramble_string_length);
	scramble_.init((t_dataptr_after_server_version + 4), t_scramble_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Handshake_v9__size;
	const_byteptr const t_dataptr_after_scramble = (t_dataptr_after_server_version + 4) + (t_scramble__size);
	BINPAC_ASSERT(t_dataptr_after_scramble <= t_end_of_data);
	t_Handshake_v9__size = t_dataptr_after_scramble - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Handshake_v9__size) <= t_end_of_data);
	return t_Handshake_v9__size;
	}

Handshake_Response_Packet::Handshake_Response_Packet()
	{
	val_case_index_ = -1;
	v10_response_ = 0;
	v9_response_ = 0;
	byteorder_ = bigendian;
	version_ = 0;
	proc_ = 0;
	}

Handshake_Response_Packet::~Handshake_Response_Packet()
	{
	switch ( val_case_index() )
		{
		case 10:
			// Clean up "v10_response"
			{
			delete v10_response_;
			v10_response_ = 0;
			}
			break;
		case 9:
			// Clean up "v9_response"
			{
			delete v9_response_;
			v9_response_ = 0;
			}
			break;
		}
	}

int Handshake_Response_Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context)
	{
	int t_val__size;
	val_case_index_ = t_context->connection()->get_version();
	switch ( val_case_index() )
		{
		case 10:
			// Parse "v10_response"
			{
			v10_response_ = new Handshake_Response_Packet_v10();
			int t_v10_response__size;
			t_v10_response__size = v10_response_->Parse(t_begin_of_data, t_end_of_data, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v10_response__size;
			}
			break;
		case 9:
			// Parse "v9_response"
			{
			v9_response_ = new Handshake_Response_Packet_v9();
			int t_v9_response__size;
			t_v9_response__size = v9_response_->Parse(t_begin_of_data, t_end_of_data, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v9_response__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("Handshake_Response_Packet", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	version_ = t_context->connection()->get_version();
	proc_ = t_context->flow()->proc_mysql_handshake_response_packet(this);
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Handshake_Response_Packet_v10::Handshake_Response_Packet_v10()
	{
	cap_flags_ = 0;
	max_pkt_size_ = 0;
	char_set_ = 0;
	}

Handshake_Response_Packet_v10::~Handshake_Response_Packet_v10()
	{
	username_.free();
	password_.free();
	}

int Handshake_Response_Packet_v10::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Handshake_Response_Packet_v10:pad"
	if ( (t_begin_of_data + 9) + (23) > t_end_of_data || (t_begin_of_data + 9) + (23) < (t_begin_of_data + 9) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake_Response_Packet_v10:pad",
			(9) + (23), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cap_flags"
	cap_flags_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_pkt_size"
	max_pkt_size_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "char_set"
	char_set_ = *((uint8 const *) ((t_begin_of_data + 8)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "username"
	int t_username_string_length;
	t_username_string_length = 
		NUL_String_re_001.MatchPrefix(
			(t_begin_of_data + 32),
			t_end_of_data - (t_begin_of_data + 32));
	if ( t_username_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:206", "[^\\0]*", string((const char *) ((t_begin_of_data + 32)), (const char *) t_end_of_data).c_str());
		}
	int t_username__size;
	t_username__size = t_username_string_length;
	// check for negative sizes
	if ( t_username_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:206", t_username_string_length);
	username_.init((t_begin_of_data + 32), t_username_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_username = (t_begin_of_data + 32) + (t_username__size);
	BINPAC_ASSERT(t_dataptr_after_username <= t_end_of_data);
	// Parse "password"
	int t_password_string_length;
	t_password_string_length = (t_end_of_data) - (t_dataptr_after_username);
	int t_password__size;
	t_password__size = t_password_string_length;
	// check for negative sizes
	if ( t_password_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:207", t_password_string_length);
	password_.init(t_dataptr_after_username, t_password_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Handshake_Response_Packet_v10__size;
	const_byteptr const t_dataptr_after_password = t_dataptr_after_username + (t_password__size);
	BINPAC_ASSERT(t_dataptr_after_password <= t_end_of_data);
	t_Handshake_Response_Packet_v10__size = t_dataptr_after_password - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Handshake_Response_Packet_v10__size) <= t_end_of_data);
	return t_Handshake_Response_Packet_v10__size;
	}

Handshake_Response_Packet_v9::Handshake_Response_Packet_v9()
	{
	cap_flags_ = 0;
	max_pkt_size_ = 0;
	have_db_case_index_ = -1;
	}

Handshake_Response_Packet_v9::~Handshake_Response_Packet_v9()
	{
	delete max_pkt_size_;
	max_pkt_size_ = 0;
	username_.free();
	auth_response_.free();
	switch ( have_db_case_index() )
		{
		case 8:
			// Clean up "database"
			{
			database_.free();
			}
			break;
		case 0:
			// Clean up "none"
			{
			}
			break;
		}
	password_.free();
	}

int Handshake_Response_Packet_v9::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Handshake_Response_Packet_v9:max_pkt_size"
	if ( (t_begin_of_data + 2) + (3) > t_end_of_data || (t_begin_of_data + 2) + (3) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake_Response_Packet_v9:max_pkt_size",
			(2) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cap_flags"
	cap_flags_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_pkt_size"
	max_pkt_size_ = new uint24le();
	max_pkt_size_->Parse((t_begin_of_data + 2), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "username"
	int t_username_string_length;
	t_username_string_length = 
		NUL_String_re_001.MatchPrefix(
			(t_begin_of_data + 5),
			t_end_of_data - (t_begin_of_data + 5));
	if ( t_username_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:213", "[^\\0]*", string((const char *) ((t_begin_of_data + 5)), (const char *) t_end_of_data).c_str());
		}
	int t_username__size;
	t_username__size = t_username_string_length;
	// check for negative sizes
	if ( t_username_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:213", t_username_string_length);
	username_.init((t_begin_of_data + 5), t_username_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_username = (t_begin_of_data + 5) + (t_username__size);
	BINPAC_ASSERT(t_dataptr_after_username <= t_end_of_data);
	// Parse "auth_response"
	int t_auth_response_string_length;
	t_auth_response_string_length = 
		NUL_String_re_001.MatchPrefix(
			t_dataptr_after_username,
			t_end_of_data - t_dataptr_after_username);
	if ( t_auth_response_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:214", "[^\\0]*", string((const char *) (t_dataptr_after_username), (const char *) t_end_of_data).c_str());
		}
	int t_auth_response__size;
	t_auth_response__size = t_auth_response_string_length;
	// check for negative sizes
	if ( t_auth_response_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:214", t_auth_response_string_length);
	auth_response_.init(t_dataptr_after_username, t_auth_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_auth_response = t_dataptr_after_username + (t_auth_response__size);
	BINPAC_ASSERT(t_dataptr_after_auth_response <= t_end_of_data);
	// Parse "have_db"
	int t_have_db__size;
	have_db_case_index_ =  ( cap_flags() & 0x8 ) ;
	switch ( have_db_case_index() )
		{
		case 8:
			// Parse "database"
			{
			int t_database_string_length;
			t_database_string_length = 
				NUL_String_re_001.MatchPrefix(
					t_dataptr_after_auth_response,
					t_end_of_data - t_dataptr_after_auth_response);
			if ( t_database_string_length < 0 )
				{
				throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:216", "[^\\0]*", string((const char *) (t_dataptr_after_auth_response), (const char *) t_end_of_data).c_str());
				}
			int t_database__size;
			t_database__size = t_database_string_length;
			// check for negative sizes
			if ( t_database_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:216", t_database_string_length);
			database_.init(t_dataptr_after_auth_response, t_database_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_have_db__size = t_database__size;
			}
			break;
		case 0:
			// Parse "none"
			{
			// Evaluate 'let' and 'withinput' fields
			t_have_db__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("Handshake_Response_Packet_v9", have_db_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_have_db = t_dataptr_after_auth_response + (t_have_db__size);
	BINPAC_ASSERT(t_dataptr_after_have_db <= t_end_of_data);
	// Parse "password"
	int t_password_string_length;
	t_password_string_length = (t_end_of_data) - (t_dataptr_after_have_db);
	int t_password__size;
	t_password__size = t_password_string_length;
	// check for negative sizes
	if ( t_password_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:219", t_password_string_length);
	password_.init(t_dataptr_after_have_db, t_password_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Handshake_Response_Packet_v9__size;
	const_byteptr const t_dataptr_after_password = t_dataptr_after_have_db + (t_password__size);
	BINPAC_ASSERT(t_dataptr_after_password <= t_end_of_data);
	t_Handshake_Response_Packet_v9__size = t_dataptr_after_password - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Handshake_Response_Packet_v9__size) <= t_end_of_data);
	return t_Handshake_Response_Packet_v9__size;
	}

Command_Request_Packet::Command_Request_Packet()
	{
	command_ = 0;
	update_expectation_ = 0;
	proc_ = 0;
	}

Command_Request_Packet::~Command_Request_Packet()
	{
	arg_.free();
	}

int Command_Request_Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context)
	{
	// Checking out-of-bound for "Command_Request_Packet:command"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Command_Request_Packet:command",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "command"
	command_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "arg"
	int t_arg_string_length;
	t_arg_string_length = (t_end_of_data) - ((t_begin_of_data + 1));
	int t_arg__size;
	t_arg__size = t_arg_string_length;
	// check for negative sizes
	if ( t_arg_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:226", t_arg_string_length);
	arg_.init((t_begin_of_data + 1), t_arg_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Command_Request_Packet__size;
	const_byteptr const t_dataptr_after_arg = (t_begin_of_data + 1) + (t_arg__size);
	BINPAC_ASSERT(t_dataptr_after_arg <= t_end_of_data);
	t_Command_Request_Packet__size = t_dataptr_after_arg - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	update_expectation_ = t_context->connection()->set_next_expected(EXPECT_COLUMN_COUNT);
	proc_ = t_context->flow()->proc_mysql_command_request_packet(this);
	BINPAC_ASSERT(t_begin_of_data + (t_Command_Request_Packet__size) <= t_end_of_data);
	return t_Command_Request_Packet__size;
	}

Command_Response::Command_Response()
	{
	val_case_index_ = -1;
	col_count_meta_ = 0;
	col_defs_ = 0;
	resultset_ = 0;
	status_ = 0;
	eof1_ = 0;
	eof2_ = 0;
	}

Command_Response::~Command_Response()
	{
	switch ( val_case_index() )
		{
		case 3:
			// Clean up "col_count_meta"
			{
			delete col_count_meta_;
			col_count_meta_ = 0;
			}
			break;
		case 2:
			// Clean up "col_defs"
			{
			delete col_defs_;
			col_defs_ = 0;
			}
			break;
		case 6:
			// Clean up "resultset"
			{
			delete resultset_;
			resultset_ = 0;
			}
			break;
		case 1:
			// Clean up "status"
			{
			delete status_;
			status_ = 0;
			}
			break;
		case 4:
			// Clean up "eof1"
			{
			delete eof1_;
			eof1_ = 0;
			}
			break;
		case 5:
			// Clean up "eof2"
			{
			delete eof2_;
			eof2_ = 0;
			}
			break;
		default:
			// Clean up "unknow"
			{
			}
			break;
		}
	}

int Command_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = t_context->connection()->get_expectation();
	switch ( val_case_index() )
		{
		case 3:
			// Parse "col_count_meta"
			{
			col_count_meta_ = new ColumnCountMeta();
			int t_col_count_meta__size;
			t_col_count_meta__size = col_count_meta_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_col_count_meta__size;
			}
			break;
		case 2:
			// Parse "col_defs"
			{
			col_defs_ = new ColumnDefinitions();
			int t_col_defs__size;
			t_col_defs__size = col_defs_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_col_defs__size;
			}
			break;
		case 6:
			// Parse "resultset"
			{
			resultset_ = new Resultset();
			int t_resultset__size;
			t_resultset__size = resultset_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_resultset__size;
			}
			break;
		case 1:
			// Parse "status"
			{
			status_ = new Command_Response_Status();
			int t_status__size;
			t_status__size = status_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_status__size;
			}
			break;
		case 4:
			// Parse "eof1"
			{
			eof1_ = new EOF1();
			eof1_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 5:
			// Parse "eof2"
			{
			eof2_ = new EOF2();
			eof2_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		default:
			// Parse "unknow"
			{
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Command_Response_Status::Command_Response_Status()
	{
	pkt_type_ = 0;
	response_case_index_ = -1;
	data_ok_ = 0;
	data_eof_ = 0;
	data_err_ = 0;
	}

Command_Response_Status::~Command_Response_Status()
	{
	switch ( response_case_index() )
		{
		case 0:
			// Clean up "data_ok"
			{
			delete data_ok_;
			data_ok_ = 0;
			}
			break;
		case 254:
			// Clean up "data_eof"
			{
			delete data_eof_;
			data_eof_ = 0;
			}
			break;
		case 255:
			// Clean up "data_err"
			{
			delete data_err_;
			data_err_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			}
			break;
		}
	}

int Command_Response_Status::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "Command_Response_Status:pkt_type"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Command_Response_Status:pkt_type",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "pkt_type"
	pkt_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "response"
	int t_response__size;
	response_case_index_ = pkt_type();
	switch ( response_case_index() )
		{
		case 0:
			// Parse "data_ok"
			{
			data_ok_ = new OK_Packet();
			int t_data_ok__size;
			t_data_ok__size = data_ok_->Parse((t_begin_of_data + 1), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_response__size = t_data_ok__size;
			}
			break;
		case 254:
			// Parse "data_eof"
			{
			data_eof_ = new EOF_Packet();
			data_eof_->Parse((t_begin_of_data + 1), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_response__size = 4;
			}
			break;
		case 255:
			// Parse "data_err"
			{
			data_err_ = new ERR_Packet();
			int t_data_err__size;
			t_data_err__size = data_err_->Parse((t_begin_of_data + 1), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_response__size = t_data_err__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			// Evaluate 'let' and 'withinput' fields
			t_response__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Command_Response_Status__size;
	const_byteptr const t_dataptr_after_response = (t_begin_of_data + 1) + (t_response__size);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	t_Command_Response_Status__size = t_dataptr_after_response - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Command_Response_Status__size) <= t_end_of_data);
	return t_Command_Response_Status__size;
	}

ColumnCountMeta::ColumnCountMeta()
	{
	byte_ = 0;
	pkt_type_case_index_ = -1;
	ok_ = 0;
	err_ = 0;
	col_count_ = 0;
	}

ColumnCountMeta::~ColumnCountMeta()
	{
	switch ( pkt_type_case_index() )
		{
		case 0:
			// Clean up "ok"
			{
			delete ok_;
			ok_ = 0;
			}
			break;
		case 255:
			// Clean up "err"
			{
			delete err_;
			err_ = 0;
			}
			break;
		default:
			// Clean up "col_count"
			{
			delete col_count_;
			col_count_ = 0;
			}
			break;
		}
	}

int ColumnCountMeta::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ColumnCountMeta:byte"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ColumnCountMeta:byte",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte"
	byte_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pkt_type"
	int t_pkt_type__size;
	pkt_type_case_index_ = byte();
	switch ( pkt_type_case_index() )
		{
		case 0:
			// Parse "ok"
			{
			ok_ = new OK_Packet();
			int t_ok__size;
			t_ok__size = ok_->Parse((t_begin_of_data + 1), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_pkt_type__size = t_ok__size;
			}
			break;
		case 255:
			// Parse "err"
			{
			err_ = new ERR_Packet();
			int t_err__size;
			t_err__size = err_->Parse((t_begin_of_data + 1), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_pkt_type__size = t_err__size;
			}
			break;
		default:
			// Parse "col_count"
			{
			col_count_ = new ColumnCount(byte());
			int t_col_count__size;
			t_col_count__size = col_count_->Parse((t_begin_of_data + 1), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_pkt_type__size = t_col_count__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_ColumnCountMeta__size;
	const_byteptr const t_dataptr_after_pkt_type = (t_begin_of_data + 1) + (t_pkt_type__size);
	BINPAC_ASSERT(t_dataptr_after_pkt_type <= t_end_of_data);
	t_ColumnCountMeta__size = t_dataptr_after_pkt_type - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ColumnCountMeta__size) <= t_end_of_data);
	return t_ColumnCountMeta__size;
	}

ColumnCount::ColumnCount(uint8 byte)
	{
	le_column_count_ = 0;
	byte_ = byte;
	col_num_ = 0;
	update_col_num_ = 0;
	update_expectation_ = 0;
	}

ColumnCount::~ColumnCount()
	{
	delete le_column_count_;
	le_column_count_ = 0;
	}

int ColumnCount::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Parse "le_column_count"
	le_column_count_ = new LengthEncodedIntegerLookahead(byte());
	int t_le_column_count__size;
	t_le_column_count__size = le_column_count_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ColumnCount__size;
	const_byteptr const t_dataptr_after_le_column_count = t_begin_of_data + (t_le_column_count__size);
	BINPAC_ASSERT(t_dataptr_after_le_column_count <= t_end_of_data);
	t_ColumnCount__size = t_dataptr_after_le_column_count - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	col_num_ = to_int()(le_column_count());
	update_col_num_ = t_context->connection()->set_col_count(col_num());
	update_expectation_ = t_context->connection()->set_next_expected(EXPECT_COLUMN_DEFINITION);
	BINPAC_ASSERT(t_begin_of_data + (t_ColumnCount__size) <= t_end_of_data);
	return t_ColumnCount__size;
	}

ColumnDefinitions::ColumnDefinitions()
	{
	defs_ = 0;
	defs__elem_ = 0;
	update_expectation_ = 0;
	}

ColumnDefinitions::~ColumnDefinitions()
	{
	delete defs__elem_;
	defs__elem_ = 0;
	if ( defs() )
		{
		for ( int i = 0; i < (int) defs()->size(); ++i )
			{
			ColumnDefinition41 * defs__elem_ = (*defs_)[i];
			delete defs__elem_;
			defs__elem_ = 0;
			}
		}
	delete defs_;
	}

int ColumnDefinitions::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Parse "defs"
	int t_defs__arraylength;
	t_defs__arraylength = 0;
	t_defs__arraylength = 1;
	if ( t_begin_of_data + t_defs__arraylength > t_end_of_data + 1 || t_begin_of_data + t_defs__arraylength < t_begin_of_data )
		{
		t_defs__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_defs__arraylength < 0 )
		{
		t_defs__arraylength = 0;
		}
	defs__elem_ = 0;
	int t_defs__elem__it;
	t_defs__elem__it = 0;
	int t_defs__size;
	defs_ = new vector<ColumnDefinition41 *>;
	defs_->reserve(t_defs__arraylength);
	const_byteptr t_defs__elem__dataptr = t_begin_of_data;
	for (; t_defs__elem__it < t_defs__arraylength; ++t_defs__elem__it)
		{
		// Check &until(defs__elem__dataptr >= end_of_data)
		if ( t_defs__elem__dataptr >= t_end_of_data )
			{
			defs__elem_ = 0;
			goto end_of_defs;
			}
		defs__elem_ = new ColumnDefinition41();
		int t_defs__elem__size;
		t_defs__elem__size = defs__elem_->Parse(t_defs__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		defs_->push_back(defs__elem_);
		t_defs__elem__dataptr += t_defs__elem__size;
		BINPAC_ASSERT(t_defs__elem__dataptr <= t_end_of_data);
		defs__elem_ = 0;
		}
end_of_defs: ;
	t_defs__size = t_defs__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ColumnDefinitions__size;
	const_byteptr const t_dataptr_after_defs = t_begin_of_data + (t_defs__size);
	BINPAC_ASSERT(t_dataptr_after_defs <= t_end_of_data);
	t_ColumnDefinitions__size = t_dataptr_after_defs - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	update_expectation_ = t_context->connection()->set_next_expected(EXPECT_EOF1);
	BINPAC_ASSERT(t_begin_of_data + (t_ColumnDefinitions__size) <= t_end_of_data);
	return t_ColumnDefinitions__size;
	}

EOF1::EOF1()
	{
	eof_ = 0;
	update_expectation_ = 0;
	}

EOF1::~EOF1()
	{
	delete eof_;
	eof_ = 0;
	}

int EOF1::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EOF1"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EOF1",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "eof"
	eof_ = new EOF_Packet();
	eof_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	update_expectation_ = t_context->connection()->set_next_expected(EXPECT_RESULTSET);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

EOF2::EOF2()
	{
	eof_ = 0;
	update_expectation_ = 0;
	}

EOF2::~EOF2()
	{
	delete eof_;
	eof_ = 0;
	}

int EOF2::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EOF2"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EOF2",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "eof"
	eof_ = new EOF_Packet();
	eof_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	update_expectation_ = t_context->connection()->set_next_expected(NO_EXPECTATION);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Resultset::Resultset()
	{
	rows_ = 0;
	rows__elem_ = 0;
	update_expectation_ = 0;
	proc_ = 0;
	}

Resultset::~Resultset()
	{
	delete rows__elem_;
	rows__elem_ = 0;
	if ( rows() )
		{
		for ( int i = 0; i < (int) rows()->size(); ++i )
			{
			ResultsetRow * rows__elem_ = (*rows_)[i];
			delete rows__elem_;
			rows__elem_ = 0;
			}
		}
	delete rows_;
	}

int Resultset::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Parse "rows"
	int t_rows__arraylength;
	t_rows__arraylength = 0;
	rows__elem_ = 0;
	int t_rows__elem__it;
	t_rows__elem__it = 0;
	int t_rows__size;
	rows_ = new vector<ResultsetRow *>;
	const_byteptr t_rows__elem__dataptr = t_begin_of_data;
	for (; /* forever */; ++t_rows__elem__it)
		{
		// Check &until(rows__elem__dataptr >= end_of_data)
		if ( t_rows__elem__dataptr >= t_end_of_data )
			{
			rows__elem_ = 0;
			goto end_of_rows;
			}
		rows__elem_ = new ResultsetRow();
		int t_rows__elem__size;
		t_rows__elem__size = rows__elem_->Parse(t_rows__elem__dataptr, t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		rows_->push_back(rows__elem_);
		t_rows__elem__dataptr += t_rows__elem__size;
		BINPAC_ASSERT(t_rows__elem__dataptr <= t_end_of_data);
		rows__elem_ = 0;
		}
end_of_rows: ;
	t_rows__size = t_rows__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Resultset__size;
	const_byteptr const t_dataptr_after_rows = t_begin_of_data + (t_rows__size);
	BINPAC_ASSERT(t_dataptr_after_rows <= t_end_of_data);
	t_Resultset__size = t_dataptr_after_rows - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	update_expectation_ = t_context->connection()->set_next_expected(EXPECT_EOF2);
	proc_ = t_context->flow()->proc_resultset(this);
	BINPAC_ASSERT(t_begin_of_data + (t_Resultset__size) <= t_end_of_data);
	return t_Resultset__size;
	}

ResultsetRow::ResultsetRow()
	{
	fields_ = 0;
	fields__elem_ = 0;
	}

ResultsetRow::~ResultsetRow()
	{
	delete fields__elem_;
	fields__elem_ = 0;
	if ( fields() )
		{
		for ( int i = 0; i < (int) fields()->size(); ++i )
			{
			LengthEncodedString * fields__elem_ = (*fields_)[i];
			delete fields__elem_;
			fields__elem_ = 0;
			}
		}
	delete fields_;
	}

int ResultsetRow::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Parse "fields"
	int t_fields__arraylength;
	t_fields__arraylength = 0;
	t_fields__arraylength = t_context->connection()->get_col_count();
	if ( t_begin_of_data + t_fields__arraylength > t_end_of_data + 1 || t_begin_of_data + t_fields__arraylength < t_begin_of_data )
		{
		t_fields__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_fields__arraylength < 0 )
		{
		t_fields__arraylength = 0;
		}
	fields__elem_ = 0;
	int t_fields__elem__it;
	t_fields__elem__it = 0;
	int t_fields__size;
	fields_ = new vector<LengthEncodedString *>;
	fields_->reserve(t_fields__arraylength);
	const_byteptr t_fields__elem__dataptr = t_begin_of_data;
	for (; t_fields__elem__it < t_fields__arraylength; ++t_fields__elem__it)
		{
		// Check &until(fields__elem__dataptr >= end_of_data)
		if ( t_fields__elem__dataptr >= t_end_of_data )
			{
			fields__elem_ = 0;
			goto end_of_fields;
			}
		fields__elem_ = new LengthEncodedString();
		int t_fields__elem__size;
		t_fields__elem__size = fields__elem_->Parse(t_fields__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		fields_->push_back(fields__elem_);
		t_fields__elem__dataptr += t_fields__elem__size;
		BINPAC_ASSERT(t_fields__elem__dataptr <= t_end_of_data);
		fields__elem_ = 0;
		}
end_of_fields: ;
	t_fields__size = t_fields__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ResultsetRow__size;
	const_byteptr const t_dataptr_after_fields = t_begin_of_data + (t_fields__size);
	BINPAC_ASSERT(t_dataptr_after_fields <= t_end_of_data);
	t_ResultsetRow__size = t_dataptr_after_fields - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ResultsetRow__size) <= t_end_of_data);
	return t_ResultsetRow__size;
	}

ColumnDefinition41::ColumnDefinition41()
	{
	catalog_ = 0;
	schema_ = 0;
	table_ = 0;
	org_table_ = 0;
	name_ = 0;
	org_name_ = 0;
	next_len_ = 0;
	char_set_ = 0;
	col_len_ = 0;
	type_ = 0;
	flags_ = 0;
	decimals_ = 0;
	}

ColumnDefinition41::~ColumnDefinition41()
	{
	delete catalog_;
	catalog_ = 0;
	delete schema_;
	schema_ = 0;
	delete table_;
	table_ = 0;
	delete org_table_;
	org_table_ = 0;
	delete name_;
	name_ = 0;
	delete org_name_;
	org_name_ = 0;
	delete next_len_;
	next_len_ = 0;
	}

int ColumnDefinition41::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "catalog"
	catalog_ = new LengthEncodedString();
	int t_catalog__size;
	t_catalog__size = catalog_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_catalog = t_begin_of_data + (t_catalog__size);
	BINPAC_ASSERT(t_dataptr_after_catalog <= t_end_of_data);
	// Parse "schema"
	schema_ = new LengthEncodedString();
	int t_schema__size;
	t_schema__size = schema_->Parse(t_dataptr_after_catalog, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_schema = t_dataptr_after_catalog + (t_schema__size);
	BINPAC_ASSERT(t_dataptr_after_schema <= t_end_of_data);
	// Parse "table"
	table_ = new LengthEncodedString();
	int t_table__size;
	t_table__size = table_->Parse(t_dataptr_after_schema, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_table = t_dataptr_after_schema + (t_table__size);
	BINPAC_ASSERT(t_dataptr_after_table <= t_end_of_data);
	// Parse "org_table"
	org_table_ = new LengthEncodedString();
	int t_org_table__size;
	t_org_table__size = org_table_->Parse(t_dataptr_after_table, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_org_table = t_dataptr_after_table + (t_org_table__size);
	BINPAC_ASSERT(t_dataptr_after_org_table <= t_end_of_data);
	// Parse "name"
	name_ = new LengthEncodedString();
	int t_name__size;
	t_name__size = name_->Parse(t_dataptr_after_org_table, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_name = t_dataptr_after_org_table + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	// Parse "org_name"
	org_name_ = new LengthEncodedString();
	int t_org_name__size;
	t_org_name__size = org_name_->Parse(t_dataptr_after_name, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_org_name = t_dataptr_after_name + (t_org_name__size);
	BINPAC_ASSERT(t_dataptr_after_org_name <= t_end_of_data);
	// Parse "next_len"
	next_len_ = new LengthEncodedInteger();
	int t_next_len__size;
	t_next_len__size = next_len_->Parse(t_dataptr_after_org_name, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_next_len = t_dataptr_after_org_name + (t_next_len__size);
	BINPAC_ASSERT(t_dataptr_after_next_len <= t_end_of_data);
	// Checking out-of-bound for "ColumnDefinition41:filler"
	if ( (t_dataptr_after_next_len + 10) + (2) > t_end_of_data || (t_dataptr_after_next_len + 10) + (2) < (t_dataptr_after_next_len + 10) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ColumnDefinition41:filler",
			(((t_dataptr_after_next_len + 10) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "char_set"
	char_set_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_next_len)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "col_len"
	col_len_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_dataptr_after_next_len + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "type"
	type_ = *((uint8 const *) ((t_dataptr_after_next_len + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_next_len + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "decimals"
	decimals_ = *((uint8 const *) ((t_dataptr_after_next_len + 9)));
	// Evaluate 'let' and 'withinput' fields
	
	
	int t_ColumnDefinition41__size;
	t_ColumnDefinition41__size = (t_dataptr_after_next_len + 12) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ColumnDefinition41__size) <= t_end_of_data);
	return t_ColumnDefinition41__size;
	}

ColumnDefinition320::ColumnDefinition320()
	{
	table_ = 0;
	name_ = 0;
	length_of_col_len_ = 0;
	col_len_ = 0;
	type_len_ = 0;
	type_ = 0;
	}

ColumnDefinition320::~ColumnDefinition320()
	{
	delete table_;
	table_ = 0;
	delete name_;
	name_ = 0;
	delete length_of_col_len_;
	length_of_col_len_ = 0;
	delete col_len_;
	col_len_ = 0;
	delete type_len_;
	type_len_ = 0;
	}

int ColumnDefinition320::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "table"
	table_ = new LengthEncodedString();
	int t_table__size;
	t_table__size = table_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_table = t_begin_of_data + (t_table__size);
	BINPAC_ASSERT(t_dataptr_after_table <= t_end_of_data);
	// Parse "name"
	name_ = new LengthEncodedString();
	int t_name__size;
	t_name__size = name_->Parse(t_dataptr_after_table, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_name = t_dataptr_after_table + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	// Parse "length_of_col_len"
	length_of_col_len_ = new LengthEncodedInteger();
	int t_length_of_col_len__size;
	t_length_of_col_len__size = length_of_col_len_->Parse(t_dataptr_after_name, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_length_of_col_len = t_dataptr_after_name + (t_length_of_col_len__size);
	BINPAC_ASSERT(t_dataptr_after_length_of_col_len <= t_end_of_data);
	// Checking out-of-bound for "ColumnDefinition320:col_len"
	if ( t_dataptr_after_length_of_col_len + (3) > t_end_of_data || t_dataptr_after_length_of_col_len + (3) < t_dataptr_after_length_of_col_len )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ColumnDefinition320:col_len",
			((t_dataptr_after_length_of_col_len - t_begin_of_data)) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "col_len"
	col_len_ = new uint24le();
	col_len_->Parse(t_dataptr_after_length_of_col_len, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "type_len"
	type_len_ = new LengthEncodedInteger();
	int t_type_len__size;
	t_type_len__size = type_len_->Parse((t_dataptr_after_length_of_col_len + 3), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_type_len = (t_dataptr_after_length_of_col_len + 3) + (t_type_len__size);
	BINPAC_ASSERT(t_dataptr_after_type_len <= t_end_of_data);
	// Checking out-of-bound for "ColumnDefinition320:type"
	if ( t_dataptr_after_type_len + (1) > t_end_of_data || t_dataptr_after_type_len + (1) < t_dataptr_after_type_len )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ColumnDefinition320:type",
			((t_dataptr_after_type_len - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = *((uint8 const *) (t_dataptr_after_type_len));
	// Evaluate 'let' and 'withinput' fields
	
	int t_ColumnDefinition320__size;
	t_ColumnDefinition320__size = (t_dataptr_after_type_len + 1) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ColumnDefinition320__size) <= t_end_of_data);
	return t_ColumnDefinition320__size;
	}

OK_Packet::OK_Packet()
	{
	le_rows_ = 0;
	rows_ = 0;
	update_state_ = 0;
	proc_ = 0;
	}

OK_Packet::~OK_Packet()
	{
	delete le_rows_;
	le_rows_ = 0;
	todo_.free();
	}

int OK_Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Parse "le_rows"
	le_rows_ = new LengthEncodedInteger();
	int t_le_rows__size;
	t_le_rows__size = le_rows_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_le_rows = t_begin_of_data + (t_le_rows__size);
	BINPAC_ASSERT(t_dataptr_after_le_rows <= t_end_of_data);
	// Parse "todo"
	int t_todo_string_length;
	t_todo_string_length = (t_end_of_data) - (t_dataptr_after_le_rows);
	int t_todo__size;
	t_todo__size = t_todo_string_length;
	// check for negative sizes
	if ( t_todo_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:326", t_todo_string_length);
	todo_.init(t_dataptr_after_le_rows, t_todo_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_OK_Packet__size;
	const_byteptr const t_dataptr_after_todo = t_dataptr_after_le_rows + (t_todo__size);
	BINPAC_ASSERT(t_dataptr_after_todo <= t_end_of_data);
	t_OK_Packet__size = t_dataptr_after_todo - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	rows_ = to_int()(le_rows());
	update_state_ = t_context->connection()->update_state(COMMAND_PHASE);
	proc_ = t_context->flow()->proc_ok_packet(this);
	BINPAC_ASSERT(t_begin_of_data + (t_OK_Packet__size) <= t_end_of_data);
	return t_OK_Packet__size;
	}

ERR_Packet::ERR_Packet()
	{
	code_ = 0;
	update_state_ = 0;
	proc_ = 0;
	}

ERR_Packet::~ERR_Packet()
	{
	state_.free();
	msg_.free();
	}

int ERR_Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ERR_Packet:code"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ERR_Packet:code",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "code"
	code_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "state"
	// Checking out-of-bound for "ERR_Packet:state"
	if ( (t_begin_of_data + 2) + (6) > t_end_of_data || (t_begin_of_data + 2) + (6) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ERR_Packet:state",
			(2) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + 6;
	int t_state_string_length;
	t_state_string_length = 6;
	int t_state__size;
	t_state__size = t_state_string_length;
	state_.init((t_begin_of_data + 2), t_state_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_state = (t_begin_of_data + 2) + (6);
	BINPAC_ASSERT(t_dataptr_after_state <= t_end_of_data);
	// Parse "msg"
	int t_msg_string_length;
	t_msg_string_length = (t_end_of_data) - (t_dataptr_after_state);
	int t_msg__size;
	t_msg__size = t_msg_string_length;
	// check for negative sizes
	if ( t_msg_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/mysql/mysql-protocol.pac:335", t_msg_string_length);
	msg_.init(t_dataptr_after_state, t_msg_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ERR_Packet__size;
	const_byteptr const t_dataptr_after_msg = t_dataptr_after_state + (t_msg__size);
	BINPAC_ASSERT(t_dataptr_after_msg <= t_end_of_data);
	t_ERR_Packet__size = t_dataptr_after_msg - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	update_state_ = t_context->connection()->update_state(COMMAND_PHASE);
	proc_ = t_context->flow()->proc_err_packet(this);
	BINPAC_ASSERT(t_begin_of_data + (t_ERR_Packet__size) <= t_end_of_data);
	return t_ERR_Packet__size;
	}

EOF_Packet::EOF_Packet()
	{
	warnings_ = 0;
	status_ = 0;
	update_state_ = 0;
	}

EOF_Packet::~EOF_Packet()
	{
	}

int EOF_Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextMySQL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EOF_Packet"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EOF_Packet",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "warnings"
	warnings_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status"
	status_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	update_state_ = t_context->connection()->update_state(COMMAND_PHASE);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

MySQL_Flow::MySQL_Flow(MySQL_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

MySQL_Flow::~MySQL_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void MySQL_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new MySQL_PDU(is_orig());
				flow_buffer_->NewFrame(0, false);
				context_ = new ContextMySQL(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			while ( ! t_dataunit_parsing_complete && flow_buffer_->ready() )
				{
				const_byteptr t_begin_of_data = flow_buffer()->begin();
				const_byteptr t_end_of_data = flow_buffer()->end();
				t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
				if ( t_dataunit_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		flow_buffer_->DiscardData();
		throw;
		}
	}

void MySQL_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void MySQL_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
bool MySQL_Flow::proc_mysql_initial_handshake_packet(Initial_Handshake_Packet * msg)
	{

		if ( mysql_server_version )
			{
			if ( msg->version() == 10 )
				BifEvent::generate_mysql_server_version(connection()->bro_analyzer(),
														connection()->bro_analyzer()->Conn(),
														bytestring_to_val(msg->handshake10()->server_version()));
			if ( msg->version() == 9 )
				BifEvent::generate_mysql_server_version(connection()->bro_analyzer(),
														connection()->bro_analyzer()->Conn(),
														bytestring_to_val(msg->handshake9()->server_version()));
			}
		return true;
		
	}

bool MySQL_Flow::proc_mysql_handshake_response_packet(Handshake_Response_Packet * msg)
	{

		if ( msg->version() == 9 || msg->version() == 10 )
			connection()->bro_analyzer()->ProtocolConfirmation();

		if ( mysql_handshake )
			{
			if ( msg->version() == 10 )
				BifEvent::generate_mysql_handshake(connection()->bro_analyzer(),
									    		   connection()->bro_analyzer()->Conn(),
													bytestring_to_val(msg->v10_response()->username()));
			if ( msg->version() == 9 )
				BifEvent::generate_mysql_handshake(connection()->bro_analyzer(),
									    		   connection()->bro_analyzer()->Conn(),
								    	    	   bytestring_to_val(msg->v9_response()->username()));
			}
		return true;
		
	}

bool MySQL_Flow::proc_mysql_command_request_packet(Command_Request_Packet * msg)
	{

		if ( mysql_command_request )
			BifEvent::generate_mysql_command_request(connection()->bro_analyzer(),
													 connection()->bro_analyzer()->Conn(),
													 msg->command(),
													 bytestring_to_val(msg->arg()));
		return true;
		
	}

bool MySQL_Flow::proc_err_packet(ERR_Packet * msg)
	{

		if ( mysql_error )
			BifEvent::generate_mysql_error(connection()->bro_analyzer(),
										   connection()->bro_analyzer()->Conn(),
										   msg->code(),
										   bytestring_to_val(msg->msg()));
		return true;
		
	}

bool MySQL_Flow::proc_ok_packet(OK_Packet * msg)
	{

		if ( mysql_ok )
			BifEvent::generate_mysql_ok(connection()->bro_analyzer(),
										connection()->bro_analyzer()->Conn(),
										msg->rows());
		return true;
		
	}

bool MySQL_Flow::proc_resultset(Resultset * msg)
	{

		if ( mysql_ok )
			BifEvent::generate_mysql_ok(connection()->bro_analyzer(),
										connection()->bro_analyzer()->Conn(),
										msg->rows()->size());
		return true;
		
	}

} // namespace MySQL
}  // namespace binpac
