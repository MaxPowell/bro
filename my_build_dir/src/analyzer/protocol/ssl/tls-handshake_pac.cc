// This file is automatically generated from /home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/ubuntu/bro/my_build_dir/src/analyzer/protocol/ssl/tls-handshake_pac.h"

namespace binpac {







namespace TLSHandshake {
ContextTLSHandshake::ContextTLSHandshake(Handshake_Conn * connection, Handshake_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextTLSHandshake::~ContextTLSHandshake()
	{
	}

Handshake_Conn::Handshake_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new Handshake_Flow(this, true);
	downflow_ = new Handshake_Flow(this, false);
	bro_analyzer_ = bro_analyzer;

		chosen_cipher_ = NO_CHOSEN_CIPHER;
		chosen_version_ = UNKNOWN_VERSION;
	
	}

Handshake_Conn::~Handshake_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void Handshake_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void Handshake_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void Handshake_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

int Handshake_Conn::chosen_cipher()
	{
 return chosen_cipher_; 
	}

bool Handshake_Conn::set_cipher(uint32 cipher)
	{

		chosen_cipher_ = cipher;
		return true;
		
	}

int Handshake_Conn::chosen_version()
	{
 return chosen_version_; 
	}

bool Handshake_Conn::set_version(uint16 version)
	{

		chosen_version_ = version;
		return true;
		
	}

bool Handshake_Conn::proc_client_hello(uint16 version, double ts, bytestring const & client_random, vector<uint8> * session_id, vector<uint16> * cipher_suites16, vector<uint24 *> * cipher_suites24)
	{

		if ( ! version_ok(version) )
			{
			bro_analyzer()->ProtocolViolation(fmt("unsupported client SSL version 0x%04x", version));
			bro_analyzer()->SetSkip(true);
			}
		else
			bro_analyzer()->ProtocolConfirmation();

		if ( ssl_client_hello )
			{
			vector<int>* cipher_suites = new vector<int>();
			if ( cipher_suites16 )
				std::copy(cipher_suites16->begin(), cipher_suites16->end(), std::back_inserter(*cipher_suites));
			else
				std::transform(cipher_suites24->begin(), cipher_suites24->end(), std::back_inserter(*cipher_suites), to_int());

			VectorVal* cipher_vec = new VectorVal(internal_type("index_vec")->AsVectorType());
			for ( unsigned int i = 0; i < cipher_suites->size(); ++i )
				{
				Val* ciph = new Val((*cipher_suites)[i], TYPE_COUNT);
				cipher_vec->Assign(i, ciph);
				}

			BifEvent::generate_ssl_client_hello(bro_analyzer(), bro_analyzer()->Conn(),
							version, ts, new StringVal(client_random.length(),
							(const char*) client_random.data()),
							to_string_val(session_id),
							cipher_vec);

			delete cipher_suites;
			}

		return true;
		
	}

bool Handshake_Conn::proc_server_hello(uint16 version, double ts, bytestring const & server_random, vector<uint8> * session_id, vector<uint16> * cipher_suites16, vector<uint24 *> * cipher_suites24, uint8 comp_method)
	{

		if ( ! version_ok(version) )
			{
			bro_analyzer()->ProtocolViolation(fmt("unsupported server SSL version 0x%04x", version));
			bro_analyzer()->SetSkip(true);
			}

		if ( ssl_server_hello )
			{
			vector<int>* ciphers = new vector<int>();

			if ( cipher_suites16 )
				std::copy(cipher_suites16->begin(), cipher_suites16->end(), std::back_inserter(*ciphers));
			else
				std::transform(cipher_suites24->begin(), cipher_suites24->end(), std::back_inserter(*ciphers), to_int());

			BifEvent::generate_ssl_server_hello(bro_analyzer(),
							bro_analyzer()->Conn(),
							version, ts, new StringVal(server_random.length(),
							(const char*) server_random.data()),
							to_string_val(session_id),
							ciphers->size()==0 ? 0 : ciphers->at(0), comp_method);

			delete ciphers;
			}

		return true;
		
	}

bool Handshake_Conn::proc_certificate(bool is_orig, vector<bytestring> * certificates)
	{

		if ( certificates->size() == 0 )
			return true;

		ODesc common;
		common.AddRaw("Analyzer::ANALYZER_SSL");
		common.Add(bro_analyzer()->Conn()->StartTime());
		common.AddRaw(is_orig ? "T" : "F", 1);
		bro_analyzer()->Conn()->IDString(&common);

		static const string user_mime = "application/x-x509-user-cert";
		static const string ca_mime = "application/x-x509-ca-cert";

		for ( unsigned int i = 0; i < certificates->size(); ++i )
			{
			const bytestring& cert = (*certificates)[i];

			ODesc file_handle;
			file_handle.Add(common.Description());
			file_handle.Add(i);

			string file_id = file_mgr->HashHandle(file_handle.Description());

			file_mgr->DataIn(reinterpret_cast<const u_char*>(cert.data()),
			                 cert.length(), bro_analyzer()->GetAnalyzerTag(),
			                 bro_analyzer()->Conn(), is_orig, file_id, i == 0 ? user_mime : ca_mime);
			file_mgr->EndOfFile(file_id);
			}
		return true;
		
	}

bool Handshake_Conn::proc_session_ticket_handshake(SessionTicketHandshake * rec, bool is_orig)
	{

		if ( ssl_session_ticket_handshake )
			{
			BifEvent::generate_ssl_session_ticket_handshake(bro_analyzer(),
							bro_analyzer()->Conn(),
							rec->ticket_lifetime_hint(),
							new StringVal(rec->data().length(), (const char*) rec->data().data()));
			}
		return true;
		
	}

bool Handshake_Conn::proc_ssl_extension(HandshakeRecord * rec, int type, const_bytestring const & sourcedata)
	{

		// We cheat a little bit here. We want to throw this event
		// for every extension we encounter, even those that are
		// handled by more specialized events later. To access the
		// parsed data, we use sourcedata, which contains the whole
		// data blob of the extension, including headers. We skip
		// over those (4 bytes).
		size_t length = sourcedata.length();
		if ( length < 4 )
			{
			// This should be impossible due to the binpac parser
			// and protocol description
			bro_analyzer()->ProtocolViolation(fmt("Impossible extension length: %zu", length));
			bro_analyzer()->SetSkip(true);
			return true;
			}

		length -= 4;
		const unsigned char* data = sourcedata.begin() + 4;

		if ( ssl_extension )
			BifEvent::generate_ssl_extension(bro_analyzer(),
						bro_analyzer()->Conn(), rec->is_orig(), type,
						new StringVal(length, reinterpret_cast<const char*>(data)));
		return true;
		
	}

bool Handshake_Conn::proc_ec_point_formats(HandshakeRecord * rec, vector<uint8> * point_format_list)
	{

		VectorVal* points = new VectorVal(internal_type("index_vec")->AsVectorType());

		if ( point_format_list )
			{
			for ( unsigned int i = 0; i < point_format_list->size(); ++i )
				points->Assign(i, new Val((*point_format_list)[i], TYPE_COUNT));
			}

		BifEvent::generate_ssl_extension_ec_point_formats(bro_analyzer(), bro_analyzer()->Conn(),
		   rec->is_orig(), points);

		return true;
		
	}

bool Handshake_Conn::proc_elliptic_curves(HandshakeRecord * rec, vector<uint16> * list)
	{

		VectorVal* curves = new VectorVal(internal_type("index_vec")->AsVectorType());

		if ( list )
			{
			for ( unsigned int i = 0; i < list->size(); ++i )
				curves->Assign(i, new Val((*list)[i], TYPE_COUNT));
			}

		BifEvent::generate_ssl_extension_elliptic_curves(bro_analyzer(), bro_analyzer()->Conn(),
		   rec->is_orig(), curves);

		return true;
		
	}

bool Handshake_Conn::proc_client_key_share(HandshakeRecord * rec, vector<KeyShareEntry *> * keyshare)
	{

		VectorVal* nglist = new VectorVal(internal_type("index_vec")->AsVectorType());

		if ( keyshare )
			{
			for ( unsigned int i = 0; i < keyshare->size(); ++i )
				nglist->Assign(i, new Val((*keyshare)[i]->namedgroup(), TYPE_COUNT));
			}

		BifEvent::generate_ssl_extension_key_share(bro_analyzer(), bro_analyzer()->Conn(), rec->is_orig(), nglist);
		return true;
		
	}

bool Handshake_Conn::proc_server_key_share(HandshakeRecord * rec, KeyShareEntry * keyshare)
	{

		VectorVal* nglist = new VectorVal(internal_type("index_vec")->AsVectorType());

		nglist->Assign(0u, new Val(keyshare->namedgroup(), TYPE_COUNT));
		BifEvent::generate_ssl_extension_key_share(bro_analyzer(), bro_analyzer()->Conn(), rec->is_orig(), nglist);
		return true;
		
	}

bool Handshake_Conn::proc_signature_algorithm(HandshakeRecord * rec, vector<SignatureAndHashAlgorithm *> * supported_signature_algorithms)
	{

		VectorVal* slist = new VectorVal(internal_type("signature_and_hashalgorithm_vec")->AsVectorType());

		if ( supported_signature_algorithms )
			{
			for ( unsigned int i = 0; i < supported_signature_algorithms->size(); ++i )
				{
				RecordVal* el = new RecordVal(BifType::Record::SSL::SignatureAndHashAlgorithm);
				el->Assign(0, new Val((*supported_signature_algorithms)[i]->HashAlgorithm(), TYPE_COUNT));
				el->Assign(1, new Val((*supported_signature_algorithms)[i]->SignatureAlgorithm(), TYPE_COUNT));
				slist->Assign(i, el);
				}
			}

		BifEvent::generate_ssl_extension_signature_algorithm(bro_analyzer(), bro_analyzer()->Conn(), rec->is_orig(), slist);

		return true;
		
	}

bool Handshake_Conn::proc_apnl(HandshakeRecord * rec, vector<ProtocolName *> * protocols)
	{

		VectorVal* plist = new VectorVal(internal_type("string_vec")->AsVectorType());

		if ( protocols )
			{
			for ( unsigned int i = 0; i < protocols->size(); ++i )
				plist->Assign(i, new StringVal((*protocols)[i]->name().length(), (const char*) (*protocols)[i]->name().data()));
			}

		BifEvent::generate_ssl_extension_application_layer_protocol_negotiation(bro_analyzer(), bro_analyzer()->Conn(),
											rec->is_orig(), plist);

		return true;
		
	}

bool Handshake_Conn::proc_server_name(HandshakeRecord * rec, vector<ServerName *> * list)
	{

		VectorVal* servers = new VectorVal(internal_type("string_vec")->AsVectorType());

		if ( list )
			{
			for ( unsigned int i = 0, j = 0; i < list->size(); ++i )
				{
				ServerName* servername = (*list)[i];
				if ( servername->name_type() != 0 )
					{
					bro_analyzer()->Weird(fmt("Encountered unknown type in server name ssl extension: %d", servername->name_type()));
					continue;
					}

				if ( servername->host_name() )
					servers->Assign(j++, new StringVal(servername->host_name()->host_name().length(), (const char*) servername->host_name()->host_name().data()));
				else
					bro_analyzer()->Weird("Empty server_name extension in ssl connection");
				}
			}

		BifEvent::generate_ssl_extension_server_name(bro_analyzer(), bro_analyzer()->Conn(),
		   rec->is_orig(), servers);

		return true;
		
	}

bool Handshake_Conn::proc_supported_versions(HandshakeRecord * rec, vector<uint16> * versions_list)
	{

		VectorVal* versions = new VectorVal(internal_type("index_vec")->AsVectorType());

		if ( versions_list )
			{
			for ( unsigned int i = 0; i < versions_list->size(); ++i )
				versions->Assign(i, new Val((*versions_list)[i], TYPE_COUNT));
			}

		BifEvent::generate_ssl_extension_supported_versions(bro_analyzer(), bro_analyzer()->Conn(),
			rec->is_orig(), versions);

		return true;
		
	}

bool Handshake_Conn::proc_one_supported_version(HandshakeRecord * rec, uint16 version)
	{

		VectorVal* versions = new VectorVal(internal_type("index_vec")->AsVectorType());
		versions->Assign(0u, new Val(version, TYPE_COUNT));

		BifEvent::generate_ssl_extension_supported_versions(bro_analyzer(), bro_analyzer()->Conn(),
			rec->is_orig(), versions);

		return true;
		
	}

bool Handshake_Conn::proc_psk_key_exchange_modes(HandshakeRecord * rec, vector<uint8> * mode_list)
	{

		VectorVal* modes = new VectorVal(internal_type("index_vec")->AsVectorType());

		if ( mode_list )
			{
			for ( unsigned int i = 0; i < mode_list->size(); ++i )
				modes->Assign(i, new Val((*mode_list)[i], TYPE_COUNT));
			}

		BifEvent::generate_ssl_extension_psk_key_exchange_modes(bro_analyzer(), bro_analyzer()->Conn(),
			rec->is_orig(), modes);

		return true;
		
	}

bool Handshake_Conn::proc_v3_certificate(bool is_orig, vector<X509Certificate *> * cl)
	{

		vector<X509Certificate*>* certs = cl;
		vector<bytestring>* cert_list = new vector<bytestring>();

		std::transform(certs->begin(), certs->end(),
		std::back_inserter(*cert_list), extract_certs());

		bool ret = proc_certificate(is_orig, cert_list);
		delete cert_list;
		return ret;
		
	}

bool Handshake_Conn::proc_unknown_handshake(HandshakeRecord * hs, bool is_orig)
	{

		bro_analyzer()->ProtocolViolation(fmt("unknown handshake message (%d) from %s",
			hs->msg_type(), orig_label(is_orig).c_str()));
		return true;
		
	}

bool Handshake_Conn::proc_certificate_status(HandshakeRecord * rec, uint8 status_type, bytestring const & response)
	{

		ODesc common;
		common.AddRaw("Analyzer::ANALYZER_SSL");
		common.Add(bro_analyzer()->Conn()->StartTime());
		common.AddRaw("F");
		bro_analyzer()->Conn()->IDString(&common);

		if ( status_type == 1 ) // ocsp
			{
			ODesc file_handle;
			file_handle.Add(common.Description());
			file_handle.Add("ocsp");

			string file_id = file_mgr->HashHandle(file_handle.Description());

			file_mgr->DataIn(reinterpret_cast<const u_char*>(response.data()),
			                 response.length(), bro_analyzer()->GetAnalyzerTag(),
			                 bro_analyzer()->Conn(), false, file_id, "application/ocsp-response");

			BifEvent::generate_ssl_stapled_ocsp(bro_analyzer(),
							    bro_analyzer()->Conn(), rec->is_orig(),
							    new StringVal(response.length(),
							    (const char*) response.data()));

			file_mgr->EndOfFile(file_id);
			}

		return true;
		
	}

bool Handshake_Conn::proc_ecdhe_server_key_exchange(EcdheServerKeyExchange * kex)
	{

		if ( kex->curve_type() != NAMED_CURVE )
			return true;

		BifEvent::generate_ssl_server_curve(bro_analyzer(),
			bro_analyzer()->Conn(), kex->params()->curve());
		BifEvent::generate_ssl_ecdh_server_params(bro_analyzer(),
			bro_analyzer()->Conn(), kex->params()->curve(), new StringVal(kex->params()->point().length(), (const char*)kex->params()->point().data()));

		RecordVal* ha = new RecordVal(BifType::Record::SSL::SignatureAndHashAlgorithm);
		if ( kex->signed_params()->uses_signature_and_hashalgorithm() )
			{
			ha->Assign(0, new Val(kex->signed_params()->algorithm()->HashAlgorithm(), TYPE_COUNT));
			ha->Assign(1, new Val(kex->signed_params()->algorithm()->SignatureAlgorithm(), TYPE_COUNT));
			}
			else
			{
			// set to impossible value
			ha->Assign(0, new Val(256, TYPE_COUNT));
			ha->Assign(1, new Val(256, TYPE_COUNT));
			}

		BifEvent::generate_ssl_server_signature(bro_analyzer(),
			bro_analyzer()->Conn(), ha, new StringVal(kex->signed_params()->signature().length(), (const char*)(kex->signed_params()->signature()).data()));

		return true;
		
	}

bool Handshake_Conn::proc_ecdh_anon_server_key_exchange(EcdhAnonServerKeyExchange * kex)
	{

		if ( kex->curve_type() != NAMED_CURVE )
			return true;

		BifEvent::generate_ssl_server_curve(bro_analyzer(),
			bro_analyzer()->Conn(), kex->params()->curve());
		BifEvent::generate_ssl_ecdh_server_params(bro_analyzer(),
			bro_analyzer()->Conn(), kex->params()->curve(), new StringVal(kex->params()->point().length(), (const char*)kex->params()->point().data()));

		return true;
		
	}

bool Handshake_Conn::proc_rsa_client_key_exchange(HandshakeRecord * rec, bytestring const & rsa_pms)
	{

		BifEvent::generate_ssl_rsa_client_pms(bro_analyzer(), bro_analyzer()->Conn(), new StringVal(rsa_pms.length(), (const char*)rsa_pms.data()));
		return true;
		
	}

bool Handshake_Conn::proc_dh_client_key_exchange(HandshakeRecord * rec, bytestring const & Yc)
	{

		BifEvent::generate_ssl_dh_client_params(bro_analyzer(), bro_analyzer()->Conn(), new StringVal(Yc.length(), (const char*)Yc.data()));
		return true;
		
	}

bool Handshake_Conn::proc_ecdh_client_key_exchange(HandshakeRecord * rec, bytestring const & point)
	{

		BifEvent::generate_ssl_ecdh_client_params(bro_analyzer(), bro_analyzer()->Conn(), new StringVal(point.length(), (const char*)point.data()));
		return true;
		
	}

bool Handshake_Conn::proc_signedcertificatetimestamp(HandshakeRecord * rec, uint8 version, const_bytestring const & logid, uint64 timestamp, SignatureAndHashAlgorithm * digitally_signed_algorithms, const_bytestring const & digitally_signed_signature)
	{

		RecordVal* ha = new RecordVal(BifType::Record::SSL::SignatureAndHashAlgorithm);
		ha->Assign(0, new Val(digitally_signed_algorithms->HashAlgorithm(), TYPE_COUNT));
		ha->Assign(1, new Val(digitally_signed_algorithms->SignatureAlgorithm(), TYPE_COUNT));

		BifEvent::generate_ssl_extension_signed_certificate_timestamp(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig(),
			version,
			new StringVal(logid.length(), reinterpret_cast<const char*>(logid.begin())),
			timestamp,
			ha,
			new StringVal(digitally_signed_signature.length(), reinterpret_cast<const char*>(digitally_signed_signature.begin()))
		);

		return true;
		
	}

bool Handshake_Conn::proc_dhe_server_key_exchange(HandshakeRecord * rec, bytestring const & p, bytestring const & g, bytestring const & Ys, ServerKeyExchangeSignature * signed_params)
	{

		BifEvent::generate_ssl_dh_server_params(bro_analyzer(),
			bro_analyzer()->Conn(),
		  new StringVal(p.length(), (const char*) p.data()),
		  new StringVal(g.length(), (const char*) g.data()),
		  new StringVal(Ys.length(), (const char*) Ys.data())
		  );

		RecordVal* ha = new RecordVal(BifType::Record::SSL::SignatureAndHashAlgorithm);
		if ( signed_params->uses_signature_and_hashalgorithm() )
			{
			ha->Assign(0, new Val(signed_params->algorithm()->HashAlgorithm(), TYPE_COUNT));
			ha->Assign(1, new Val(signed_params->algorithm()->SignatureAlgorithm(), TYPE_COUNT));
			}
			else
			{
			// set to impossible value
			ha->Assign(0, new Val(256, TYPE_COUNT));
			ha->Assign(1, new Val(256, TYPE_COUNT));
			}

		BifEvent::generate_ssl_server_signature(bro_analyzer(),
			bro_analyzer()->Conn(), ha,
		  new StringVal(signed_params->signature().length(), (const char*)(signed_params->signature()).data())
		  );

		return true;
		
	}

bool Handshake_Conn::proc_dh_anon_server_key_exchange(HandshakeRecord * rec, bytestring const & p, bytestring const & g, bytestring const & Ys)
	{

		BifEvent::generate_ssl_dh_server_params(bro_analyzer(),
			bro_analyzer()->Conn(),
		  new StringVal(p.length(), (const char*) p.data()),
		  new StringVal(g.length(), (const char*) g.data()),
		  new StringVal(Ys.length(), (const char*) Ys.data())
		  );

		return true;
		
	}

bool Handshake_Conn::proc_handshake(bool is_orig, uint8 msg_type, uint24 * length)
	{

		BifEvent::generate_ssl_handshake_message(bro_analyzer(),
			bro_analyzer()->Conn(), is_orig, msg_type, to_int()(length));

		return true;
		
	}

uint24::uint24()
	{
	byte1_ = 0;
	byte2_ = 0;
	byte3_ = 0;
	}

uint24::~uint24()
	{
	}

int uint24::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "uint24"
	if ( t_begin_of_data + (3) > t_end_of_data || t_begin_of_data + (3) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("uint24",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte1"
	byte1_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte2"
	byte2_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte3"
	byte3_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

uint48::uint48()
	{
	byte1_ = 0;
	byte2_ = 0;
	byte3_ = 0;
	byte4_ = 0;
	byte5_ = 0;
	byte6_ = 0;
	}

uint48::~uint48()
	{
	}

int uint48::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "uint48"
	if ( t_begin_of_data + (6) > t_end_of_data || t_begin_of_data + (6) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("uint48",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte1"
	byte1_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte2"
	byte2_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte3"
	byte3_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte4"
	byte4_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte5"
	byte5_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte6"
	byte6_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}


string orig_label(bool is_orig)
		{
		return string(is_orig ? "originator" :"responder");
		}

StringVal * to_string_val(vector<uint8> * data)
	{

	char tmp[32];
	memset(tmp, 0, sizeof(tmp));

	// Just return an empty string if the string is longer than 32 bytes
	if ( data && data->size() <= 32 )
		{
		for ( unsigned int i = data->size(); i > 0; --i )
			tmp[i-1] = (*data)[i-1];
		}

	return new StringVal(32, tmp);
	
	}

bool version_ok(uint16 vers)
	{

	if ( vers >> 8 == 0x7F ) // 1.3 draft
		return true;

	switch ( vers ) {
	case SSLv20:
	case SSLv30:
	case TLSv10:
	case TLSv11:
	case TLSv12:
	case TLSv13:
	case DTLSv10:
	case DTLSv12:
		return true;

	default:
		return false;
	}
	
	}

uint32 const MAX_DTLS_HANDSHAKE_RECORD = 100000;
HandshakeRecord::HandshakeRecord(bool is_orig)
	{
	msg_type_ = 0;
	msg_length_ = 0;
	rec_ = 0;
	is_orig_ = is_orig;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

HandshakeRecord::~HandshakeRecord()
	{
	delete msg_length_;
	msg_length_ = 0;
	delete rec_;
	rec_ = 0;
	}

bool HandshakeRecord::ParseBuffer(flow_buffer_t t_flow_buffer, ContextTLSHandshake * t_context, int t_byteorder)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(4, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			// Checking out-of-bound for "HandshakeRecord:msg_length"
			if ( (t_begin_of_data + 1) + (3) > t_end_of_data || (t_begin_of_data + 1) + (3) < (t_begin_of_data + 1) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("HandshakeRecord:msg_length",
					(1) + (3), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "msg_length"
			msg_length_ = new uint24();
			msg_length_->Parse((t_begin_of_data + 1), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_flow_buffer->GrowFrame( ( to_int()(msg_length()) + 4 ) );
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				// Parse "msg_type"
				msg_type_ = *((uint8 const *) (t_begin_of_data));
				// Evaluate 'let' and 'withinput' fields
				
				
				// Parse "rec"
				rec_ = new Handshake(this);
				int t_rec__size;
				t_rec__size = rec_->Parse((t_begin_of_data + 4), t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

Handshake::Handshake(HandshakeRecord * rec)
	{
	val_case_index_ = -1;
	hello_request_ = 0;
	client_hello_ = 0;
	server_hello_ = 0;
	hello_verify_request_ = 0;
	session_ticket_ = 0;
	certificate_ = 0;
	server_key_exchange_ = 0;
	certificate_request_ = 0;
	server_hello_done_ = 0;
	certificate_verify_ = 0;
	client_key_exchange_ = 0;
	finished_ = 0;
	certificate_status_ = 0;
	unknown_handshake_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Handshake::~Handshake()
	{
	switch ( val_case_index() )
		{
		case 0:
			// Clean up "hello_request"
			{
			delete hello_request_;
			hello_request_ = 0;
			}
			break;
		case 1:
			// Clean up "client_hello"
			{
			delete client_hello_;
			client_hello_ = 0;
			}
			break;
		case 2:
			// Clean up "server_hello"
			{
			delete server_hello_;
			server_hello_ = 0;
			}
			break;
		case 3:
			// Clean up "hello_verify_request"
			{
			delete hello_verify_request_;
			hello_verify_request_ = 0;
			}
			break;
		case 4:
			// Clean up "session_ticket"
			{
			delete session_ticket_;
			session_ticket_ = 0;
			}
			break;
		case 11:
			// Clean up "certificate"
			{
			delete certificate_;
			certificate_ = 0;
			}
			break;
		case 12:
			// Clean up "server_key_exchange"
			{
			delete server_key_exchange_;
			server_key_exchange_ = 0;
			}
			break;
		case 13:
			// Clean up "certificate_request"
			{
			delete certificate_request_;
			certificate_request_ = 0;
			}
			break;
		case 14:
			// Clean up "server_hello_done"
			{
			delete server_hello_done_;
			server_hello_done_ = 0;
			}
			break;
		case 15:
			// Clean up "certificate_verify"
			{
			delete certificate_verify_;
			certificate_verify_ = 0;
			}
			break;
		case 16:
			// Clean up "client_key_exchange"
			{
			delete client_key_exchange_;
			client_key_exchange_ = 0;
			}
			break;
		case 20:
			// Clean up "finished"
			{
			delete finished_;
			finished_ = 0;
			}
			break;
		case 21:
			// Clean up "certificate_url"
			{
			}
			break;
		case 22:
			// Clean up "certificate_status"
			{
			delete certificate_status_;
			certificate_status_ = 0;
			}
			break;
		default:
			// Clean up "unknown_handshake"
			{
			delete unknown_handshake_;
			unknown_handshake_ = 0;
			}
			break;
		}
	}

int Handshake::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = rec()->msg_type();
	switch ( val_case_index() )
		{
		case 0:
			// Parse "hello_request"
			{
			hello_request_ = new HelloRequest(rec());
			hello_request_->Parse(0, 0, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		case 1:
			// Parse "client_hello"
			{
			client_hello_ = new ClientHello(rec());
			int t_client_hello__size;
			t_client_hello__size = client_hello_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_client_hello__size;
			}
			break;
		case 2:
			// Parse "server_hello"
			{
			server_hello_ = new ServerHelloChoice(rec());
			int t_server_hello__size;
			t_server_hello__size = server_hello_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_server_hello__size;
			}
			break;
		case 3:
			// Parse "hello_verify_request"
			{
			hello_verify_request_ = new HelloVerifyRequest(rec());
			int t_hello_verify_request__size;
			t_hello_verify_request__size = hello_verify_request_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_hello_verify_request__size;
			}
			break;
		case 4:
			// Parse "session_ticket"
			{
			session_ticket_ = new SessionTicketHandshake(rec());
			int t_session_ticket__size;
			t_session_ticket__size = session_ticket_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_session_ticket__size;
			}
			break;
		case 11:
			// Parse "certificate"
			{
			certificate_ = new Certificate(rec());
			int t_certificate__size;
			t_certificate__size = certificate_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_certificate__size;
			}
			break;
		case 12:
			// Parse "server_key_exchange"
			{
			server_key_exchange_ = new ServerKeyExchange(rec());
			int t_server_key_exchange__size;
			t_server_key_exchange__size = server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_server_key_exchange__size;
			}
			break;
		case 13:
			// Parse "certificate_request"
			{
			certificate_request_ = new CertificateRequest(rec());
			int t_certificate_request__size;
			t_certificate_request__size = certificate_request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_certificate_request__size;
			}
			break;
		case 14:
			// Parse "server_hello_done"
			{
			server_hello_done_ = new ServerHelloDone(rec());
			server_hello_done_->Parse(0, 0, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		case 15:
			// Parse "certificate_verify"
			{
			certificate_verify_ = new CertificateVerify(rec());
			int t_certificate_verify__size;
			t_certificate_verify__size = certificate_verify_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_certificate_verify__size;
			}
			break;
		case 16:
			// Parse "client_key_exchange"
			{
			client_key_exchange_ = new ClientKeyExchange(rec());
			int t_client_key_exchange__size;
			t_client_key_exchange__size = client_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_client_key_exchange__size;
			}
			break;
		case 20:
			// Parse "finished"
			{
			finished_ = new Finished(rec());
			int t_finished__size;
			t_finished__size = finished_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_finished__size;
			}
			break;
		case 21:
			// Parse "certificate_url"
			{
			int t_certificate_url_string_length;
			t_certificate_url_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_certificate_url__size;
			t_certificate_url__size = t_certificate_url_string_length;
			// check for negative sizes
			if ( t_certificate_url_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:46", t_certificate_url_string_length);
			certificate_url_.init(t_begin_of_data, t_certificate_url_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_certificate_url__size;
			}
			break;
		case 22:
			// Parse "certificate_status"
			{
			certificate_status_ = new CertificateStatus(rec());
			int t_certificate_status__size;
			t_certificate_status__size = certificate_status_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_certificate_status__size;
			}
			break;
		default:
			// Parse "unknown_handshake"
			{
			unknown_handshake_ = new UnknownHandshake(rec(), rec()->is_orig());
			int t_unknown_handshake__size;
			t_unknown_handshake__size = unknown_handshake_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown_handshake__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_handshake(rec()->is_orig(), rec()->msg_type(), rec()->msg_length());
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

HandshakePDU::HandshakePDU(bool is_orig)
	{
	records_ = 0;
	records__elem_ = 0;
	records__arraylength_ = 0;
	records__elem__it_ = 0;
	records__elem__it_ = -1;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	parsing_state_ = 0;
	parsing_state_ = 0;
	}

HandshakePDU::~HandshakePDU()
	{
	delete records__elem_;
	records__elem_ = 0;
	if ( records_ )
		{
		for ( int i = 0; i < (int) records_->size(); ++i )
			{
			HandshakeRecord * records__elem_ = (*records_)[i];
			delete records__elem_;
			records__elem_ = 0;
			}
		}
	delete records_;
	}

bool HandshakePDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextTLSHandshake * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "records"
		if ( ! records_ )
			{
			}
		parsing_state_ = 1;
		/* fall through */
	case 1:
		{
		bool t_records_parsing_complete;
		t_records_parsing_complete = false;
		if ( records__elem__it_ < 0 )
			{
			// Initialize only once
			records__elem__it_ = 0;
			records_ = new vector<HandshakeRecord *>;
			}
		for (; /* forever */; ++records__elem__it_)
			{
			if ( ! records__elem_ )
				{
				records__elem_ = new HandshakeRecord(is_orig());
				}
			bool t_records__elem_parsing_complete;
			t_records__elem_parsing_complete = false;
			while ( ! t_records__elem_parsing_complete && t_flow_buffer->ready() )
				{
				const_byteptr t_begin_of_data = t_flow_buffer->begin();
				const_byteptr t_end_of_data = t_flow_buffer->end();
				t_records__elem_parsing_complete = records__elem_->ParseBuffer(t_flow_buffer, t_context, byteorder());
				if ( t_records__elem_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			if ( ! t_records__elem_parsing_complete )
				goto need_more_data;
			delete records__elem_;
			records__elem_ = 0;
			}
	end_of_records: ;
		if ( t_records_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_records_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

UnknownHandshake::UnknownHandshake(HandshakeRecord * hs, bool is_orig)
	{
	hs_ = hs;
	is_orig_ = is_orig;
	proc_ = 0;
	}

UnknownHandshake::~UnknownHandshake()
	{
	}

int UnknownHandshake::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:56", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_UnknownHandshake__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_UnknownHandshake__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_unknown_handshake(hs(), is_orig());
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownHandshake__size) <= t_end_of_data);
	return t_UnknownHandshake__size;
	}

HelloRequest::HelloRequest(HandshakeRecord * rec)
	{
	rec_ = rec;
	}

HelloRequest::~HelloRequest()
	{
	}

int HelloRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (0) <= t_end_of_data);
	return 0;
	}

ClientHello::ClientHello(HandshakeRecord * rec)
	{
	client_version_ = 0;
	gmt_unix_time_ = 0;
	session_len_ = 0;
	session_id_ = 0;
	session_id__elem_ = 0;
	dtls_cookie_case_index_ = -1;
	cookie_ = 0;
	csuit_len_ = 0;
	csuits_ = 0;
	csuits__elem_ = 0;
	cmeth_len_ = 0;
	cmeths_ = 0;
	cmeths__elem_ = 0;
	ext_len_ = 0;
	ext_len__elem_ = 0;
	extensions_ = 0;
	extensions__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ClientHello::~ClientHello()
	{
	random_bytes_.free();
	delete session_id_;
	switch ( dtls_cookie_case_index() )
		{
		case 65279:
		case 65277:
			// Clean up "cookie"
			{
			delete cookie_;
			cookie_ = 0;
			}
			break;
		default:
			// Clean up "nothing"
			{
			nothing_.free();
			}
			break;
		}
	delete csuits_;
	delete cmeths_;
	delete ext_len_;
	delete extensions__elem_;
	extensions__elem_ = 0;
	if ( extensions() )
		{
		for ( int i = 0; i < (int) extensions()->size(); ++i )
			{
			SSLExtension * extensions__elem_ = (*extensions_)[i];
			delete extensions__elem_;
			extensions__elem_ = 0;
			}
		}
	delete extensions_;
	}

int ClientHello::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ClientHello:gmt_unix_time"
	if ( (t_begin_of_data + 2) + (4) > t_end_of_data || (t_begin_of_data + 2) + (4) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:gmt_unix_time",
			(2) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "client_version"
	client_version_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "gmt_unix_time"
	gmt_unix_time_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "random_bytes"
	// Checking out-of-bound for "ClientHello:random_bytes"
	if ( (t_begin_of_data + 6) + (28) > t_end_of_data || (t_begin_of_data + 6) + (28) < (t_begin_of_data + 6) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:random_bytes",
			(6) + (28), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 6) + 28;
	int t_random_bytes_string_length;
	t_random_bytes_string_length = 28;
	int t_random_bytes__size;
	t_random_bytes__size = t_random_bytes_string_length;
	random_bytes_.init((t_begin_of_data + 6), t_random_bytes_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_random_bytes = (t_begin_of_data + 6) + (28);
	BINPAC_ASSERT(t_dataptr_after_random_bytes <= t_end_of_data);
	// Checking out-of-bound for "ClientHello:session_len"
	if ( t_dataptr_after_random_bytes + (1) > t_end_of_data || t_dataptr_after_random_bytes + (1) < t_dataptr_after_random_bytes )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:session_len",
			((t_dataptr_after_random_bytes - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "session_len"
	session_len_ = *((uint8 const *) (t_dataptr_after_random_bytes));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "session_id"
	int t_session_id__arraylength;
	t_session_id__arraylength = 0;
	t_session_id__arraylength = session_len();
	if ( t_begin_of_data + t_session_id__arraylength > t_end_of_data + 1 || t_begin_of_data + t_session_id__arraylength < t_begin_of_data )
		{
		t_session_id__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_session_id__arraylength < 0 )
		{
		t_session_id__arraylength = 0;
		}
	session_id__elem_ = 0;
	int t_session_id__elem__it;
	t_session_id__elem__it = 0;
	int t_session_id__size;
	session_id_ = new vector<uint8>;
	session_id_->reserve(t_session_id__arraylength);
	const_byteptr t_session_id__elem__dataptr = (t_dataptr_after_random_bytes + 1);
	for (; t_session_id__elem__it < t_session_id__arraylength; ++t_session_id__elem__it)
		{
		// Check &until(session_id__elem__dataptr >= end_of_data)
		if ( t_session_id__elem__dataptr >= t_end_of_data )
			{
			goto end_of_session_id;
			}
		// Checking out-of-bound for "ClientHello:session_id__elem"
		if ( t_session_id__elem__dataptr + (1) > t_end_of_data || t_session_id__elem__dataptr + (1) < t_session_id__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:session_id__elem",
				((t_session_id__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		session_id__elem_ = *((uint8 const *) (t_session_id__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		session_id_->push_back(session_id__elem_);
		t_session_id__elem__dataptr += 1;
		BINPAC_ASSERT(t_session_id__elem__dataptr <= t_end_of_data);
		}
end_of_session_id: ;
	t_session_id__size = t_session_id__elem__dataptr - ((t_dataptr_after_random_bytes + 1));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_session_id = (t_dataptr_after_random_bytes + 1) + (t_session_id__size);
	BINPAC_ASSERT(t_dataptr_after_session_id <= t_end_of_data);
	// Parse "dtls_cookie"
	int t_dtls_cookie__size;
	dtls_cookie_case_index_ = client_version();
	switch ( dtls_cookie_case_index() )
		{
		case 65279:
		case 65277:
			// Parse "cookie"
			{
			cookie_ = new ClientHelloCookie(rec());
			int t_cookie__size;
			t_cookie__size = cookie_->Parse(t_dataptr_after_session_id, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_dtls_cookie__size = t_cookie__size;
			}
			break;
		default:
			// Parse "nothing"
			{
			// Checking out-of-bound for "ClientHello:nothing"
			if ( t_dataptr_after_session_id + (0) > t_end_of_data || t_dataptr_after_session_id + (0) < t_dataptr_after_session_id )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("ClientHello:nothing",
					((t_dataptr_after_session_id - t_begin_of_data)) + (0), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_dataptr_after_session_id + 0;
			int t_nothing_string_length;
			t_nothing_string_length = 0;
			int t_nothing__size;
			t_nothing__size = t_nothing_string_length;
			nothing_.init(t_dataptr_after_session_id, t_nothing_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_dtls_cookie__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_dtls_cookie = t_dataptr_after_session_id + (t_dtls_cookie__size);
	BINPAC_ASSERT(t_dataptr_after_dtls_cookie <= t_end_of_data);
	// Checking out-of-bound for "ClientHello:csuit_len"
	if ( t_dataptr_after_dtls_cookie + (2) > t_end_of_data || t_dataptr_after_dtls_cookie + (2) < t_dataptr_after_dtls_cookie )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:csuit_len",
			((t_dataptr_after_dtls_cookie - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csuit_len"
	csuit_len_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_dtls_cookie)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "csuits"
	int t_csuits__arraylength;
	t_csuits__arraylength = 0;
	t_csuits__arraylength = csuit_len() / 2;
	if ( t_begin_of_data + t_csuits__arraylength > t_end_of_data + 1 || t_begin_of_data + t_csuits__arraylength < t_begin_of_data )
		{
		t_csuits__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_csuits__arraylength < 0 )
		{
		t_csuits__arraylength = 0;
		}
	csuits__elem_ = 0;
	int t_csuits__elem__it;
	t_csuits__elem__it = 0;
	int t_csuits__size;
	csuits_ = new vector<uint16>;
	csuits_->reserve(t_csuits__arraylength);
	const_byteptr t_csuits__elem__dataptr = (t_dataptr_after_dtls_cookie + 2);
	for (; t_csuits__elem__it < t_csuits__arraylength; ++t_csuits__elem__it)
		{
		// Check &until(csuits__elem__dataptr >= end_of_data)
		if ( t_csuits__elem__dataptr >= t_end_of_data )
			{
			goto end_of_csuits;
			}
		// Checking out-of-bound for "ClientHello:csuits__elem"
		if ( t_csuits__elem__dataptr + (2) > t_end_of_data || t_csuits__elem__dataptr + (2) < t_csuits__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:csuits__elem",
				((t_csuits__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		csuits__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_csuits__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		csuits_->push_back(csuits__elem_);
		t_csuits__elem__dataptr += 2;
		BINPAC_ASSERT(t_csuits__elem__dataptr <= t_end_of_data);
		}
end_of_csuits: ;
	t_csuits__size = t_csuits__elem__dataptr - ((t_dataptr_after_dtls_cookie + 2));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_csuits = (t_dataptr_after_dtls_cookie + 2) + (t_csuits__size);
	BINPAC_ASSERT(t_dataptr_after_csuits <= t_end_of_data);
	// Checking out-of-bound for "ClientHello:cmeth_len"
	if ( t_dataptr_after_csuits + (1) > t_end_of_data || t_dataptr_after_csuits + (1) < t_dataptr_after_csuits )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:cmeth_len",
			((t_dataptr_after_csuits - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cmeth_len"
	cmeth_len_ = *((uint8 const *) (t_dataptr_after_csuits));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cmeths"
	int t_cmeths__arraylength;
	t_cmeths__arraylength = 0;
	t_cmeths__arraylength = cmeth_len();
	if ( t_begin_of_data + t_cmeths__arraylength > t_end_of_data + 1 || t_begin_of_data + t_cmeths__arraylength < t_begin_of_data )
		{
		t_cmeths__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_cmeths__arraylength < 0 )
		{
		t_cmeths__arraylength = 0;
		}
	cmeths__elem_ = 0;
	int t_cmeths__elem__it;
	t_cmeths__elem__it = 0;
	int t_cmeths__size;
	cmeths_ = new vector<uint8>;
	cmeths_->reserve(t_cmeths__arraylength);
	const_byteptr t_cmeths__elem__dataptr = (t_dataptr_after_csuits + 1);
	for (; t_cmeths__elem__it < t_cmeths__arraylength; ++t_cmeths__elem__it)
		{
		// Check &until(cmeths__elem__dataptr >= end_of_data)
		if ( t_cmeths__elem__dataptr >= t_end_of_data )
			{
			goto end_of_cmeths;
			}
		// Checking out-of-bound for "ClientHello:cmeths__elem"
		if ( t_cmeths__elem__dataptr + (1) > t_end_of_data || t_cmeths__elem__dataptr + (1) < t_cmeths__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:cmeths__elem",
				((t_cmeths__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		cmeths__elem_ = *((uint8 const *) (t_cmeths__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		cmeths_->push_back(cmeths__elem_);
		t_cmeths__elem__dataptr += 1;
		BINPAC_ASSERT(t_cmeths__elem__dataptr <= t_end_of_data);
		}
end_of_cmeths: ;
	t_cmeths__size = t_cmeths__elem__dataptr - ((t_dataptr_after_csuits + 1));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_cmeths = (t_dataptr_after_csuits + 1) + (t_cmeths__size);
	BINPAC_ASSERT(t_dataptr_after_cmeths <= t_end_of_data);
	// Parse "ext_len"
	int t_ext_len__arraylength;
	t_ext_len__arraylength = 0;
	ext_len__elem_ = 0;
	int t_ext_len__elem__it;
	t_ext_len__elem__it = 0;
	int t_ext_len__size;
	ext_len_ = new vector<uint16>;
	const_byteptr t_ext_len__elem__dataptr = t_dataptr_after_cmeths;
	for (; /* forever */; ++t_ext_len__elem__it)
		{
		// Check &until(ext_len__elem__dataptr >= end_of_data)
		if ( t_ext_len__elem__dataptr >= t_end_of_data )
			{
			goto end_of_ext_len;
			}
		// Checking out-of-bound for "ClientHello:ext_len__elem"
		if ( t_ext_len__elem__dataptr + (2) > t_end_of_data || t_ext_len__elem__dataptr + (2) < t_ext_len__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:ext_len__elem",
				((t_ext_len__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		ext_len__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_ext_len__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		ext_len_->push_back(ext_len__elem_);
		t_ext_len__elem__dataptr += 2;
		BINPAC_ASSERT(t_ext_len__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
		if (  ( ext_len__elem_ == 0 || ext_len__elem_ != 0 )  )
			{
			goto end_of_ext_len;
			}
		}
end_of_ext_len: ;
	t_ext_len__size = t_ext_len__elem__dataptr - (t_dataptr_after_cmeths);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_ext_len = t_dataptr_after_cmeths + (t_ext_len__size);
	BINPAC_ASSERT(t_dataptr_after_ext_len <= t_end_of_data);
	// Parse "extensions"
	int t_extensions__arraylength;
	t_extensions__arraylength = 0;
	extensions__elem_ = 0;
	int t_extensions__elem__it;
	t_extensions__elem__it = 0;
	int t_extensions__size;
	extensions_ = new vector<SSLExtension *>;
	const_byteptr t_extensions__elem__dataptr = t_dataptr_after_ext_len;
	for (; /* forever */; ++t_extensions__elem__it)
		{
		// Check &until(extensions__elem__dataptr >= end_of_data)
		if ( t_extensions__elem__dataptr >= t_end_of_data )
			{
			extensions__elem_ = 0;
			goto end_of_extensions;
			}
		extensions__elem_ = new SSLExtension(rec());
		int t_extensions__elem__size;
		t_extensions__elem__size = extensions__elem_->Parse(t_extensions__elem__dataptr, t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		extensions_->push_back(extensions__elem_);
		t_extensions__elem__dataptr += t_extensions__elem__size;
		BINPAC_ASSERT(t_extensions__elem__dataptr <= t_end_of_data);
		extensions__elem_ = 0;
		}
end_of_extensions: ;
	t_extensions__size = t_extensions__elem__dataptr - (t_dataptr_after_ext_len);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ClientHello__size;
	const_byteptr const t_dataptr_after_extensions = t_dataptr_after_ext_len + (t_extensions__size);
	BINPAC_ASSERT(t_dataptr_after_extensions <= t_end_of_data);
	t_ClientHello__size = t_dataptr_after_extensions - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_client_hello(client_version(), gmt_unix_time(), random_bytes(), session_id(), csuits(), 0);
	BINPAC_ASSERT(t_begin_of_data + (t_ClientHello__size) <= t_end_of_data);
	return t_ClientHello__size;
	}

ClientHelloCookie::ClientHelloCookie(HandshakeRecord * rec)
	{
	cookie_len_ = 0;
	rec_ = rec;
	}

ClientHelloCookie::~ClientHelloCookie()
	{
	cookie_.free();
	}

int ClientHelloCookie::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Checking out-of-bound for "ClientHelloCookie:cookie_len"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHelloCookie:cookie_len",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cookie_len"
	cookie_len_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cookie"
	int t_cookie__size;
	t_cookie__size = cookie_len();
	// Checking out-of-bound for "ClientHelloCookie:cookie"
	if ( (t_begin_of_data + 1) + (t_cookie__size) > t_end_of_data || (t_begin_of_data + 1) + (t_cookie__size) < (t_begin_of_data + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHelloCookie:cookie",
			(1) + (t_cookie__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_cookie__size;
	int t_cookie_string_length;
	t_cookie_string_length = cookie_len();
	// check for negative sizes
	if ( t_cookie_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:93", t_cookie_string_length);
	cookie_.init((t_begin_of_data + 1), t_cookie_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ClientHelloCookie__size;
	const_byteptr const t_dataptr_after_cookie = (t_begin_of_data + 1) + (t_cookie__size);
	BINPAC_ASSERT(t_dataptr_after_cookie <= t_end_of_data);
	t_ClientHelloCookie__size = t_dataptr_after_cookie - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ClientHelloCookie__size) <= t_end_of_data);
	return t_ClientHelloCookie__size;
	}

ServerHelloChoice::ServerHelloChoice(HandshakeRecord * rec)
	{
	server_version0_ = 0;
	server_version1_ = 0;
	hello_case_index_ = -1;
	hello13_ = 0;
	helloclassic_ = 0;
	rec_ = rec;
	server_version_ = 0;
	parsed_version_ = 0;
	version_set_ = 0;
	}

ServerHelloChoice::~ServerHelloChoice()
	{
	switch ( hello_case_index() )
		{
		case 772:
		case 32512:
			// Clean up "hello13"
			{
			delete hello13_;
			hello13_ = 0;
			}
			break;
		default:
			// Clean up "helloclassic"
			{
			delete helloclassic_;
			helloclassic_ = 0;
			}
			break;
		}
	}

int ServerHelloChoice::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ServerHelloChoice:server_version1"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data || (t_begin_of_data + 1) + (1) < (t_begin_of_data + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHelloChoice:server_version1",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "server_version0"
	server_version0_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_version1"
	server_version1_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "hello"
	server_version_ =  ( server_version0() << 8 )  | server_version1();
	int t_t_var_001;
	switch ( server_version0() )
		{
		case 127:
			t_t_var_001 = 0x7F00;
			break;
		default:
			t_t_var_001 = server_version();
			break;
		}
	parsed_version_ = t_t_var_001;
	int t_hello__size;
	hello_case_index_ = parsed_version();
	switch ( hello_case_index() )
		{
		case 772:
		case 32512:
			// Parse "hello13"
			{
			hello13_ = new ServerHello13(rec(), server_version());
			int t_hello13__size;
			t_hello13__size = hello13_->Parse((t_begin_of_data + 2), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_hello__size = t_hello13__size;
			}
			break;
		default:
			// Parse "helloclassic"
			{
			helloclassic_ = new ServerHello(rec(), server_version());
			int t_helloclassic__size;
			t_helloclassic__size = helloclassic_->Parse((t_begin_of_data + 2), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_hello__size = t_helloclassic__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_ServerHelloChoice__size;
	const_byteptr const t_dataptr_after_hello = (t_begin_of_data + 2) + (t_hello__size);
	BINPAC_ASSERT(t_dataptr_after_hello <= t_end_of_data);
	t_ServerHelloChoice__size = t_dataptr_after_hello - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	version_set_ = t_context->connection()->set_version(server_version());
	BINPAC_ASSERT(t_begin_of_data + (t_ServerHelloChoice__size) <= t_end_of_data);
	return t_ServerHelloChoice__size;
	}

ServerHello::ServerHello(HandshakeRecord * rec, uint16 server_version)
	{
	gmt_unix_time_ = 0;
	session_len_ = 0;
	session_id_ = 0;
	session_id__elem_ = 0;
	cipher_suite_ = 0;
	cipher_suite__elem_ = 0;
	compression_method_ = 0;
	ext_len_ = 0;
	ext_len__elem_ = 0;
	extensions_ = 0;
	extensions__elem_ = 0;
	rec_ = rec;
	server_version_ = server_version;
	cipher_set_ = 0;
	proc_ = 0;
	}

ServerHello::~ServerHello()
	{
	random_bytes_.free();
	delete session_id_;
	delete cipher_suite_;
	delete ext_len_;
	delete extensions__elem_;
	extensions__elem_ = 0;
	if ( extensions() )
		{
		for ( int i = 0; i < (int) extensions()->size(); ++i )
			{
			SSLExtension * extensions__elem_ = (*extensions_)[i];
			delete extensions__elem_;
			extensions__elem_ = 0;
			}
		}
	delete extensions_;
	}

int ServerHello::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ServerHello:gmt_unix_time"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:gmt_unix_time",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "gmt_unix_time"
	gmt_unix_time_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "random_bytes"
	// Checking out-of-bound for "ServerHello:random_bytes"
	if ( (t_begin_of_data + 4) + (28) > t_end_of_data || (t_begin_of_data + 4) + (28) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:random_bytes",
			(4) + (28), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 28;
	int t_random_bytes_string_length;
	t_random_bytes_string_length = 28;
	int t_random_bytes__size;
	t_random_bytes__size = t_random_bytes_string_length;
	random_bytes_.init((t_begin_of_data + 4), t_random_bytes_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_random_bytes = (t_begin_of_data + 4) + (28);
	BINPAC_ASSERT(t_dataptr_after_random_bytes <= t_end_of_data);
	// Checking out-of-bound for "ServerHello:session_len"
	if ( t_dataptr_after_random_bytes + (1) > t_end_of_data || t_dataptr_after_random_bytes + (1) < t_dataptr_after_random_bytes )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:session_len",
			((t_dataptr_after_random_bytes - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "session_len"
	session_len_ = *((uint8 const *) (t_dataptr_after_random_bytes));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "session_id"
	int t_session_id__arraylength;
	t_session_id__arraylength = 0;
	t_session_id__arraylength = session_len();
	if ( t_begin_of_data + t_session_id__arraylength > t_end_of_data + 1 || t_begin_of_data + t_session_id__arraylength < t_begin_of_data )
		{
		t_session_id__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_session_id__arraylength < 0 )
		{
		t_session_id__arraylength = 0;
		}
	session_id__elem_ = 0;
	int t_session_id__elem__it;
	t_session_id__elem__it = 0;
	int t_session_id__size;
	session_id_ = new vector<uint8>;
	session_id_->reserve(t_session_id__arraylength);
	const_byteptr t_session_id__elem__dataptr = (t_dataptr_after_random_bytes + 1);
	for (; t_session_id__elem__it < t_session_id__arraylength; ++t_session_id__elem__it)
		{
		// Check &until(session_id__elem__dataptr >= end_of_data)
		if ( t_session_id__elem__dataptr >= t_end_of_data )
			{
			goto end_of_session_id;
			}
		// Checking out-of-bound for "ServerHello:session_id__elem"
		if ( t_session_id__elem__dataptr + (1) > t_end_of_data || t_session_id__elem__dataptr + (1) < t_session_id__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ServerHello:session_id__elem",
				((t_session_id__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		session_id__elem_ = *((uint8 const *) (t_session_id__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		session_id_->push_back(session_id__elem_);
		t_session_id__elem__dataptr += 1;
		BINPAC_ASSERT(t_session_id__elem__dataptr <= t_end_of_data);
		}
end_of_session_id: ;
	t_session_id__size = t_session_id__elem__dataptr - ((t_dataptr_after_random_bytes + 1));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_session_id = (t_dataptr_after_random_bytes + 1) + (t_session_id__size);
	BINPAC_ASSERT(t_dataptr_after_session_id <= t_end_of_data);
	// Checking out-of-bound for "ServerHello:compression_method"
	if ( (t_dataptr_after_session_id + 2) + (1) > t_end_of_data || (t_dataptr_after_session_id + 2) + (1) < (t_dataptr_after_session_id + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:compression_method",
			(((t_dataptr_after_session_id + 2) - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cipher_suite"
	int t_cipher_suite__arraylength;
	t_cipher_suite__arraylength = 0;
	t_cipher_suite__arraylength = 1;
	if ( t_begin_of_data + t_cipher_suite__arraylength > t_end_of_data + 1 || t_begin_of_data + t_cipher_suite__arraylength < t_begin_of_data )
		{
		t_cipher_suite__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_cipher_suite__arraylength < 0 )
		{
		t_cipher_suite__arraylength = 0;
		}
	cipher_suite__elem_ = 0;
	int t_cipher_suite__elem__it;
	t_cipher_suite__elem__it = 0;
	cipher_suite_ = new vector<uint16>;
	cipher_suite_->reserve(t_cipher_suite__arraylength);
	const_byteptr t_cipher_suite__elem__dataptr = t_dataptr_after_session_id;
	for (; t_cipher_suite__elem__it < t_cipher_suite__arraylength; ++t_cipher_suite__elem__it)
		{
		// Check &until(cipher_suite__elem__dataptr >= end_of_data)
		if ( t_cipher_suite__elem__dataptr >= t_end_of_data )
			{
			goto end_of_cipher_suite;
			}
		cipher_suite__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_cipher_suite__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		cipher_suite_->push_back(cipher_suite__elem_);
		t_cipher_suite__elem__dataptr += 2;
		BINPAC_ASSERT(t_cipher_suite__elem__dataptr <= t_end_of_data);
		}
end_of_cipher_suite: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "compression_method"
	compression_method_ = *((uint8 const *) ((t_dataptr_after_session_id + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ext_len"
	int t_ext_len__arraylength;
	t_ext_len__arraylength = 0;
	ext_len__elem_ = 0;
	int t_ext_len__elem__it;
	t_ext_len__elem__it = 0;
	int t_ext_len__size;
	ext_len_ = new vector<uint16>;
	const_byteptr t_ext_len__elem__dataptr = (t_dataptr_after_session_id + 3);
	for (; /* forever */; ++t_ext_len__elem__it)
		{
		// Check &until(ext_len__elem__dataptr >= end_of_data)
		if ( t_ext_len__elem__dataptr >= t_end_of_data )
			{
			goto end_of_ext_len;
			}
		// Checking out-of-bound for "ServerHello:ext_len__elem"
		if ( t_ext_len__elem__dataptr + (2) > t_end_of_data || t_ext_len__elem__dataptr + (2) < t_ext_len__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ServerHello:ext_len__elem",
				((t_ext_len__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		ext_len__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_ext_len__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		ext_len_->push_back(ext_len__elem_);
		t_ext_len__elem__dataptr += 2;
		BINPAC_ASSERT(t_ext_len__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
		if (  ( ext_len__elem_ == 0 || ext_len__elem_ != 0 )  )
			{
			goto end_of_ext_len;
			}
		}
end_of_ext_len: ;
	t_ext_len__size = t_ext_len__elem__dataptr - ((t_dataptr_after_session_id + 3));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_ext_len = (t_dataptr_after_session_id + 3) + (t_ext_len__size);
	BINPAC_ASSERT(t_dataptr_after_ext_len <= t_end_of_data);
	// Parse "extensions"
	int t_extensions__arraylength;
	t_extensions__arraylength = 0;
	extensions__elem_ = 0;
	int t_extensions__elem__it;
	t_extensions__elem__it = 0;
	int t_extensions__size;
	extensions_ = new vector<SSLExtension *>;
	const_byteptr t_extensions__elem__dataptr = t_dataptr_after_ext_len;
	for (; /* forever */; ++t_extensions__elem__it)
		{
		// Check &until(extensions__elem__dataptr >= end_of_data)
		if ( t_extensions__elem__dataptr >= t_end_of_data )
			{
			extensions__elem_ = 0;
			goto end_of_extensions;
			}
		extensions__elem_ = new SSLExtension(rec());
		int t_extensions__elem__size;
		t_extensions__elem__size = extensions__elem_->Parse(t_extensions__elem__dataptr, t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		extensions_->push_back(extensions__elem_);
		t_extensions__elem__dataptr += t_extensions__elem__size;
		BINPAC_ASSERT(t_extensions__elem__dataptr <= t_end_of_data);
		extensions__elem_ = 0;
		}
end_of_extensions: ;
	t_extensions__size = t_extensions__elem__dataptr - (t_dataptr_after_ext_len);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ServerHello__size;
	const_byteptr const t_dataptr_after_extensions = t_dataptr_after_ext_len + (t_extensions__size);
	BINPAC_ASSERT(t_dataptr_after_extensions <= t_end_of_data);
	t_ServerHello__size = t_dataptr_after_extensions - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	cipher_set_ = t_context->connection()->set_cipher((*(cipher_suite()))[0]);
	proc_ = t_context->connection()->proc_server_hello(server_version(), gmt_unix_time(), random_bytes(), session_id(), cipher_suite(), 0, compression_method());
	BINPAC_ASSERT(t_begin_of_data + (t_ServerHello__size) <= t_end_of_data);
	return t_ServerHello__size;
	}

ServerHello13::ServerHello13(HandshakeRecord * rec, uint16 server_version)
	{
	cipher_suite_ = 0;
	cipher_suite__elem_ = 0;
	ext_len_ = 0;
	ext_len__elem_ = 0;
	extensions_ = 0;
	extensions__elem_ = 0;
	rec_ = rec;
	server_version_ = server_version;
	cipher_set_ = 0;
	proc_ = 0;
	}

ServerHello13::~ServerHello13()
	{
	random_.free();
	delete cipher_suite_;
	delete ext_len_;
	delete extensions__elem_;
	extensions__elem_ = 0;
	if ( extensions() )
		{
		for ( int i = 0; i < (int) extensions()->size(); ++i )
			{
			SSLExtension * extensions__elem_ = (*extensions_)[i];
			delete extensions__elem_;
			extensions__elem_ = 0;
			}
		}
	delete extensions_;
	}

int ServerHello13::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Parse "random"
	// Checking out-of-bound for "ServerHello13:random"
	if ( t_begin_of_data + (32) > t_end_of_data || t_begin_of_data + (32) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello13:random",
			(0) + (32), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 32;
	int t_random_string_length;
	t_random_string_length = 32;
	int t_random__size;
	t_random__size = t_random_string_length;
	random_.init(t_begin_of_data, t_random_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_random = t_begin_of_data + (32);
	BINPAC_ASSERT(t_dataptr_after_random <= t_end_of_data);
	// Checking out-of-bound for "ServerHello13:cipher_suite"
	if ( t_dataptr_after_random + (2) > t_end_of_data || t_dataptr_after_random + (2) < t_dataptr_after_random )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello13:cipher_suite",
			((t_dataptr_after_random - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cipher_suite"
	int t_cipher_suite__arraylength;
	t_cipher_suite__arraylength = 0;
	t_cipher_suite__arraylength = 1;
	if ( t_begin_of_data + t_cipher_suite__arraylength > t_end_of_data + 1 || t_begin_of_data + t_cipher_suite__arraylength < t_begin_of_data )
		{
		t_cipher_suite__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_cipher_suite__arraylength < 0 )
		{
		t_cipher_suite__arraylength = 0;
		}
	cipher_suite__elem_ = 0;
	int t_cipher_suite__elem__it;
	t_cipher_suite__elem__it = 0;
	cipher_suite_ = new vector<uint16>;
	cipher_suite_->reserve(t_cipher_suite__arraylength);
	const_byteptr t_cipher_suite__elem__dataptr = t_dataptr_after_random;
	for (; t_cipher_suite__elem__it < t_cipher_suite__arraylength; ++t_cipher_suite__elem__it)
		{
		// Check &until(cipher_suite__elem__dataptr >= end_of_data)
		if ( t_cipher_suite__elem__dataptr >= t_end_of_data )
			{
			goto end_of_cipher_suite;
			}
		cipher_suite__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_cipher_suite__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		cipher_suite_->push_back(cipher_suite__elem_);
		t_cipher_suite__elem__dataptr += 2;
		BINPAC_ASSERT(t_cipher_suite__elem__dataptr <= t_end_of_data);
		}
end_of_cipher_suite: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ext_len"
	int t_ext_len__arraylength;
	t_ext_len__arraylength = 0;
	ext_len__elem_ = 0;
	int t_ext_len__elem__it;
	t_ext_len__elem__it = 0;
	int t_ext_len__size;
	ext_len_ = new vector<uint16>;
	const_byteptr t_ext_len__elem__dataptr = (t_dataptr_after_random + 2);
	for (; /* forever */; ++t_ext_len__elem__it)
		{
		// Check &until(ext_len__elem__dataptr >= end_of_data)
		if ( t_ext_len__elem__dataptr >= t_end_of_data )
			{
			goto end_of_ext_len;
			}
		// Checking out-of-bound for "ServerHello13:ext_len__elem"
		if ( t_ext_len__elem__dataptr + (2) > t_end_of_data || t_ext_len__elem__dataptr + (2) < t_ext_len__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ServerHello13:ext_len__elem",
				((t_ext_len__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		ext_len__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_ext_len__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		ext_len_->push_back(ext_len__elem_);
		t_ext_len__elem__dataptr += 2;
		BINPAC_ASSERT(t_ext_len__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
		if (  ( ext_len__elem_ == 0 || ext_len__elem_ != 0 )  )
			{
			goto end_of_ext_len;
			}
		}
end_of_ext_len: ;
	t_ext_len__size = t_ext_len__elem__dataptr - ((t_dataptr_after_random + 2));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_ext_len = (t_dataptr_after_random + 2) + (t_ext_len__size);
	BINPAC_ASSERT(t_dataptr_after_ext_len <= t_end_of_data);
	// Parse "extensions"
	int t_extensions__arraylength;
	t_extensions__arraylength = 0;
	extensions__elem_ = 0;
	int t_extensions__elem__it;
	t_extensions__elem__it = 0;
	int t_extensions__size;
	extensions_ = new vector<SSLExtension *>;
	const_byteptr t_extensions__elem__dataptr = t_dataptr_after_ext_len;
	for (; /* forever */; ++t_extensions__elem__it)
		{
		// Check &until(extensions__elem__dataptr >= end_of_data)
		if ( t_extensions__elem__dataptr >= t_end_of_data )
			{
			extensions__elem_ = 0;
			goto end_of_extensions;
			}
		extensions__elem_ = new SSLExtension(rec());
		int t_extensions__elem__size;
		t_extensions__elem__size = extensions__elem_->Parse(t_extensions__elem__dataptr, t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		extensions_->push_back(extensions__elem_);
		t_extensions__elem__dataptr += t_extensions__elem__size;
		BINPAC_ASSERT(t_extensions__elem__dataptr <= t_end_of_data);
		extensions__elem_ = 0;
		}
end_of_extensions: ;
	t_extensions__size = t_extensions__elem__dataptr - (t_dataptr_after_ext_len);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ServerHello13__size;
	const_byteptr const t_dataptr_after_extensions = t_dataptr_after_ext_len + (t_extensions__size);
	BINPAC_ASSERT(t_dataptr_after_extensions <= t_end_of_data);
	t_ServerHello13__size = t_dataptr_after_extensions - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	cipher_set_ = t_context->connection()->set_cipher((*(cipher_suite()))[0]);
	proc_ = t_context->connection()->proc_server_hello(server_version(), 0, random(), 0, cipher_suite(), 0, 0);
	BINPAC_ASSERT(t_begin_of_data + (t_ServerHello13__size) <= t_end_of_data);
	return t_ServerHello13__size;
	}

HelloVerifyRequest::HelloVerifyRequest(HandshakeRecord * rec)
	{
	version_ = 0;
	cookie_length_ = 0;
	rec_ = rec;
	}

HelloVerifyRequest::~HelloVerifyRequest()
	{
	cookie_.free();
	}

int HelloVerifyRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "HelloVerifyRequest:cookie_length"
	if ( (t_begin_of_data + 2) + (1) > t_end_of_data || (t_begin_of_data + 2) + (1) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("HelloVerifyRequest:cookie_length",
			(2) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "version"
	version_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cookie_length"
	cookie_length_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cookie"
	int t_cookie__size;
	t_cookie__size = cookie_length();
	// Checking out-of-bound for "HelloVerifyRequest:cookie"
	if ( (t_begin_of_data + 3) + (t_cookie__size) > t_end_of_data || (t_begin_of_data + 3) + (t_cookie__size) < (t_begin_of_data + 3) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("HelloVerifyRequest:cookie",
			(3) + (t_cookie__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + t_cookie__size;
	int t_cookie_string_length;
	t_cookie_string_length = cookie_length();
	// check for negative sizes
	if ( t_cookie_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:151", t_cookie_string_length);
	cookie_.init((t_begin_of_data + 3), t_cookie_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_HelloVerifyRequest__size;
	const_byteptr const t_dataptr_after_cookie = (t_begin_of_data + 3) + (t_cookie__size);
	BINPAC_ASSERT(t_dataptr_after_cookie <= t_end_of_data);
	t_HelloVerifyRequest__size = t_dataptr_after_cookie - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_HelloVerifyRequest__size) <= t_end_of_data);
	return t_HelloVerifyRequest__size;
	}

X509Certificate::X509Certificate()
	{
	length_ = 0;
	}

X509Certificate::~X509Certificate()
	{
	delete length_;
	length_ = 0;
	certificate_.free();
	}

int X509Certificate::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "X509Certificate:length"
	if ( t_begin_of_data + (3) > t_end_of_data || t_begin_of_data + (3) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("X509Certificate:length",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = new uint24();
	length_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "certificate"
	int t_certificate__size;
	t_certificate__size = to_int()(length());
	// Checking out-of-bound for "X509Certificate:certificate"
	if ( (t_begin_of_data + 3) + (t_certificate__size) > t_end_of_data || (t_begin_of_data + 3) + (t_certificate__size) < (t_begin_of_data + 3) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("X509Certificate:certificate",
			(3) + (t_certificate__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + t_certificate__size;
	int t_certificate_string_length;
	t_certificate_string_length = to_int()(length());
	// check for negative sizes
	if ( t_certificate_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:160", t_certificate_string_length);
	certificate_.init((t_begin_of_data + 3), t_certificate_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_X509Certificate__size;
	const_byteptr const t_dataptr_after_certificate = (t_begin_of_data + 3) + (t_certificate__size);
	BINPAC_ASSERT(t_dataptr_after_certificate <= t_end_of_data);
	t_X509Certificate__size = t_dataptr_after_certificate - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_X509Certificate__size) <= t_end_of_data);
	return t_X509Certificate__size;
	}

Certificate::Certificate(HandshakeRecord * rec)
	{
	length_ = 0;
	certificates_ = 0;
	certificates__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Certificate::~Certificate()
	{
	delete length_;
	length_ = 0;
	delete certificates__elem_;
	certificates__elem_ = 0;
	if ( certificates() )
		{
		for ( int i = 0; i < (int) certificates()->size(); ++i )
			{
			X509Certificate * certificates__elem_ = (*certificates_)[i];
			delete certificates__elem_;
			certificates__elem_ = 0;
			}
		}
	delete certificates_;
	}

int Certificate::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	int t_Certificate__size;
	// Checking out-of-bound for "Certificate:length"
	if ( t_begin_of_data + (3) > t_end_of_data || t_begin_of_data + (3) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Certificate:length",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = new uint24();
	length_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	t_Certificate__size = to_int()(length()) + 3;
	// Checking out-of-bound for "Certificate"
	if ( t_begin_of_data + (t_Certificate__size) > t_end_of_data || t_begin_of_data + (t_Certificate__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Certificate",
			(0) + (t_Certificate__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_Certificate__size;
	
	// Parse "certificates"
	int t_certificates__arraylength;
	t_certificates__arraylength = 0;
	certificates__elem_ = 0;
	int t_certificates__elem__it;
	t_certificates__elem__it = 0;
	int t_certificates__size;
	certificates_ = new vector<X509Certificate *>;
	const_byteptr t_certificates__elem__dataptr = (t_begin_of_data + 3);
	for (; /* forever */; ++t_certificates__elem__it)
		{
		// Check &until(certificates__elem__dataptr >= end_of_data)
		if ( t_certificates__elem__dataptr >= t_end_of_data )
			{
			certificates__elem_ = 0;
			goto end_of_certificates;
			}
		certificates__elem_ = new X509Certificate();
		int t_certificates__elem__size;
		t_certificates__elem__size = certificates__elem_->Parse(t_certificates__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		certificates_->push_back(certificates__elem_);
		t_certificates__elem__dataptr += t_certificates__elem__size;
		BINPAC_ASSERT(t_certificates__elem__dataptr <= t_end_of_data);
		certificates__elem_ = 0;
		}
end_of_certificates: ;
	t_certificates__size = t_certificates__elem__dataptr - ((t_begin_of_data + 3));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_v3_certificate(rec()->is_orig(), certificates());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_Certificate__size) <= t_end_of_data);
	return t_Certificate__size;
	}

CertificateStatus::CertificateStatus(HandshakeRecord * rec)
	{
	status_type_ = 0;
	length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

CertificateStatus::~CertificateStatus()
	{
	delete length_;
	length_ = 0;
	response_.free();
	}

int CertificateStatus::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Checking out-of-bound for "CertificateStatus:length"
	if ( (t_begin_of_data + 1) + (3) > t_end_of_data || (t_begin_of_data + 1) + (3) < (t_begin_of_data + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CertificateStatus:length",
			(1) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "status_type"
	status_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = new uint24();
	length_->Parse((t_begin_of_data + 1), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "response"
	int t_response_string_length;
	t_response_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
	int t_response__size;
	t_response__size = t_response_string_length;
	// check for negative sizes
	if ( t_response_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:173", t_response_string_length);
	response_.init((t_begin_of_data + 4), t_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CertificateStatus__size;
	const_byteptr const t_dataptr_after_response = (t_begin_of_data + 4) + (t_response__size);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	t_CertificateStatus__size = t_dataptr_after_response - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_certificate_status(rec(), status_type(), response());
	BINPAC_ASSERT(t_begin_of_data + (t_CertificateStatus__size) <= t_end_of_data);
	return t_CertificateStatus__size;
	}

ServerKeyExchange::ServerKeyExchange(HandshakeRecord * rec)
	{
	val_case_index_ = -1;
	ecdhe_server_key_exchange_ = 0;
	ecdh_anon_server_key_exchange_ = 0;
	dhe_server_key_exchange_ = 0;
	dh_anon_server_key_exchange_ = 0;
	rec_ = rec;
	}

ServerKeyExchange::~ServerKeyExchange()
	{
	switch ( val_case_index() )
		{
		case 49158:
		case 49159:
		case 49160:
		case 49161:
		case 49162:
		case 49168:
		case 49169:
		case 49170:
		case 49171:
		case 49172:
		case 49187:
		case 49188:
		case 49191:
		case 49192:
		case 49195:
		case 49196:
		case 49199:
		case 49200:
		case 49203:
		case 49204:
		case 49205:
		case 49206:
		case 49207:
		case 49208:
		case 49209:
		case 49210:
		case 49211:
		case 49224:
		case 49225:
		case 49228:
		case 49229:
		case 49244:
		case 49245:
		case 49248:
		case 49249:
		case 49264:
		case 49265:
		case 49266:
		case 49267:
		case 49270:
		case 49271:
		case 49286:
		case 49287:
		case 49290:
		case 49291:
		case 49306:
		case 49307:
		case 49324:
		case 49325:
		case 49326:
		case 49327:
		case 52243:
		case 52244:
			// Clean up "ecdhe_server_key_exchange"
			{
			delete ecdhe_server_key_exchange_;
			ecdhe_server_key_exchange_ = 0;
			}
			break;
		case 49173:
		case 49174:
		case 49175:
		case 49176:
		case 49177:
			// Clean up "ecdh_anon_server_key_exchange"
			{
			delete ecdh_anon_server_key_exchange_;
			ecdh_anon_server_key_exchange_ = 0;
			}
			break;
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 50:
		case 51:
		case 56:
		case 57:
		case 64:
		case 68:
		case 69:
		case 99:
		case 101:
		case 102:
		case 103:
		case 106:
		case 107:
		case 114:
		case 115:
		case 116:
		case 119:
		case 120:
		case 121:
		case 135:
		case 136:
		case 142:
		case 143:
		case 144:
		case 145:
		case 153:
		case 154:
		case 158:
		case 159:
		case 162:
		case 163:
		case 170:
		case 171:
		case 178:
		case 179:
		case 180:
		case 181:
		case 189:
		case 190:
		case 195:
		case 196:
		case 49218:
		case 49219:
		case 49220:
		case 49221:
		case 49234:
		case 49235:
		case 49238:
		case 49239:
		case 49254:
		case 49255:
		case 49260:
		case 49261:
		case 49276:
		case 49277:
		case 49280:
		case 49281:
		case 49296:
		case 49297:
		case 49302:
		case 49303:
		case 49310:
		case 49311:
		case 49314:
		case 49315:
		case 49318:
		case 49319:
		case 49322:
		case 49323:
		case 52245:
			// Clean up "dhe_server_key_exchange"
			{
			delete dhe_server_key_exchange_;
			dhe_server_key_exchange_ = 0;
			}
			break;
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 52:
		case 58:
		case 70:
		case 108:
		case 109:
		case 137:
		case 155:
		case 166:
		case 167:
		case 191:
		case 197:
		case 49222:
		case 49223:
		case 49242:
		case 49243:
		case 49284:
		case 49285:
			// Clean up "dh_anon_server_key_exchange"
			{
			delete dh_anon_server_key_exchange_;
			dh_anon_server_key_exchange_ = 0;
			}
			break;
		default:
			// Clean up "key"
			{
			}
			break;
		}
	}

int ServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = t_context->connection()->chosen_cipher();
	switch ( val_case_index() )
		{
		case 49158:
		case 49159:
		case 49160:
		case 49161:
		case 49162:
		case 49168:
		case 49169:
		case 49170:
		case 49171:
		case 49172:
		case 49187:
		case 49188:
		case 49191:
		case 49192:
		case 49195:
		case 49196:
		case 49199:
		case 49200:
		case 49203:
		case 49204:
		case 49205:
		case 49206:
		case 49207:
		case 49208:
		case 49209:
		case 49210:
		case 49211:
		case 49224:
		case 49225:
		case 49228:
		case 49229:
		case 49244:
		case 49245:
		case 49248:
		case 49249:
		case 49264:
		case 49265:
		case 49266:
		case 49267:
		case 49270:
		case 49271:
		case 49286:
		case 49287:
		case 49290:
		case 49291:
		case 49306:
		case 49307:
		case 49324:
		case 49325:
		case 49326:
		case 49327:
		case 52243:
		case 52244:
			// Parse "ecdhe_server_key_exchange"
			{
			ecdhe_server_key_exchange_ = new EcdheServerKeyExchange(rec());
			int t_ecdhe_server_key_exchange__size;
			t_ecdhe_server_key_exchange__size = ecdhe_server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_ecdhe_server_key_exchange__size;
			}
			break;
		case 49173:
		case 49174:
		case 49175:
		case 49176:
		case 49177:
			// Parse "ecdh_anon_server_key_exchange"
			{
			ecdh_anon_server_key_exchange_ = new EcdhAnonServerKeyExchange(rec());
			int t_ecdh_anon_server_key_exchange__size;
			t_ecdh_anon_server_key_exchange__size = ecdh_anon_server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_ecdh_anon_server_key_exchange__size;
			}
			break;
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 50:
		case 51:
		case 56:
		case 57:
		case 64:
		case 68:
		case 69:
		case 99:
		case 101:
		case 102:
		case 103:
		case 106:
		case 107:
		case 114:
		case 115:
		case 116:
		case 119:
		case 120:
		case 121:
		case 135:
		case 136:
		case 142:
		case 143:
		case 144:
		case 145:
		case 153:
		case 154:
		case 158:
		case 159:
		case 162:
		case 163:
		case 170:
		case 171:
		case 178:
		case 179:
		case 180:
		case 181:
		case 189:
		case 190:
		case 195:
		case 196:
		case 49218:
		case 49219:
		case 49220:
		case 49221:
		case 49234:
		case 49235:
		case 49238:
		case 49239:
		case 49254:
		case 49255:
		case 49260:
		case 49261:
		case 49276:
		case 49277:
		case 49280:
		case 49281:
		case 49296:
		case 49297:
		case 49302:
		case 49303:
		case 49310:
		case 49311:
		case 49314:
		case 49315:
		case 49318:
		case 49319:
		case 49322:
		case 49323:
		case 52245:
			// Parse "dhe_server_key_exchange"
			{
			dhe_server_key_exchange_ = new DheServerKeyExchange(rec());
			int t_dhe_server_key_exchange__size;
			t_dhe_server_key_exchange__size = dhe_server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_dhe_server_key_exchange__size;
			}
			break;
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 52:
		case 58:
		case 70:
		case 108:
		case 109:
		case 137:
		case 155:
		case 166:
		case 167:
		case 191:
		case 197:
		case 49222:
		case 49223:
		case 49242:
		case 49243:
		case 49284:
		case 49285:
			// Parse "dh_anon_server_key_exchange"
			{
			dh_anon_server_key_exchange_ = new DhAnonServerKeyExchange(rec());
			int t_dh_anon_server_key_exchange__size;
			t_dh_anon_server_key_exchange__size = dh_anon_server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_dh_anon_server_key_exchange__size;
			}
			break;
		default:
			// Parse "key"
			{
			int t_key_string_length;
			t_key_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_key__size;
			t_key__size = t_key_string_length;
			// check for negative sizes
			if ( t_key_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:356", t_key_string_length);
			key_.init(t_begin_of_data, t_key_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_key__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

EcdheServerKeyExchange::EcdheServerKeyExchange(HandshakeRecord * rec)
	{
	curve_type_ = 0;
	named_curve_case_index_ = -1;
	params_ = 0;
	signature_case_index_ = -1;
	signed_params_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

EcdheServerKeyExchange::~EcdheServerKeyExchange()
	{
	switch ( named_curve_case_index() )
		{
		case 3:
			// Clean up "params"
			{
			delete params_;
			params_ = 0;
			}
			break;
		default:
			// Clean up "data"
			{
			}
			break;
		}
	switch ( signature_case_index() )
		{
		case 3:
			// Clean up "signed_params"
			{
			delete signed_params_;
			signed_params_ = 0;
			}
			break;
		default:
			// Clean up "nothing"
			{
			nothing_.free();
			}
			break;
		}
	}

int EcdheServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EcdheServerKeyExchange:curve_type"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EcdheServerKeyExchange:curve_type",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "curve_type"
	curve_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "named_curve"
	int t_named_curve__size;
	named_curve_case_index_ = curve_type();
	switch ( named_curve_case_index() )
		{
		case 3:
			// Parse "params"
			{
			params_ = new ServerECDHParamsAndSignature();
			int t_params__size;
			t_params__size = params_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_named_curve__size = t_params__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 1));
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:366", t_data_string_length);
			data_.init((t_begin_of_data + 1), t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_named_curve__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_named_curve = (t_begin_of_data + 1) + (t_named_curve__size);
	BINPAC_ASSERT(t_dataptr_after_named_curve <= t_end_of_data);
	// Parse "signature"
	int t_signature__size;
	signature_case_index_ = curve_type();
	switch ( signature_case_index() )
		{
		case 3:
			// Parse "signed_params"
			{
			signed_params_ = new ServerKeyExchangeSignature();
			int t_signed_params__size;
			t_signed_params__size = signed_params_->Parse(t_dataptr_after_named_curve, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_signature__size = t_signed_params__size;
			}
			break;
		default:
			// Parse "nothing"
			{
			// Checking out-of-bound for "EcdheServerKeyExchange:nothing"
			if ( t_dataptr_after_named_curve + (0) > t_end_of_data || t_dataptr_after_named_curve + (0) < t_dataptr_after_named_curve )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("EcdheServerKeyExchange:nothing",
					((t_dataptr_after_named_curve - t_begin_of_data)) + (0), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_dataptr_after_named_curve + 0;
			int t_nothing_string_length;
			t_nothing_string_length = 0;
			int t_nothing__size;
			t_nothing__size = t_nothing_string_length;
			nothing_.init(t_dataptr_after_named_curve, t_nothing_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_signature__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_EcdheServerKeyExchange__size;
	const_byteptr const t_dataptr_after_signature = t_dataptr_after_named_curve + (t_signature__size);
	BINPAC_ASSERT(t_dataptr_after_signature <= t_end_of_data);
	t_EcdheServerKeyExchange__size = t_dataptr_after_signature - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ecdhe_server_key_exchange(this);
	BINPAC_ASSERT(t_begin_of_data + (t_EcdheServerKeyExchange__size) <= t_end_of_data);
	return t_EcdheServerKeyExchange__size;
	}

ServerKeyExchangeSignature::ServerKeyExchangeSignature()
	{
	alg_case_index_ = -1;
	algorithm_ = 0;
	signature_length_ = 0;
	uses_signature_and_hashalgorithm_ = 0;
	}

ServerKeyExchangeSignature::~ServerKeyExchangeSignature()
	{
	switch ( alg_case_index() )
		{
		case 1:
			// Clean up "algorithm"
			{
			delete algorithm_;
			algorithm_ = 0;
			}
			break;
		case 0:
			// Clean up "nothing"
			{
			nothing_.free();
			}
			break;
		}
	signature_.free();
	}

int ServerKeyExchangeSignature::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Parse "alg"
	uses_signature_and_hashalgorithm_ =  ( t_context->connection()->chosen_version() > TLSv11 )  &&  ( t_context->connection()->chosen_version() != DTLSv10 ) ;
	int t_alg__size;
	alg_case_index_ = uses_signature_and_hashalgorithm();
	switch ( alg_case_index() )
		{
		case 1:
			// Parse "algorithm"
			{
			algorithm_ = new SignatureAndHashAlgorithm();
			algorithm_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_alg__size = 2;
			}
			break;
		case 0:
			// Parse "nothing"
			{
			// Checking out-of-bound for "ServerKeyExchangeSignature:nothing"
			if ( t_begin_of_data + (0) > t_end_of_data || t_begin_of_data + (0) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("ServerKeyExchangeSignature:nothing",
					(0) + (0), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + 0;
			int t_nothing_string_length;
			t_nothing_string_length = 0;
			int t_nothing__size;
			t_nothing__size = t_nothing_string_length;
			nothing_.init(t_begin_of_data, t_nothing_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_alg__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("ServerKeyExchangeSignature", alg_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_alg = t_begin_of_data + (t_alg__size);
	BINPAC_ASSERT(t_dataptr_after_alg <= t_end_of_data);
	// Checking out-of-bound for "ServerKeyExchangeSignature:signature_length"
	if ( t_dataptr_after_alg + (2) > t_end_of_data || t_dataptr_after_alg + (2) < t_dataptr_after_alg )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerKeyExchangeSignature:signature_length",
			((t_dataptr_after_alg - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "signature_length"
	signature_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_alg)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature"
	int t_signature__size;
	t_signature__size = signature_length();
	// Checking out-of-bound for "ServerKeyExchangeSignature:signature"
	if ( (t_dataptr_after_alg + 2) + (t_signature__size) > t_end_of_data || (t_dataptr_after_alg + 2) + (t_signature__size) < (t_dataptr_after_alg + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerKeyExchangeSignature:signature",
			(((t_dataptr_after_alg + 2) - t_begin_of_data)) + (t_signature__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_alg + 2) + t_signature__size;
	int t_signature_string_length;
	t_signature_string_length = signature_length();
	// check for negative sizes
	if ( t_signature_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:380", t_signature_string_length);
	signature_.init((t_dataptr_after_alg + 2), t_signature_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ServerKeyExchangeSignature__size;
	const_byteptr const t_dataptr_after_signature = (t_dataptr_after_alg + 2) + (t_signature__size);
	BINPAC_ASSERT(t_dataptr_after_signature <= t_end_of_data);
	t_ServerKeyExchangeSignature__size = t_dataptr_after_signature - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ServerKeyExchangeSignature__size) <= t_end_of_data);
	return t_ServerKeyExchangeSignature__size;
	}

EcdhAnonServerKeyExchange::EcdhAnonServerKeyExchange(HandshakeRecord * rec)
	{
	curve_type_ = 0;
	named_curve_case_index_ = -1;
	params_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

EcdhAnonServerKeyExchange::~EcdhAnonServerKeyExchange()
	{
	switch ( named_curve_case_index() )
		{
		case 3:
			// Clean up "params"
			{
			delete params_;
			params_ = 0;
			}
			break;
		default:
			// Clean up "data"
			{
			}
			break;
		}
	}

int EcdhAnonServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EcdhAnonServerKeyExchange:curve_type"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EcdhAnonServerKeyExchange:curve_type",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "curve_type"
	curve_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "named_curve"
	int t_named_curve__size;
	named_curve_case_index_ = curve_type();
	switch ( named_curve_case_index() )
		{
		case 3:
			// Parse "params"
			{
			params_ = new ServerECDHParamsAndSignature();
			int t_params__size;
			t_params__size = params_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_named_curve__size = t_params__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 1));
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:394", t_data_string_length);
			data_.init((t_begin_of_data + 1), t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_named_curve__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_EcdhAnonServerKeyExchange__size;
	const_byteptr const t_dataptr_after_named_curve = (t_begin_of_data + 1) + (t_named_curve__size);
	BINPAC_ASSERT(t_dataptr_after_named_curve <= t_end_of_data);
	t_EcdhAnonServerKeyExchange__size = t_dataptr_after_named_curve - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ecdh_anon_server_key_exchange(this);
	BINPAC_ASSERT(t_begin_of_data + (t_EcdhAnonServerKeyExchange__size) <= t_end_of_data);
	return t_EcdhAnonServerKeyExchange__size;
	}

ServerECDHParamsAndSignature::ServerECDHParamsAndSignature()
	{
	curve_ = 0;
	point_length_ = 0;
	}

ServerECDHParamsAndSignature::~ServerECDHParamsAndSignature()
	{
	point_.free();
	}

int ServerECDHParamsAndSignature::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "ServerECDHParamsAndSignature:point_length"
	if ( (t_begin_of_data + 2) + (1) > t_end_of_data || (t_begin_of_data + 2) + (1) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerECDHParamsAndSignature:point_length",
			(2) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "curve"
	curve_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "point_length"
	point_length_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "point"
	int t_point__size;
	t_point__size = point_length();
	// Checking out-of-bound for "ServerECDHParamsAndSignature:point"
	if ( (t_begin_of_data + 3) + (t_point__size) > t_end_of_data || (t_begin_of_data + 3) + (t_point__size) < (t_begin_of_data + 3) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerECDHParamsAndSignature:point",
			(3) + (t_point__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + t_point__size;
	int t_point_string_length;
	t_point_string_length = point_length();
	// check for negative sizes
	if ( t_point_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:401", t_point_string_length);
	point_.init((t_begin_of_data + 3), t_point_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ServerECDHParamsAndSignature__size;
	const_byteptr const t_dataptr_after_point = (t_begin_of_data + 3) + (t_point__size);
	BINPAC_ASSERT(t_dataptr_after_point <= t_end_of_data);
	t_ServerECDHParamsAndSignature__size = t_dataptr_after_point - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ServerECDHParamsAndSignature__size) <= t_end_of_data);
	return t_ServerECDHParamsAndSignature__size;
	}

DheServerKeyExchange::DheServerKeyExchange(HandshakeRecord * rec)
	{
	dh_p_length_ = 0;
	dh_g_length_ = 0;
	dh_Ys_length_ = 0;
	signed_params_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

DheServerKeyExchange::~DheServerKeyExchange()
	{
	dh_p_.free();
	dh_g_.free();
	dh_Ys_.free();
	delete signed_params_;
	signed_params_ = 0;
	}

int DheServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "DheServerKeyExchange:dh_p_length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DheServerKeyExchange:dh_p_length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_p_length"
	dh_p_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_p"
	int t_dh_p__size;
	t_dh_p__size = dh_p_length();
	// Checking out-of-bound for "DheServerKeyExchange:dh_p"
	if ( (t_begin_of_data + 2) + (t_dh_p__size) > t_end_of_data || (t_begin_of_data + 2) + (t_dh_p__size) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DheServerKeyExchange:dh_p",
			(2) + (t_dh_p__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_dh_p__size;
	int t_dh_p_string_length;
	t_dh_p_string_length = dh_p_length();
	// check for negative sizes
	if ( t_dh_p_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:408", t_dh_p_string_length);
	dh_p_.init((t_begin_of_data + 2), t_dh_p_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_p = (t_begin_of_data + 2) + (t_dh_p__size);
	BINPAC_ASSERT(t_dataptr_after_dh_p <= t_end_of_data);
	// Checking out-of-bound for "DheServerKeyExchange:dh_g_length"
	if ( t_dataptr_after_dh_p + (2) > t_end_of_data || t_dataptr_after_dh_p + (2) < t_dataptr_after_dh_p )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DheServerKeyExchange:dh_g_length",
			((t_dataptr_after_dh_p - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_g_length"
	dh_g_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_dh_p)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_g"
	int t_dh_g__size;
	t_dh_g__size = dh_g_length();
	// Checking out-of-bound for "DheServerKeyExchange:dh_g"
	if ( (t_dataptr_after_dh_p + 2) + (t_dh_g__size) > t_end_of_data || (t_dataptr_after_dh_p + 2) + (t_dh_g__size) < (t_dataptr_after_dh_p + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DheServerKeyExchange:dh_g",
			(((t_dataptr_after_dh_p + 2) - t_begin_of_data)) + (t_dh_g__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_dh_p + 2) + t_dh_g__size;
	int t_dh_g_string_length;
	t_dh_g_string_length = dh_g_length();
	// check for negative sizes
	if ( t_dh_g_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:410", t_dh_g_string_length);
	dh_g_.init((t_dataptr_after_dh_p + 2), t_dh_g_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_g = (t_dataptr_after_dh_p + 2) + (t_dh_g__size);
	BINPAC_ASSERT(t_dataptr_after_dh_g <= t_end_of_data);
	// Checking out-of-bound for "DheServerKeyExchange:dh_Ys_length"
	if ( t_dataptr_after_dh_g + (2) > t_end_of_data || t_dataptr_after_dh_g + (2) < t_dataptr_after_dh_g )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DheServerKeyExchange:dh_Ys_length",
			((t_dataptr_after_dh_g - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_Ys_length"
	dh_Ys_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_dh_g)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_Ys"
	int t_dh_Ys__size;
	t_dh_Ys__size = dh_Ys_length();
	// Checking out-of-bound for "DheServerKeyExchange:dh_Ys"
	if ( (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size) > t_end_of_data || (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size) < (t_dataptr_after_dh_g + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DheServerKeyExchange:dh_Ys",
			(((t_dataptr_after_dh_g + 2) - t_begin_of_data)) + (t_dh_Ys__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_dh_g + 2) + t_dh_Ys__size;
	int t_dh_Ys_string_length;
	t_dh_Ys_string_length = dh_Ys_length();
	// check for negative sizes
	if ( t_dh_Ys_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:412", t_dh_Ys_string_length);
	dh_Ys_.init((t_dataptr_after_dh_g + 2), t_dh_Ys_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_Ys = (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size);
	BINPAC_ASSERT(t_dataptr_after_dh_Ys <= t_end_of_data);
	// Parse "signed_params"
	signed_params_ = new ServerKeyExchangeSignature();
	int t_signed_params__size;
	t_signed_params__size = signed_params_->Parse(t_dataptr_after_dh_Ys, t_end_of_data, t_context, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DheServerKeyExchange__size;
	const_byteptr const t_dataptr_after_signed_params = t_dataptr_after_dh_Ys + (t_signed_params__size);
	BINPAC_ASSERT(t_dataptr_after_signed_params <= t_end_of_data);
	t_DheServerKeyExchange__size = t_dataptr_after_signed_params - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_dhe_server_key_exchange(rec(), dh_p(), dh_g(), dh_Ys(), signed_params());
	BINPAC_ASSERT(t_begin_of_data + (t_DheServerKeyExchange__size) <= t_end_of_data);
	return t_DheServerKeyExchange__size;
	}

DhAnonServerKeyExchange::DhAnonServerKeyExchange(HandshakeRecord * rec)
	{
	dh_p_length_ = 0;
	dh_g_length_ = 0;
	dh_Ys_length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

DhAnonServerKeyExchange::~DhAnonServerKeyExchange()
	{
	dh_p_.free();
	dh_g_.free();
	dh_Ys_.free();
	}

int DhAnonServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "DhAnonServerKeyExchange:dh_p_length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhAnonServerKeyExchange:dh_p_length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_p_length"
	dh_p_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_p"
	int t_dh_p__size;
	t_dh_p__size = dh_p_length();
	// Checking out-of-bound for "DhAnonServerKeyExchange:dh_p"
	if ( (t_begin_of_data + 2) + (t_dh_p__size) > t_end_of_data || (t_begin_of_data + 2) + (t_dh_p__size) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhAnonServerKeyExchange:dh_p",
			(2) + (t_dh_p__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_dh_p__size;
	int t_dh_p_string_length;
	t_dh_p_string_length = dh_p_length();
	// check for negative sizes
	if ( t_dh_p_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:420", t_dh_p_string_length);
	dh_p_.init((t_begin_of_data + 2), t_dh_p_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_p = (t_begin_of_data + 2) + (t_dh_p__size);
	BINPAC_ASSERT(t_dataptr_after_dh_p <= t_end_of_data);
	// Checking out-of-bound for "DhAnonServerKeyExchange:dh_g_length"
	if ( t_dataptr_after_dh_p + (2) > t_end_of_data || t_dataptr_after_dh_p + (2) < t_dataptr_after_dh_p )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhAnonServerKeyExchange:dh_g_length",
			((t_dataptr_after_dh_p - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_g_length"
	dh_g_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_dh_p)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_g"
	int t_dh_g__size;
	t_dh_g__size = dh_g_length();
	// Checking out-of-bound for "DhAnonServerKeyExchange:dh_g"
	if ( (t_dataptr_after_dh_p + 2) + (t_dh_g__size) > t_end_of_data || (t_dataptr_after_dh_p + 2) + (t_dh_g__size) < (t_dataptr_after_dh_p + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhAnonServerKeyExchange:dh_g",
			(((t_dataptr_after_dh_p + 2) - t_begin_of_data)) + (t_dh_g__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_dh_p + 2) + t_dh_g__size;
	int t_dh_g_string_length;
	t_dh_g_string_length = dh_g_length();
	// check for negative sizes
	if ( t_dh_g_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:422", t_dh_g_string_length);
	dh_g_.init((t_dataptr_after_dh_p + 2), t_dh_g_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_g = (t_dataptr_after_dh_p + 2) + (t_dh_g__size);
	BINPAC_ASSERT(t_dataptr_after_dh_g <= t_end_of_data);
	// Checking out-of-bound for "DhAnonServerKeyExchange:dh_Ys_length"
	if ( t_dataptr_after_dh_g + (2) > t_end_of_data || t_dataptr_after_dh_g + (2) < t_dataptr_after_dh_g )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhAnonServerKeyExchange:dh_Ys_length",
			((t_dataptr_after_dh_g - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_Ys_length"
	dh_Ys_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_dh_g)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_Ys"
	int t_dh_Ys__size;
	t_dh_Ys__size = dh_Ys_length();
	// Checking out-of-bound for "DhAnonServerKeyExchange:dh_Ys"
	if ( (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size) > t_end_of_data || (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size) < (t_dataptr_after_dh_g + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhAnonServerKeyExchange:dh_Ys",
			(((t_dataptr_after_dh_g + 2) - t_begin_of_data)) + (t_dh_Ys__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_dh_g + 2) + t_dh_Ys__size;
	int t_dh_Ys_string_length;
	t_dh_Ys_string_length = dh_Ys_length();
	// check for negative sizes
	if ( t_dh_Ys_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:424", t_dh_Ys_string_length);
	dh_Ys_.init((t_dataptr_after_dh_g + 2), t_dh_Ys_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_Ys = (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size);
	BINPAC_ASSERT(t_dataptr_after_dh_Ys <= t_end_of_data);
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_dataptr_after_dh_Ys);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:425", t_data_string_length);
	data_.init(t_dataptr_after_dh_Ys, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DhAnonServerKeyExchange__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_dh_Ys + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_DhAnonServerKeyExchange__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_dh_anon_server_key_exchange(rec(), dh_p(), dh_g(), dh_Ys());
	BINPAC_ASSERT(t_begin_of_data + (t_DhAnonServerKeyExchange__size) <= t_end_of_data);
	return t_DhAnonServerKeyExchange__size;
	}

CertificateRequest::CertificateRequest(HandshakeRecord * rec)
	{
	rec_ = rec;
	}

CertificateRequest::~CertificateRequest()
	{
	}

int CertificateRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:434", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CertificateRequest__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_CertificateRequest__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CertificateRequest__size) <= t_end_of_data);
	return t_CertificateRequest__size;
	}

ServerHelloDone::ServerHelloDone(HandshakeRecord * rec)
	{
	rec_ = rec;
	}

ServerHelloDone::~ServerHelloDone()
	{
	}

int ServerHelloDone::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (0) <= t_end_of_data);
	return 0;
	}

ClientKeyExchange::ClientKeyExchange(HandshakeRecord * rec)
	{
	val_case_index_ = -1;
	rsa_client_key_exchange_ = 0;
	ecdh_client_key_exchange_ = 0;
	dh_server_key_exchange_ = 0;
	rec_ = rec;
	}

ClientKeyExchange::~ClientKeyExchange()
	{
	switch ( val_case_index() )
		{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 47:
		case 53:
		case 59:
		case 60:
		case 61:
		case 65:
		case 96:
		case 97:
		case 98:
		case 100:
		case 124:
		case 125:
		case 126:
		case 132:
		case 146:
		case 147:
		case 148:
		case 149:
		case 150:
		case 156:
		case 157:
		case 182:
		case 183:
		case 184:
		case 185:
		case 186:
		case 192:
		case 49212:
		case 49213:
		case 49232:
		case 49233:
		case 49256:
		case 49257:
		case 49262:
		case 49263:
		case 49274:
		case 49275:
		case 49298:
		case 49299:
		case 49304:
		case 49305:
		case 49308:
		case 49309:
		case 49312:
		case 49313:
			// Clean up "rsa_client_key_exchange"
			{
			delete rsa_client_key_exchange_;
			rsa_client_key_exchange_ = 0;
			}
			break;
		case 49153:
		case 49154:
		case 49155:
		case 49156:
		case 49157:
		case 49158:
		case 49159:
		case 49160:
		case 49161:
		case 49162:
		case 49163:
		case 49164:
		case 49165:
		case 49166:
		case 49167:
		case 49168:
		case 49169:
		case 49170:
		case 49171:
		case 49172:
		case 49173:
		case 49174:
		case 49175:
		case 49176:
		case 49177:
		case 49187:
		case 49188:
		case 49189:
		case 49190:
		case 49191:
		case 49192:
		case 49193:
		case 49194:
		case 49195:
		case 49196:
		case 49197:
		case 49198:
		case 49199:
		case 49200:
		case 49201:
		case 49202:
		case 49203:
		case 49204:
		case 49205:
		case 49206:
		case 49207:
		case 49208:
		case 49209:
		case 49210:
		case 49211:
		case 49224:
		case 49225:
		case 49226:
		case 49227:
		case 49228:
		case 49229:
		case 49230:
		case 49231:
		case 49244:
		case 49245:
		case 49246:
		case 49247:
		case 49248:
		case 49249:
		case 49250:
		case 49251:
		case 49264:
		case 49265:
		case 49266:
		case 49267:
		case 49268:
		case 49269:
		case 49270:
		case 49271:
		case 49272:
		case 49273:
		case 49286:
		case 49287:
		case 49288:
		case 49289:
		case 49290:
		case 49291:
		case 49292:
		case 49293:
		case 49306:
		case 49307:
		case 49324:
		case 49325:
		case 49326:
		case 49327:
		case 52243:
		case 52244:
			// Clean up "ecdh_client_key_exchange"
			{
			delete ecdh_client_key_exchange_;
			ecdh_client_key_exchange_ = 0;
			}
			break;
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 50:
		case 51:
		case 56:
		case 57:
		case 64:
		case 68:
		case 69:
		case 99:
		case 101:
		case 102:
		case 103:
		case 106:
		case 107:
		case 114:
		case 115:
		case 116:
		case 119:
		case 120:
		case 121:
		case 135:
		case 136:
		case 142:
		case 143:
		case 144:
		case 145:
		case 153:
		case 154:
		case 158:
		case 159:
		case 162:
		case 163:
		case 170:
		case 171:
		case 178:
		case 179:
		case 180:
		case 181:
		case 189:
		case 190:
		case 195:
		case 196:
		case 49218:
		case 49219:
		case 49220:
		case 49221:
		case 49234:
		case 49235:
		case 49238:
		case 49239:
		case 49254:
		case 49255:
		case 49260:
		case 49261:
		case 49276:
		case 49277:
		case 49280:
		case 49281:
		case 49296:
		case 49297:
		case 49302:
		case 49303:
		case 49310:
		case 49311:
		case 49314:
		case 49315:
		case 49318:
		case 49319:
		case 49322:
		case 49323:
		case 52245:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 52:
		case 58:
		case 70:
		case 108:
		case 109:
		case 137:
		case 155:
		case 166:
		case 167:
		case 191:
		case 197:
		case 49222:
		case 49223:
		case 49242:
		case 49243:
		case 49284:
		case 49285:
			// Clean up "dh_server_key_exchange"
			{
			delete dh_server_key_exchange_;
			dh_server_key_exchange_ = 0;
			}
			break;
		default:
			// Clean up "key"
			{
			}
			break;
		}
	}

int ClientKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	int t_val__size;
	val_case_index_ = t_context->connection()->chosen_cipher();
	switch ( val_case_index() )
		{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 47:
		case 53:
		case 59:
		case 60:
		case 61:
		case 65:
		case 96:
		case 97:
		case 98:
		case 100:
		case 124:
		case 125:
		case 126:
		case 132:
		case 146:
		case 147:
		case 148:
		case 149:
		case 150:
		case 156:
		case 157:
		case 182:
		case 183:
		case 184:
		case 185:
		case 186:
		case 192:
		case 49212:
		case 49213:
		case 49232:
		case 49233:
		case 49256:
		case 49257:
		case 49262:
		case 49263:
		case 49274:
		case 49275:
		case 49298:
		case 49299:
		case 49304:
		case 49305:
		case 49308:
		case 49309:
		case 49312:
		case 49313:
			// Parse "rsa_client_key_exchange"
			{
			rsa_client_key_exchange_ = new RsaClientKeyExchange(rec());
			int t_rsa_client_key_exchange__size;
			t_rsa_client_key_exchange__size = rsa_client_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_rsa_client_key_exchange__size;
			}
			break;
		case 49153:
		case 49154:
		case 49155:
		case 49156:
		case 49157:
		case 49158:
		case 49159:
		case 49160:
		case 49161:
		case 49162:
		case 49163:
		case 49164:
		case 49165:
		case 49166:
		case 49167:
		case 49168:
		case 49169:
		case 49170:
		case 49171:
		case 49172:
		case 49173:
		case 49174:
		case 49175:
		case 49176:
		case 49177:
		case 49187:
		case 49188:
		case 49189:
		case 49190:
		case 49191:
		case 49192:
		case 49193:
		case 49194:
		case 49195:
		case 49196:
		case 49197:
		case 49198:
		case 49199:
		case 49200:
		case 49201:
		case 49202:
		case 49203:
		case 49204:
		case 49205:
		case 49206:
		case 49207:
		case 49208:
		case 49209:
		case 49210:
		case 49211:
		case 49224:
		case 49225:
		case 49226:
		case 49227:
		case 49228:
		case 49229:
		case 49230:
		case 49231:
		case 49244:
		case 49245:
		case 49246:
		case 49247:
		case 49248:
		case 49249:
		case 49250:
		case 49251:
		case 49264:
		case 49265:
		case 49266:
		case 49267:
		case 49268:
		case 49269:
		case 49270:
		case 49271:
		case 49272:
		case 49273:
		case 49286:
		case 49287:
		case 49288:
		case 49289:
		case 49290:
		case 49291:
		case 49292:
		case 49293:
		case 49306:
		case 49307:
		case 49324:
		case 49325:
		case 49326:
		case 49327:
		case 52243:
		case 52244:
			// Parse "ecdh_client_key_exchange"
			{
			ecdh_client_key_exchange_ = new EcdhClientKeyExchange(rec());
			int t_ecdh_client_key_exchange__size;
			t_ecdh_client_key_exchange__size = ecdh_client_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_ecdh_client_key_exchange__size;
			}
			break;
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 50:
		case 51:
		case 56:
		case 57:
		case 64:
		case 68:
		case 69:
		case 99:
		case 101:
		case 102:
		case 103:
		case 106:
		case 107:
		case 114:
		case 115:
		case 116:
		case 119:
		case 120:
		case 121:
		case 135:
		case 136:
		case 142:
		case 143:
		case 144:
		case 145:
		case 153:
		case 154:
		case 158:
		case 159:
		case 162:
		case 163:
		case 170:
		case 171:
		case 178:
		case 179:
		case 180:
		case 181:
		case 189:
		case 190:
		case 195:
		case 196:
		case 49218:
		case 49219:
		case 49220:
		case 49221:
		case 49234:
		case 49235:
		case 49238:
		case 49239:
		case 49254:
		case 49255:
		case 49260:
		case 49261:
		case 49276:
		case 49277:
		case 49280:
		case 49281:
		case 49296:
		case 49297:
		case 49302:
		case 49303:
		case 49310:
		case 49311:
		case 49314:
		case 49315:
		case 49318:
		case 49319:
		case 49322:
		case 49323:
		case 52245:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 52:
		case 58:
		case 70:
		case 108:
		case 109:
		case 137:
		case 155:
		case 166:
		case 167:
		case 191:
		case 197:
		case 49222:
		case 49223:
		case 49242:
		case 49243:
		case 49284:
		case 49285:
			// Parse "dh_server_key_exchange"
			{
			dh_server_key_exchange_ = new DhClientKeyExchange(rec());
			int t_dh_server_key_exchange__size;
			t_dh_server_key_exchange__size = dh_server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_dh_server_key_exchange__size;
			}
			break;
		default:
			// Parse "key"
			{
			int t_key_string_length;
			t_key_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_key__size;
			t_key__size = t_key_string_length;
			// check for negative sizes
			if ( t_key_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:720", t_key_string_length);
			key_.init(t_begin_of_data, t_key_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_key__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

RsaClientKeyExchange::RsaClientKeyExchange(HandshakeRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

RsaClientKeyExchange::~RsaClientKeyExchange()
	{
	rsa_pms_.free();
	}

int RsaClientKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Parse "rsa_pms"
	int t_rsa_pms_string_length;
	t_rsa_pms_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_rsa_pms__size;
	t_rsa_pms__size = t_rsa_pms_string_length;
	// check for negative sizes
	if ( t_rsa_pms_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:724", t_rsa_pms_string_length);
	rsa_pms_.init(t_begin_of_data, t_rsa_pms_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_RsaClientKeyExchange__size;
	const_byteptr const t_dataptr_after_rsa_pms = t_begin_of_data + (t_rsa_pms__size);
	BINPAC_ASSERT(t_dataptr_after_rsa_pms <= t_end_of_data);
	t_RsaClientKeyExchange__size = t_dataptr_after_rsa_pms - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_rsa_client_key_exchange(rec(), rsa_pms());
	BINPAC_ASSERT(t_begin_of_data + (t_RsaClientKeyExchange__size) <= t_end_of_data);
	return t_RsaClientKeyExchange__size;
	}

DhClientKeyExchange::DhClientKeyExchange(HandshakeRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

DhClientKeyExchange::~DhClientKeyExchange()
	{
	dh_Yc_.free();
	}

int DhClientKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Parse "dh_Yc"
	int t_dh_Yc_string_length;
	t_dh_Yc_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_dh_Yc__size;
	t_dh_Yc__size = t_dh_Yc_string_length;
	// check for negative sizes
	if ( t_dh_Yc_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:728", t_dh_Yc_string_length);
	dh_Yc_.init(t_begin_of_data, t_dh_Yc_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DhClientKeyExchange__size;
	const_byteptr const t_dataptr_after_dh_Yc = t_begin_of_data + (t_dh_Yc__size);
	BINPAC_ASSERT(t_dataptr_after_dh_Yc <= t_end_of_data);
	t_DhClientKeyExchange__size = t_dataptr_after_dh_Yc - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_dh_client_key_exchange(rec(), dh_Yc());
	BINPAC_ASSERT(t_begin_of_data + (t_DhClientKeyExchange__size) <= t_end_of_data);
	return t_DhClientKeyExchange__size;
	}

EcdhClientKeyExchange::EcdhClientKeyExchange(HandshakeRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

EcdhClientKeyExchange::~EcdhClientKeyExchange()
	{
	point_.free();
	}

int EcdhClientKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Parse "point"
	int t_point_string_length;
	t_point_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_point__size;
	t_point__size = t_point_string_length;
	// check for negative sizes
	if ( t_point_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:732", t_point_string_length);
	point_.init(t_begin_of_data, t_point_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_EcdhClientKeyExchange__size;
	const_byteptr const t_dataptr_after_point = t_begin_of_data + (t_point__size);
	BINPAC_ASSERT(t_dataptr_after_point <= t_end_of_data);
	t_EcdhClientKeyExchange__size = t_dataptr_after_point - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ecdh_client_key_exchange(rec(), point());
	BINPAC_ASSERT(t_begin_of_data + (t_EcdhClientKeyExchange__size) <= t_end_of_data);
	return t_EcdhClientKeyExchange__size;
	}

CertificateVerify::CertificateVerify(HandshakeRecord * rec)
	{
	rec_ = rec;
	}

CertificateVerify::~CertificateVerify()
	{
	}

int CertificateVerify::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:741", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CertificateVerify__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_CertificateVerify__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CertificateVerify__size) <= t_end_of_data);
	return t_CertificateVerify__size;
	}

Finished::Finished(HandshakeRecord * rec)
	{
	rec_ = rec;
	}

Finished::~Finished()
	{
	}

int Finished::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:752", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Finished__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_Finished__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Finished__size) <= t_end_of_data);
	return t_Finished__size;
	}

SessionTicketHandshake::SessionTicketHandshake(HandshakeRecord * rec)
	{
	ticket_lifetime_hint_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

SessionTicketHandshake::~SessionTicketHandshake()
	{
	data_.free();
	}

int SessionTicketHandshake::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "SessionTicketHandshake:ticket_lifetime_hint"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SessionTicketHandshake:ticket_lifetime_hint",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "ticket_lifetime_hint"
	ticket_lifetime_hint_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:757", t_data_string_length);
	data_.init((t_begin_of_data + 4), t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SessionTicketHandshake__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SessionTicketHandshake__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_session_ticket_handshake(this, rec()->is_orig());
	BINPAC_ASSERT(t_begin_of_data + (t_SessionTicketHandshake__size) <= t_end_of_data);
	return t_SessionTicketHandshake__size;
	}

SSLExtension::SSLExtension(HandshakeRecord * rec)
	{
	type_ = 0;
	data_len_ = 0;
	ext_case_index_ = -1;
	apnl_ = 0;
	apnl__elem_ = 0;
	elliptic_curves_ = 0;
	elliptic_curves__elem_ = 0;
	ec_point_formats_ = 0;
	ec_point_formats__elem_ = 0;
	server_name_ = 0;
	server_name__elem_ = 0;
	signature_algorithm_ = 0;
	signature_algorithm__elem_ = 0;
	certificate_timestamp_ = 0;
	certificate_timestamp__elem_ = 0;
	key_share_ = 0;
	key_share__elem_ = 0;
	supported_versions_selector_ = 0;
	supported_versions_selector__elem_ = 0;
	psk_key_exchange_modes_ = 0;
	psk_key_exchange_modes__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

SSLExtension::~SSLExtension()
	{
	switch ( ext_case_index() )
		{
		case 16:
			// Clean up "apnl"
			{
			delete apnl__elem_;
			apnl__elem_ = 0;
			if ( apnl() )
				{
				for ( int i = 0; i < (int) apnl()->size(); ++i )
					{
					ApplicationLayerProtocolNegotiationExtension * apnl__elem_ = (*apnl_)[i];
					delete apnl__elem_;
					apnl__elem_ = 0;
					}
				}
			delete apnl_;
			}
			break;
		case 10:
			// Clean up "elliptic_curves"
			{
			delete elliptic_curves__elem_;
			elliptic_curves__elem_ = 0;
			if ( elliptic_curves() )
				{
				for ( int i = 0; i < (int) elliptic_curves()->size(); ++i )
					{
					EllipticCurves * elliptic_curves__elem_ = (*elliptic_curves_)[i];
					delete elliptic_curves__elem_;
					elliptic_curves__elem_ = 0;
					}
				}
			delete elliptic_curves_;
			}
			break;
		case 11:
			// Clean up "ec_point_formats"
			{
			delete ec_point_formats__elem_;
			ec_point_formats__elem_ = 0;
			if ( ec_point_formats() )
				{
				for ( int i = 0; i < (int) ec_point_formats()->size(); ++i )
					{
					EcPointFormats * ec_point_formats__elem_ = (*ec_point_formats_)[i];
					delete ec_point_formats__elem_;
					ec_point_formats__elem_ = 0;
					}
				}
			delete ec_point_formats_;
			}
			break;
		case 0:
			// Clean up "server_name"
			{
			delete server_name__elem_;
			server_name__elem_ = 0;
			if ( server_name() )
				{
				for ( int i = 0; i < (int) server_name()->size(); ++i )
					{
					ServerNameExt * server_name__elem_ = (*server_name_)[i];
					delete server_name__elem_;
					server_name__elem_ = 0;
					}
				}
			delete server_name_;
			}
			break;
		case 13:
			// Clean up "signature_algorithm"
			{
			delete signature_algorithm__elem_;
			signature_algorithm__elem_ = 0;
			if ( signature_algorithm() )
				{
				for ( int i = 0; i < (int) signature_algorithm()->size(); ++i )
					{
					SignatureAlgorithm * signature_algorithm__elem_ = (*signature_algorithm_)[i];
					delete signature_algorithm__elem_;
					signature_algorithm__elem_ = 0;
					}
				}
			delete signature_algorithm_;
			}
			break;
		case 18:
			// Clean up "certificate_timestamp"
			{
			delete certificate_timestamp__elem_;
			certificate_timestamp__elem_ = 0;
			if ( certificate_timestamp() )
				{
				for ( int i = 0; i < (int) certificate_timestamp()->size(); ++i )
					{
					SignedCertificateTimestampList * certificate_timestamp__elem_ = (*certificate_timestamp_)[i];
					delete certificate_timestamp__elem_;
					certificate_timestamp__elem_ = 0;
					}
				}
			delete certificate_timestamp_;
			}
			break;
		case 40:
			// Clean up "key_share"
			{
			delete key_share__elem_;
			key_share__elem_ = 0;
			if ( key_share() )
				{
				for ( int i = 0; i < (int) key_share()->size(); ++i )
					{
					KeyShare * key_share__elem_ = (*key_share_)[i];
					delete key_share__elem_;
					key_share__elem_ = 0;
					}
				}
			delete key_share_;
			}
			break;
		case 43:
			// Clean up "supported_versions_selector"
			{
			delete supported_versions_selector__elem_;
			supported_versions_selector__elem_ = 0;
			if ( supported_versions_selector() )
				{
				for ( int i = 0; i < (int) supported_versions_selector()->size(); ++i )
					{
					SupportedVersionsSelector * supported_versions_selector__elem_ = (*supported_versions_selector_)[i];
					delete supported_versions_selector__elem_;
					supported_versions_selector__elem_ = 0;
					}
				}
			delete supported_versions_selector_;
			}
			break;
		case 45:
			// Clean up "psk_key_exchange_modes"
			{
			delete psk_key_exchange_modes__elem_;
			psk_key_exchange_modes__elem_ = 0;
			if ( psk_key_exchange_modes() )
				{
				for ( int i = 0; i < (int) psk_key_exchange_modes()->size(); ++i )
					{
					PSKKeyExchangeModes * psk_key_exchange_modes__elem_ = (*psk_key_exchange_modes_)[i];
					delete psk_key_exchange_modes__elem_;
					psk_key_exchange_modes__elem_ = 0;
					}
				}
			delete psk_key_exchange_modes_;
			}
			break;
		default:
			// Clean up "data"
			{
			data_.free();
			}
			break;
		}
	}

int SSLExtension::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_SSLExtension__size;
	// Checking out-of-bound for "SSLExtension:data_len"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SSLExtension:data_len",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "data_len"
	data_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	t_SSLExtension__size = data_len() + 4;
	// Checking out-of-bound for "SSLExtension"
	if ( t_begin_of_data + (t_SSLExtension__size) > t_end_of_data || t_begin_of_data + (t_SSLExtension__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SSLExtension",
			(0) + (t_SSLExtension__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_SSLExtension__size;
	sourcedata_ = const_bytestring(t_begin_of_data, t_end_of_data);
	// Parse "type"
	type_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "ext"
	int t_ext__size;
	ext_case_index_ = type();
	switch ( ext_case_index() )
		{
		case 16:
			// Parse "apnl"
			{
			int t_apnl__arraylength;
			t_apnl__arraylength = 0;
			apnl__elem_ = 0;
			int t_apnl__elem__it;
			t_apnl__elem__it = 0;
			int t_apnl__size;
			apnl_ = new vector<ApplicationLayerProtocolNegotiationExtension *>;
			const_byteptr t_apnl__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_apnl__elem__it)
				{
				// Check &until(apnl__elem__dataptr >= end_of_data)
				if ( t_apnl__elem__dataptr >= t_end_of_data )
					{
					apnl__elem_ = 0;
					goto end_of_apnl;
					}
				apnl__elem_ = new ApplicationLayerProtocolNegotiationExtension(rec());
				int t_apnl__elem__size;
				t_apnl__elem__size = apnl__elem_->Parse(t_apnl__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				apnl_->push_back(apnl__elem_);
				t_apnl__elem__dataptr += t_apnl__elem__size;
				BINPAC_ASSERT(t_apnl__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( apnl__elem_ == 0 || apnl__elem_ != 0 )  )
					{
					apnl__elem_ = 0;
					goto end_of_apnl;
					}
				apnl__elem_ = 0;
				}
		end_of_apnl: ;
			t_apnl__size = t_apnl__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_apnl__size;
			}
			break;
		case 10:
			// Parse "elliptic_curves"
			{
			int t_elliptic_curves__arraylength;
			t_elliptic_curves__arraylength = 0;
			elliptic_curves__elem_ = 0;
			int t_elliptic_curves__elem__it;
			t_elliptic_curves__elem__it = 0;
			int t_elliptic_curves__size;
			elliptic_curves_ = new vector<EllipticCurves *>;
			const_byteptr t_elliptic_curves__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_elliptic_curves__elem__it)
				{
				// Check &until(elliptic_curves__elem__dataptr >= end_of_data)
				if ( t_elliptic_curves__elem__dataptr >= t_end_of_data )
					{
					elliptic_curves__elem_ = 0;
					goto end_of_elliptic_curves;
					}
				elliptic_curves__elem_ = new EllipticCurves(rec());
				int t_elliptic_curves__elem__size;
				t_elliptic_curves__elem__size = elliptic_curves__elem_->Parse(t_elliptic_curves__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				elliptic_curves_->push_back(elliptic_curves__elem_);
				t_elliptic_curves__elem__dataptr += t_elliptic_curves__elem__size;
				BINPAC_ASSERT(t_elliptic_curves__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( elliptic_curves__elem_ == 0 || elliptic_curves__elem_ != 0 )  )
					{
					elliptic_curves__elem_ = 0;
					goto end_of_elliptic_curves;
					}
				elliptic_curves__elem_ = 0;
				}
		end_of_elliptic_curves: ;
			t_elliptic_curves__size = t_elliptic_curves__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_elliptic_curves__size;
			}
			break;
		case 11:
			// Parse "ec_point_formats"
			{
			int t_ec_point_formats__arraylength;
			t_ec_point_formats__arraylength = 0;
			ec_point_formats__elem_ = 0;
			int t_ec_point_formats__elem__it;
			t_ec_point_formats__elem__it = 0;
			int t_ec_point_formats__size;
			ec_point_formats_ = new vector<EcPointFormats *>;
			const_byteptr t_ec_point_formats__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_ec_point_formats__elem__it)
				{
				// Check &until(ec_point_formats__elem__dataptr >= end_of_data)
				if ( t_ec_point_formats__elem__dataptr >= t_end_of_data )
					{
					ec_point_formats__elem_ = 0;
					goto end_of_ec_point_formats;
					}
				ec_point_formats__elem_ = new EcPointFormats(rec());
				int t_ec_point_formats__elem__size;
				t_ec_point_formats__elem__size = ec_point_formats__elem_->Parse(t_ec_point_formats__elem__dataptr, t_end_of_data, t_context);
				// Evaluate 'let' and 'withinput' fields
				ec_point_formats_->push_back(ec_point_formats__elem_);
				t_ec_point_formats__elem__dataptr += t_ec_point_formats__elem__size;
				BINPAC_ASSERT(t_ec_point_formats__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( ec_point_formats__elem_ == 0 || ec_point_formats__elem_ != 0 )  )
					{
					ec_point_formats__elem_ = 0;
					goto end_of_ec_point_formats;
					}
				ec_point_formats__elem_ = 0;
				}
		end_of_ec_point_formats: ;
			t_ec_point_formats__size = t_ec_point_formats__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_ec_point_formats__size;
			}
			break;
		case 0:
			// Parse "server_name"
			{
			int t_server_name__arraylength;
			t_server_name__arraylength = 0;
			server_name__elem_ = 0;
			int t_server_name__elem__it;
			t_server_name__elem__it = 0;
			int t_server_name__size;
			server_name_ = new vector<ServerNameExt *>;
			const_byteptr t_server_name__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_server_name__elem__it)
				{
				// Check &until(server_name__elem__dataptr >= end_of_data)
				if ( t_server_name__elem__dataptr >= t_end_of_data )
					{
					server_name__elem_ = 0;
					goto end_of_server_name;
					}
				server_name__elem_ = new ServerNameExt(rec());
				int t_server_name__elem__size;
				t_server_name__elem__size = server_name__elem_->Parse(t_server_name__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				server_name_->push_back(server_name__elem_);
				t_server_name__elem__dataptr += t_server_name__elem__size;
				BINPAC_ASSERT(t_server_name__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( server_name__elem_ == 0 || server_name__elem_ != 0 )  )
					{
					server_name__elem_ = 0;
					goto end_of_server_name;
					}
				server_name__elem_ = 0;
				}
		end_of_server_name: ;
			t_server_name__size = t_server_name__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_server_name__size;
			}
			break;
		case 13:
			// Parse "signature_algorithm"
			{
			int t_signature_algorithm__arraylength;
			t_signature_algorithm__arraylength = 0;
			signature_algorithm__elem_ = 0;
			int t_signature_algorithm__elem__it;
			t_signature_algorithm__elem__it = 0;
			int t_signature_algorithm__size;
			signature_algorithm_ = new vector<SignatureAlgorithm *>;
			const_byteptr t_signature_algorithm__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_signature_algorithm__elem__it)
				{
				// Check &until(signature_algorithm__elem__dataptr >= end_of_data)
				if ( t_signature_algorithm__elem__dataptr >= t_end_of_data )
					{
					signature_algorithm__elem_ = 0;
					goto end_of_signature_algorithm;
					}
				signature_algorithm__elem_ = new SignatureAlgorithm(rec());
				int t_signature_algorithm__elem__size;
				t_signature_algorithm__elem__size = signature_algorithm__elem_->Parse(t_signature_algorithm__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				signature_algorithm_->push_back(signature_algorithm__elem_);
				t_signature_algorithm__elem__dataptr += t_signature_algorithm__elem__size;
				BINPAC_ASSERT(t_signature_algorithm__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( signature_algorithm__elem_ == 0 || signature_algorithm__elem_ != 0 )  )
					{
					signature_algorithm__elem_ = 0;
					goto end_of_signature_algorithm;
					}
				signature_algorithm__elem_ = 0;
				}
		end_of_signature_algorithm: ;
			t_signature_algorithm__size = t_signature_algorithm__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_signature_algorithm__size;
			}
			break;
		case 18:
			// Parse "certificate_timestamp"
			{
			int t_certificate_timestamp__arraylength;
			t_certificate_timestamp__arraylength = 0;
			certificate_timestamp__elem_ = 0;
			int t_certificate_timestamp__elem__it;
			t_certificate_timestamp__elem__it = 0;
			int t_certificate_timestamp__size;
			certificate_timestamp_ = new vector<SignedCertificateTimestampList *>;
			const_byteptr t_certificate_timestamp__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_certificate_timestamp__elem__it)
				{
				// Check &until(certificate_timestamp__elem__dataptr >= end_of_data)
				if ( t_certificate_timestamp__elem__dataptr >= t_end_of_data )
					{
					certificate_timestamp__elem_ = 0;
					goto end_of_certificate_timestamp;
					}
				certificate_timestamp__elem_ = new SignedCertificateTimestampList(rec());
				int t_certificate_timestamp__elem__size;
				t_certificate_timestamp__elem__size = certificate_timestamp__elem_->Parse(t_certificate_timestamp__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				certificate_timestamp_->push_back(certificate_timestamp__elem_);
				t_certificate_timestamp__elem__dataptr += t_certificate_timestamp__elem__size;
				BINPAC_ASSERT(t_certificate_timestamp__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( certificate_timestamp__elem_ == 0 || certificate_timestamp__elem_ != 0 )  )
					{
					certificate_timestamp__elem_ = 0;
					goto end_of_certificate_timestamp;
					}
				certificate_timestamp__elem_ = 0;
				}
		end_of_certificate_timestamp: ;
			t_certificate_timestamp__size = t_certificate_timestamp__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_certificate_timestamp__size;
			}
			break;
		case 40:
			// Parse "key_share"
			{
			int t_key_share__arraylength;
			t_key_share__arraylength = 0;
			key_share__elem_ = 0;
			int t_key_share__elem__it;
			t_key_share__elem__it = 0;
			int t_key_share__size;
			key_share_ = new vector<KeyShare *>;
			const_byteptr t_key_share__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_key_share__elem__it)
				{
				// Check &until(key_share__elem__dataptr >= end_of_data)
				if ( t_key_share__elem__dataptr >= t_end_of_data )
					{
					key_share__elem_ = 0;
					goto end_of_key_share;
					}
				key_share__elem_ = new KeyShare(rec());
				int t_key_share__elem__size;
				t_key_share__elem__size = key_share__elem_->Parse(t_key_share__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				key_share_->push_back(key_share__elem_);
				t_key_share__elem__dataptr += t_key_share__elem__size;
				BINPAC_ASSERT(t_key_share__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( key_share__elem_ == 0 || key_share__elem_ != 0 )  )
					{
					key_share__elem_ = 0;
					goto end_of_key_share;
					}
				key_share__elem_ = 0;
				}
		end_of_key_share: ;
			t_key_share__size = t_key_share__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_key_share__size;
			}
			break;
		case 43:
			// Parse "supported_versions_selector"
			{
			int t_supported_versions_selector__arraylength;
			t_supported_versions_selector__arraylength = 0;
			supported_versions_selector__elem_ = 0;
			int t_supported_versions_selector__elem__it;
			t_supported_versions_selector__elem__it = 0;
			int t_supported_versions_selector__size;
			supported_versions_selector_ = new vector<SupportedVersionsSelector *>;
			const_byteptr t_supported_versions_selector__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_supported_versions_selector__elem__it)
				{
				// Check &until(supported_versions_selector__elem__dataptr >= end_of_data)
				if ( t_supported_versions_selector__elem__dataptr >= t_end_of_data )
					{
					supported_versions_selector__elem_ = 0;
					goto end_of_supported_versions_selector;
					}
				supported_versions_selector__elem_ = new SupportedVersionsSelector(rec(), data_len());
				int t_supported_versions_selector__elem__size;
				t_supported_versions_selector__elem__size = supported_versions_selector__elem_->Parse(t_supported_versions_selector__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				supported_versions_selector_->push_back(supported_versions_selector__elem_);
				t_supported_versions_selector__elem__dataptr += t_supported_versions_selector__elem__size;
				BINPAC_ASSERT(t_supported_versions_selector__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( supported_versions_selector__elem_ == 0 || supported_versions_selector__elem_ != 0 )  )
					{
					supported_versions_selector__elem_ = 0;
					goto end_of_supported_versions_selector;
					}
				supported_versions_selector__elem_ = 0;
				}
		end_of_supported_versions_selector: ;
			t_supported_versions_selector__size = t_supported_versions_selector__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_supported_versions_selector__size;
			}
			break;
		case 45:
			// Parse "psk_key_exchange_modes"
			{
			int t_psk_key_exchange_modes__arraylength;
			t_psk_key_exchange_modes__arraylength = 0;
			psk_key_exchange_modes__elem_ = 0;
			int t_psk_key_exchange_modes__elem__it;
			t_psk_key_exchange_modes__elem__it = 0;
			int t_psk_key_exchange_modes__size;
			psk_key_exchange_modes_ = new vector<PSKKeyExchangeModes *>;
			const_byteptr t_psk_key_exchange_modes__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_psk_key_exchange_modes__elem__it)
				{
				// Check &until(psk_key_exchange_modes__elem__dataptr >= end_of_data)
				if ( t_psk_key_exchange_modes__elem__dataptr >= t_end_of_data )
					{
					psk_key_exchange_modes__elem_ = 0;
					goto end_of_psk_key_exchange_modes;
					}
				psk_key_exchange_modes__elem_ = new PSKKeyExchangeModes(rec());
				int t_psk_key_exchange_modes__elem__size;
				t_psk_key_exchange_modes__elem__size = psk_key_exchange_modes__elem_->Parse(t_psk_key_exchange_modes__elem__dataptr, t_end_of_data, t_context);
				// Evaluate 'let' and 'withinput' fields
				psk_key_exchange_modes_->push_back(psk_key_exchange_modes__elem_);
				t_psk_key_exchange_modes__elem__dataptr += t_psk_key_exchange_modes__elem__size;
				BINPAC_ASSERT(t_psk_key_exchange_modes__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( psk_key_exchange_modes__elem_ == 0 || psk_key_exchange_modes__elem_ != 0 )  )
					{
					psk_key_exchange_modes__elem_ = 0;
					goto end_of_psk_key_exchange_modes;
					}
				psk_key_exchange_modes__elem_ = 0;
				}
		end_of_psk_key_exchange_modes: ;
			t_psk_key_exchange_modes__size = t_psk_key_exchange_modes__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_psk_key_exchange_modes__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:781", t_data_string_length);
			data_.init((t_begin_of_data + 4), t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ssl_extension(rec(), type(), sourcedata());
	sourcedata_.set_end(t_begin_of_data + t_SSLExtension__size);
	}
	BINPAC_ASSERT(t_begin_of_data + (t_SSLExtension__size) <= t_end_of_data);
	return t_SSLExtension__size;
	}

SignatureAndHashAlgorithm::SignatureAndHashAlgorithm()
	{
	HashAlgorithm_ = 0;
	SignatureAlgorithm_ = 0;
	}

SignatureAndHashAlgorithm::~SignatureAndHashAlgorithm()
	{
	}

int SignatureAndHashAlgorithm::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SignatureAndHashAlgorithm"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignatureAndHashAlgorithm",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "HashAlgorithm"
	HashAlgorithm_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "SignatureAlgorithm"
	SignatureAlgorithm_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

SignedCertificateTimestampList::SignedCertificateTimestampList(HandshakeRecord * rec)
	{
	length_ = 0;
	SCTs_ = 0;
	SCTs__elem_ = 0;
	rec_ = rec;
	}

SignedCertificateTimestampList::~SignedCertificateTimestampList()
	{
	delete SCTs__elem_;
	SCTs__elem_ = 0;
	if ( SCTs() )
		{
		for ( int i = 0; i < (int) SCTs()->size(); ++i )
			{
			SignedCertificateTimestamp * SCTs__elem_ = (*SCTs_)[i];
			delete SCTs__elem_;
			SCTs__elem_ = 0;
			}
		}
	delete SCTs_;
	}

int SignedCertificateTimestampList::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_SignedCertificateTimestampList__size;
	// Checking out-of-bound for "SignedCertificateTimestampList:length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestampList:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	t_SignedCertificateTimestampList__size = length() + 2;
	// Checking out-of-bound for "SignedCertificateTimestampList"
	if ( t_begin_of_data + (t_SignedCertificateTimestampList__size) > t_end_of_data || t_begin_of_data + (t_SignedCertificateTimestampList__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestampList",
			(0) + (t_SignedCertificateTimestampList__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_SignedCertificateTimestampList__size;
	
	// Parse "SCTs"
	int t_SCTs__arraylength;
	t_SCTs__arraylength = 0;
	SCTs__elem_ = 0;
	int t_SCTs__elem__it;
	t_SCTs__elem__it = 0;
	int t_SCTs__size;
	SCTs_ = new vector<SignedCertificateTimestamp *>;
	const_byteptr t_SCTs__elem__dataptr = (t_begin_of_data + 2);
	for (; /* forever */; ++t_SCTs__elem__it)
		{
		// Check &until(SCTs__elem__dataptr >= end_of_data)
		if ( t_SCTs__elem__dataptr >= t_end_of_data )
			{
			SCTs__elem_ = 0;
			goto end_of_SCTs;
			}
		SCTs__elem_ = new SignedCertificateTimestamp(rec());
		int t_SCTs__elem__size;
		t_SCTs__elem__size = SCTs__elem_->Parse(t_SCTs__elem__dataptr, t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		SCTs_->push_back(SCTs__elem_);
		t_SCTs__elem__dataptr += t_SCTs__elem__size;
		BINPAC_ASSERT(t_SCTs__elem__dataptr <= t_end_of_data);
		SCTs__elem_ = 0;
		}
end_of_SCTs: ;
	t_SCTs__size = t_SCTs__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	}
	BINPAC_ASSERT(t_begin_of_data + (t_SignedCertificateTimestampList__size) <= t_end_of_data);
	return t_SignedCertificateTimestampList__size;
	}

SignedCertificateTimestamp::SignedCertificateTimestamp(HandshakeRecord * rec)
	{
	length_ = 0;
	version_ = 0;
	timestamp_ = 0;
	extensions_length_ = 0;
	digitally_signed_algorithms_ = 0;
	digitally_signed_signature_length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

SignedCertificateTimestamp::~SignedCertificateTimestamp()
	{
	logid_.free();
	extensions_.free();
	delete digitally_signed_algorithms_;
	digitally_signed_algorithms_ = 0;
	digitally_signed_signature_.free();
	}

int SignedCertificateTimestamp::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_SignedCertificateTimestamp__size;
	// Checking out-of-bound for "SignedCertificateTimestamp:version"
	if ( (t_begin_of_data + 2) + (1) > t_end_of_data || (t_begin_of_data + 2) + (1) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestamp:version",
			(2) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	t_SignedCertificateTimestamp__size = length() + 2;
	// Checking out-of-bound for "SignedCertificateTimestamp"
	if ( t_begin_of_data + (t_SignedCertificateTimestamp__size) > t_end_of_data || t_begin_of_data + (t_SignedCertificateTimestamp__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestamp",
			(0) + (t_SignedCertificateTimestamp__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_SignedCertificateTimestamp__size;
	
	// Parse "version"
	version_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "logid"
	// Checking out-of-bound for "SignedCertificateTimestamp:logid"
	if ( (t_begin_of_data + 3) + (32) > t_end_of_data || (t_begin_of_data + 3) + (32) < (t_begin_of_data + 3) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestamp:logid",
			(3) + (32), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + 32;
	int t_logid_string_length;
	t_logid_string_length = 32;
	int t_logid__size;
	t_logid__size = t_logid_string_length;
	logid_.init((t_begin_of_data + 3), t_logid_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_logid = (t_begin_of_data + 3) + (32);
	BINPAC_ASSERT(t_dataptr_after_logid <= t_end_of_data);
	// Checking out-of-bound for "SignedCertificateTimestamp:extensions_length"
	if ( (t_dataptr_after_logid + 8) + (2) > t_end_of_data || (t_dataptr_after_logid + 8) + (2) < (t_dataptr_after_logid + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestamp:extensions_length",
			(((t_dataptr_after_logid + 8) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "timestamp"
	timestamp_ = FixByteOrder(t_byteorder, *((uint64 const *) (t_dataptr_after_logid)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "extensions_length"
	extensions_length_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_logid + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "extensions"
	int t_extensions__size;
	t_extensions__size = extensions_length();
	// Checking out-of-bound for "SignedCertificateTimestamp:extensions"
	if ( (t_dataptr_after_logid + 10) + (t_extensions__size) > t_end_of_data || (t_dataptr_after_logid + 10) + (t_extensions__size) < (t_dataptr_after_logid + 10) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestamp:extensions",
			(((t_dataptr_after_logid + 10) - t_begin_of_data)) + (t_extensions__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_logid + 10) + t_extensions__size;
	int t_extensions_string_length;
	t_extensions_string_length = extensions_length();
	// check for negative sizes
	if ( t_extensions_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-signed_certificate_timestamp.pac:23", t_extensions_string_length);
	extensions_.init((t_dataptr_after_logid + 10), t_extensions_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_extensions = (t_dataptr_after_logid + 10) + (t_extensions__size);
	BINPAC_ASSERT(t_dataptr_after_extensions <= t_end_of_data);
	// Checking out-of-bound for "SignedCertificateTimestamp:digitally_signed_signature_length"
	if ( (t_dataptr_after_extensions + 2) + (2) > t_end_of_data || (t_dataptr_after_extensions + 2) + (2) < (t_dataptr_after_extensions + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestamp:digitally_signed_signature_length",
			(((t_dataptr_after_extensions + 2) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "digitally_signed_algorithms"
	digitally_signed_algorithms_ = new SignatureAndHashAlgorithm();
	digitally_signed_algorithms_->Parse(t_dataptr_after_extensions, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "digitally_signed_signature_length"
	digitally_signed_signature_length_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_extensions + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "digitally_signed_signature"
	int t_digitally_signed_signature__size;
	t_digitally_signed_signature__size = digitally_signed_signature_length();
	// Checking out-of-bound for "SignedCertificateTimestamp:digitally_signed_signature"
	if ( (t_dataptr_after_extensions + 4) + (t_digitally_signed_signature__size) > t_end_of_data || (t_dataptr_after_extensions + 4) + (t_digitally_signed_signature__size) < (t_dataptr_after_extensions + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignedCertificateTimestamp:digitally_signed_signature",
			(((t_dataptr_after_extensions + 4) - t_begin_of_data)) + (t_digitally_signed_signature__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_extensions + 4) + t_digitally_signed_signature__size;
	int t_digitally_signed_signature_string_length;
	t_digitally_signed_signature_string_length = digitally_signed_signature_length();
	// check for negative sizes
	if ( t_digitally_signed_signature_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-signed_certificate_timestamp.pac:26", t_digitally_signed_signature_string_length);
	digitally_signed_signature_.init((t_dataptr_after_extensions + 4), t_digitally_signed_signature_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_signedcertificatetimestamp(rec(), version(), logid(), timestamp(), digitally_signed_algorithms(), digitally_signed_signature());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_SignedCertificateTimestamp__size) <= t_end_of_data);
	return t_SignedCertificateTimestamp__size;
	}

SupportedVersionsSelector::SupportedVersionsSelector(HandshakeRecord * rec, uint16 data_len)
	{
	val_case_index_ = -1;
	a_ = 0;
	b_ = 0;
	rec_ = rec;
	data_len_ = data_len;
	}

SupportedVersionsSelector::~SupportedVersionsSelector()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "a"
			{
			delete a_;
			a_ = 0;
			}
			break;
		case 0:
			// Clean up "b"
			{
			delete b_;
			b_ = 0;
			}
			break;
		}
	}

int SupportedVersionsSelector::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = rec()->is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "a"
			{
			a_ = new SupportedVersions(rec());
			int t_a__size;
			t_a__size = a_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_a__size;
			}
			break;
		case 0:
			// Parse "b"
			{
			b_ = new OneSupportedVersion(rec());
			b_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 2;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SupportedVersionsSelector", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SupportedVersions::SupportedVersions(HandshakeRecord * rec)
	{
	length_ = 0;
	versions_ = 0;
	versions__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

SupportedVersions::~SupportedVersions()
	{
	delete versions_;
	}

int SupportedVersions::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_SupportedVersions__size;
	// Checking out-of-bound for "SupportedVersions:length"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SupportedVersions:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	t_SupportedVersions__size = length() + 1;
	// Checking out-of-bound for "SupportedVersions"
	if ( t_begin_of_data + (t_SupportedVersions__size) > t_end_of_data || t_begin_of_data + (t_SupportedVersions__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SupportedVersions",
			(0) + (t_SupportedVersions__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_SupportedVersions__size;
	
	// Parse "versions"
	int t_versions__arraylength;
	t_versions__arraylength = 0;
	versions__elem_ = 0;
	int t_versions__elem__it;
	t_versions__elem__it = 0;
	int t_versions__size;
	versions_ = new vector<uint16>;
	const_byteptr t_versions__elem__dataptr = (t_begin_of_data + 1);
	for (; /* forever */; ++t_versions__elem__it)
		{
		// Check &until(versions__elem__dataptr >= end_of_data)
		if ( t_versions__elem__dataptr >= t_end_of_data )
			{
			goto end_of_versions;
			}
		// Checking out-of-bound for "SupportedVersions:versions__elem"
		if ( t_versions__elem__dataptr + (2) > t_end_of_data || t_versions__elem__dataptr + (2) < t_versions__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SupportedVersions:versions__elem",
				((t_versions__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		versions__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_versions__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		versions_->push_back(versions__elem_);
		t_versions__elem__dataptr += 2;
		BINPAC_ASSERT(t_versions__elem__dataptr <= t_end_of_data);
		}
end_of_versions: ;
	t_versions__size = t_versions__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_supported_versions(rec(), versions());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_SupportedVersions__size) <= t_end_of_data);
	return t_SupportedVersions__size;
	}

OneSupportedVersion::OneSupportedVersion(HandshakeRecord * rec)
	{
	version_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

OneSupportedVersion::~OneSupportedVersion()
	{
	}

int OneSupportedVersion::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "OneSupportedVersion"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OneSupportedVersion",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "version"
	version_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_one_supported_version(rec(), version());
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

PSKKeyExchangeModes::PSKKeyExchangeModes(HandshakeRecord * rec)
	{
	length_ = 0;
	modes_ = 0;
	modes__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

PSKKeyExchangeModes::~PSKKeyExchangeModes()
	{
	delete modes_;
	}

int PSKKeyExchangeModes::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	int t_PSKKeyExchangeModes__size;
	// Checking out-of-bound for "PSKKeyExchangeModes:length"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PSKKeyExchangeModes:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	t_PSKKeyExchangeModes__size = length() + 1;
	// Checking out-of-bound for "PSKKeyExchangeModes"
	if ( t_begin_of_data + (t_PSKKeyExchangeModes__size) > t_end_of_data || t_begin_of_data + (t_PSKKeyExchangeModes__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PSKKeyExchangeModes",
			(0) + (t_PSKKeyExchangeModes__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_PSKKeyExchangeModes__size;
	
	// Parse "modes"
	int t_modes__arraylength;
	t_modes__arraylength = 0;
	modes__elem_ = 0;
	int t_modes__elem__it;
	t_modes__elem__it = 0;
	int t_modes__size;
	modes_ = new vector<uint8>;
	const_byteptr t_modes__elem__dataptr = (t_begin_of_data + 1);
	for (; /* forever */; ++t_modes__elem__it)
		{
		// Check &until(modes__elem__dataptr >= end_of_data)
		if ( t_modes__elem__dataptr >= t_end_of_data )
			{
			goto end_of_modes;
			}
		// Checking out-of-bound for "PSKKeyExchangeModes:modes__elem"
		if ( t_modes__elem__dataptr + (1) > t_end_of_data || t_modes__elem__dataptr + (1) < t_modes__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("PSKKeyExchangeModes:modes__elem",
				((t_modes__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		modes__elem_ = *((uint8 const *) (t_modes__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		modes_->push_back(modes__elem_);
		t_modes__elem__dataptr += 1;
		BINPAC_ASSERT(t_modes__elem__dataptr <= t_end_of_data);
		}
end_of_modes: ;
	t_modes__size = t_modes__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_psk_key_exchange_modes(rec(), modes());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_PSKKeyExchangeModes__size) <= t_end_of_data);
	return t_PSKKeyExchangeModes__size;
	}

ServerNameHostName::ServerNameHostName()
	{
	length_ = 0;
	}

ServerNameHostName::~ServerNameHostName()
	{
	host_name_.free();
	}

int ServerNameHostName::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "ServerNameHostName:length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameHostName:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "host_name"
	int t_host_name__size;
	t_host_name__size = length();
	// Checking out-of-bound for "ServerNameHostName:host_name"
	if ( (t_begin_of_data + 2) + (t_host_name__size) > t_end_of_data || (t_begin_of_data + 2) + (t_host_name__size) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameHostName:host_name",
			(2) + (t_host_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_host_name__size;
	int t_host_name_string_length;
	t_host_name_string_length = length();
	// check for negative sizes
	if ( t_host_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:808", t_host_name_string_length);
	host_name_.init((t_begin_of_data + 2), t_host_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ServerNameHostName__size;
	const_byteptr const t_dataptr_after_host_name = (t_begin_of_data + 2) + (t_host_name__size);
	BINPAC_ASSERT(t_dataptr_after_host_name <= t_end_of_data);
	t_ServerNameHostName__size = t_dataptr_after_host_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ServerNameHostName__size) <= t_end_of_data);
	return t_ServerNameHostName__size;
	}

ServerName::ServerName()
	{
	name_type_ = 0;
	name_case_index_ = -1;
	host_name_ = 0;
	}

ServerName::~ServerName()
	{
	switch ( name_case_index() )
		{
		case 0:
			// Clean up "host_name"
			{
			delete host_name_;
			host_name_ = 0;
			}
			break;
		default:
			// Clean up "data"
			{
			}
			break;
		}
	}

int ServerName::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "ServerName:name_type"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerName:name_type",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "name_type"
	name_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name"
	int t_name__size;
	name_case_index_ = name_type();
	switch ( name_case_index() )
		{
		case 0:
			// Parse "host_name"
			{
			host_name_ = new ServerNameHostName();
			int t_host_name__size;
			t_host_name__size = host_name_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_name__size = t_host_name__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 1));
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:815", t_data_string_length);
			data_.init((t_begin_of_data + 1), t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_name__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_ServerName__size;
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 1) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_ServerName__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ServerName__size) <= t_end_of_data);
	return t_ServerName__size;
	}

ServerNameExt::ServerNameExt(HandshakeRecord * rec)
	{
	length_ = 0;
	server_names_ = 0;
	server_names__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ServerNameExt::~ServerNameExt()
	{
	delete server_names__elem_;
	server_names__elem_ = 0;
	if ( server_names() )
		{
		for ( int i = 0; i < (int) server_names()->size(); ++i )
			{
			ServerName * server_names__elem_ = (*server_names_)[i];
			delete server_names__elem_;
			server_names__elem_ = 0;
			}
		}
	delete server_names_;
	}

int ServerNameExt::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_ServerNameExt__size;
	// Checking out-of-bound for "ServerNameExt:length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameExt:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	t_ServerNameExt__size = length() + 2;
	// Checking out-of-bound for "ServerNameExt"
	if ( t_begin_of_data + (t_ServerNameExt__size) > t_end_of_data || t_begin_of_data + (t_ServerNameExt__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameExt",
			(0) + (t_ServerNameExt__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_ServerNameExt__size;
	
	// Parse "server_names"
	int t_server_names__arraylength;
	t_server_names__arraylength = 0;
	server_names__elem_ = 0;
	int t_server_names__elem__it;
	t_server_names__elem__it = 0;
	int t_server_names__size;
	server_names_ = new vector<ServerName *>;
	const_byteptr t_server_names__elem__dataptr = (t_begin_of_data + 2);
	for (; /* forever */; ++t_server_names__elem__it)
		{
		// Check &until(server_names__elem__dataptr >= end_of_data)
		if ( t_server_names__elem__dataptr >= t_end_of_data )
			{
			server_names__elem_ = 0;
			goto end_of_server_names;
			}
		server_names__elem_ = new ServerName();
		int t_server_names__elem__size;
		t_server_names__elem__size = server_names__elem_->Parse(t_server_names__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		server_names_->push_back(server_names__elem_);
		t_server_names__elem__dataptr += t_server_names__elem__size;
		BINPAC_ASSERT(t_server_names__elem__dataptr <= t_end_of_data);
		server_names__elem_ = 0;
		}
end_of_server_names: ;
	t_server_names__size = t_server_names__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_server_name(rec(), server_names());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_ServerNameExt__size) <= t_end_of_data);
	return t_ServerNameExt__size;
	}

EcPointFormats::EcPointFormats(HandshakeRecord * rec)
	{
	length_ = 0;
	point_format_list_ = 0;
	point_format_list__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

EcPointFormats::~EcPointFormats()
	{
	delete point_format_list_;
	}

int EcPointFormats::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context)
	{
	// Checking out-of-bound for "EcPointFormats:length"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EcPointFormats:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "point_format_list"
	int t_point_format_list__arraylength;
	t_point_format_list__arraylength = 0;
	t_point_format_list__arraylength = length();
	if ( t_begin_of_data + t_point_format_list__arraylength > t_end_of_data + 1 || t_begin_of_data + t_point_format_list__arraylength < t_begin_of_data )
		{
		t_point_format_list__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_point_format_list__arraylength < 0 )
		{
		t_point_format_list__arraylength = 0;
		}
	point_format_list__elem_ = 0;
	int t_point_format_list__elem__it;
	t_point_format_list__elem__it = 0;
	int t_point_format_list__size;
	point_format_list_ = new vector<uint8>;
	point_format_list_->reserve(t_point_format_list__arraylength);
	const_byteptr t_point_format_list__elem__dataptr = (t_begin_of_data + 1);
	for (; t_point_format_list__elem__it < t_point_format_list__arraylength; ++t_point_format_list__elem__it)
		{
		// Check &until(point_format_list__elem__dataptr >= end_of_data)
		if ( t_point_format_list__elem__dataptr >= t_end_of_data )
			{
			goto end_of_point_format_list;
			}
		// Checking out-of-bound for "EcPointFormats:point_format_list__elem"
		if ( t_point_format_list__elem__dataptr + (1) > t_end_of_data || t_point_format_list__elem__dataptr + (1) < t_point_format_list__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("EcPointFormats:point_format_list__elem",
				((t_point_format_list__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		point_format_list__elem_ = *((uint8 const *) (t_point_format_list__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		point_format_list_->push_back(point_format_list__elem_);
		t_point_format_list__elem__dataptr += 1;
		BINPAC_ASSERT(t_point_format_list__elem__dataptr <= t_end_of_data);
		}
end_of_point_format_list: ;
	t_point_format_list__size = t_point_format_list__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	int t_EcPointFormats__size;
	const_byteptr const t_dataptr_after_point_format_list = (t_begin_of_data + 1) + (t_point_format_list__size);
	BINPAC_ASSERT(t_dataptr_after_point_format_list <= t_end_of_data);
	t_EcPointFormats__size = t_dataptr_after_point_format_list - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ec_point_formats(rec(), point_format_list());
	BINPAC_ASSERT(t_begin_of_data + (t_EcPointFormats__size) <= t_end_of_data);
	return t_EcPointFormats__size;
	}

KeyShareEntry::KeyShareEntry()
	{
	namedgroup_ = 0;
	key_exchange_length_ = 0;
	}

KeyShareEntry::~KeyShareEntry()
	{
	}

int KeyShareEntry::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "KeyShareEntry:key_exchange_length"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("KeyShareEntry:key_exchange_length",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "namedgroup"
	namedgroup_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "key_exchange_length"
	key_exchange_length_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "key_exchange"
	int t_key_exchange__size;
	t_key_exchange__size = key_exchange_length();
	// Checking out-of-bound for "KeyShareEntry:key_exchange"
	if ( (t_begin_of_data + 4) + (t_key_exchange__size) > t_end_of_data || (t_begin_of_data + 4) + (t_key_exchange__size) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("KeyShareEntry:key_exchange",
			(4) + (t_key_exchange__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_key_exchange__size;
	int t_key_exchange_string_length;
	t_key_exchange_string_length = key_exchange_length();
	// check for negative sizes
	if ( t_key_exchange_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:848", t_key_exchange_string_length);
	key_exchange_.init((t_begin_of_data + 4), t_key_exchange_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_KeyShareEntry__size;
	const_byteptr const t_dataptr_after_key_exchange = (t_begin_of_data + 4) + (t_key_exchange__size);
	BINPAC_ASSERT(t_dataptr_after_key_exchange <= t_end_of_data);
	t_KeyShareEntry__size = t_dataptr_after_key_exchange - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_KeyShareEntry__size) <= t_end_of_data);
	return t_KeyShareEntry__size;
	}

ServerHelloKeyShare::ServerHelloKeyShare(HandshakeRecord * rec)
	{
	keyshare_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ServerHelloKeyShare::~ServerHelloKeyShare()
	{
	delete keyshare_;
	keyshare_ = 0;
	}

int ServerHelloKeyShare::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Parse "keyshare"
	keyshare_ = new KeyShareEntry();
	int t_keyshare__size;
	t_keyshare__size = keyshare_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ServerHelloKeyShare__size;
	const_byteptr const t_dataptr_after_keyshare = t_begin_of_data + (t_keyshare__size);
	BINPAC_ASSERT(t_dataptr_after_keyshare <= t_end_of_data);
	t_ServerHelloKeyShare__size = t_dataptr_after_keyshare - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_server_key_share(rec(), keyshare());
	BINPAC_ASSERT(t_begin_of_data + (t_ServerHelloKeyShare__size) <= t_end_of_data);
	return t_ServerHelloKeyShare__size;
	}

ClientHelloKeyShare::ClientHelloKeyShare(HandshakeRecord * rec)
	{
	length_ = 0;
	keyshares_ = 0;
	keyshares__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ClientHelloKeyShare::~ClientHelloKeyShare()
	{
	delete keyshares__elem_;
	keyshares__elem_ = 0;
	if ( keyshares() )
		{
		for ( int i = 0; i < (int) keyshares()->size(); ++i )
			{
			KeyShareEntry * keyshares__elem_ = (*keyshares_)[i];
			delete keyshares__elem_;
			keyshares__elem_ = 0;
			}
		}
	delete keyshares_;
	}

int ClientHelloKeyShare::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ClientHelloKeyShare:length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHelloKeyShare:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "keyshares"
	int t_keyshares__arraylength;
	t_keyshares__arraylength = 0;
	keyshares__elem_ = 0;
	int t_keyshares__elem__it;
	t_keyshares__elem__it = 0;
	int t_keyshares__size;
	keyshares_ = new vector<KeyShareEntry *>;
	const_byteptr t_keyshares__elem__dataptr = (t_begin_of_data + 2);
	for (; /* forever */; ++t_keyshares__elem__it)
		{
		// Check &until(keyshares__elem__dataptr >= end_of_data)
		if ( t_keyshares__elem__dataptr >= t_end_of_data )
			{
			keyshares__elem_ = 0;
			goto end_of_keyshares;
			}
		keyshares__elem_ = new KeyShareEntry();
		int t_keyshares__elem__size;
		t_keyshares__elem__size = keyshares__elem_->Parse(t_keyshares__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		keyshares_->push_back(keyshares__elem_);
		t_keyshares__elem__dataptr += t_keyshares__elem__size;
		BINPAC_ASSERT(t_keyshares__elem__dataptr <= t_end_of_data);
		keyshares__elem_ = 0;
		}
end_of_keyshares: ;
	t_keyshares__size = t_keyshares__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_ClientHelloKeyShare__size;
	const_byteptr const t_dataptr_after_keyshares = (t_begin_of_data + 2) + (t_keyshares__size);
	BINPAC_ASSERT(t_dataptr_after_keyshares <= t_end_of_data);
	t_ClientHelloKeyShare__size = t_dataptr_after_keyshares - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_client_key_share(rec(), keyshares());
	BINPAC_ASSERT(t_begin_of_data + (t_ClientHelloKeyShare__size) <= t_end_of_data);
	return t_ClientHelloKeyShare__size;
	}

KeyShare::KeyShare(HandshakeRecord * rec)
	{
	val_case_index_ = -1;
	client_hello_keyshare_ = 0;
	server_hello_keyshare_ = 0;
	rec_ = rec;
	}

KeyShare::~KeyShare()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "client_hello_keyshare"
			{
			delete client_hello_keyshare_;
			client_hello_keyshare_ = 0;
			}
			break;
		case 2:
			// Clean up "server_hello_keyshare"
			{
			delete server_hello_keyshare_;
			server_hello_keyshare_ = 0;
			}
			break;
		default:
			// Clean up "other"
			{
			}
			break;
		}
	}

int KeyShare::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = rec()->msg_type();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "client_hello_keyshare"
			{
			client_hello_keyshare_ = new ClientHelloKeyShare(rec());
			int t_client_hello_keyshare__size;
			t_client_hello_keyshare__size = client_hello_keyshare_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_client_hello_keyshare__size;
			}
			break;
		case 2:
			// Parse "server_hello_keyshare"
			{
			server_hello_keyshare_ = new ServerHelloKeyShare(rec());
			int t_server_hello_keyshare__size;
			t_server_hello_keyshare__size = server_hello_keyshare_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_server_hello_keyshare__size;
			}
			break;
		default:
			// Parse "other"
			{
			int t_other_string_length;
			t_other_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_other__size;
			t_other__size = t_other_string_length;
			// check for negative sizes
			if ( t_other_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:864", t_other_string_length);
			other_.init(t_begin_of_data, t_other_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_other__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SignatureAlgorithm::SignatureAlgorithm(HandshakeRecord * rec)
	{
	length_ = 0;
	supported_signature_algorithms_ = 0;
	supported_signature_algorithms__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

SignatureAlgorithm::~SignatureAlgorithm()
	{
	delete supported_signature_algorithms__elem_;
	supported_signature_algorithms__elem_ = 0;
	if ( supported_signature_algorithms() )
		{
		for ( int i = 0; i < (int) supported_signature_algorithms()->size(); ++i )
			{
			SignatureAndHashAlgorithm * supported_signature_algorithms__elem_ = (*supported_signature_algorithms_)[i];
			delete supported_signature_algorithms__elem_;
			supported_signature_algorithms__elem_ = 0;
			}
		}
	delete supported_signature_algorithms_;
	}

int SignatureAlgorithm::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "SignatureAlgorithm:length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SignatureAlgorithm:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "supported_signature_algorithms"
	int t_supported_signature_algorithms__arraylength;
	t_supported_signature_algorithms__arraylength = 0;
	supported_signature_algorithms__elem_ = 0;
	int t_supported_signature_algorithms__elem__it;
	t_supported_signature_algorithms__elem__it = 0;
	int t_supported_signature_algorithms__size;
	supported_signature_algorithms_ = new vector<SignatureAndHashAlgorithm *>;
	const_byteptr t_supported_signature_algorithms__elem__dataptr = (t_begin_of_data + 2);
	for (; /* forever */; ++t_supported_signature_algorithms__elem__it)
		{
		// Check &until(supported_signature_algorithms__elem__dataptr >= end_of_data)
		if ( t_supported_signature_algorithms__elem__dataptr >= t_end_of_data )
			{
			supported_signature_algorithms__elem_ = 0;
			goto end_of_supported_signature_algorithms;
			}
		supported_signature_algorithms__elem_ = new SignatureAndHashAlgorithm();
		supported_signature_algorithms__elem_->Parse(t_supported_signature_algorithms__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		supported_signature_algorithms_->push_back(supported_signature_algorithms__elem_);
		t_supported_signature_algorithms__elem__dataptr += 2;
		BINPAC_ASSERT(t_supported_signature_algorithms__elem__dataptr <= t_end_of_data);
		supported_signature_algorithms__elem_ = 0;
		}
end_of_supported_signature_algorithms: ;
	t_supported_signature_algorithms__size = t_supported_signature_algorithms__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_SignatureAlgorithm__size;
	const_byteptr const t_dataptr_after_supported_signature_algorithms = (t_begin_of_data + 2) + (t_supported_signature_algorithms__size);
	BINPAC_ASSERT(t_dataptr_after_supported_signature_algorithms <= t_end_of_data);
	t_SignatureAlgorithm__size = t_dataptr_after_supported_signature_algorithms - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_signature_algorithm(rec(), supported_signature_algorithms());
	BINPAC_ASSERT(t_begin_of_data + (t_SignatureAlgorithm__size) <= t_end_of_data);
	return t_SignatureAlgorithm__size;
	}

EllipticCurves::EllipticCurves(HandshakeRecord * rec)
	{
	length_ = 0;
	elliptic_curve_list_ = 0;
	elliptic_curve_list__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

EllipticCurves::~EllipticCurves()
	{
	delete elliptic_curve_list_;
	}

int EllipticCurves::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EllipticCurves:length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EllipticCurves:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "elliptic_curve_list"
	int t_elliptic_curve_list__arraylength;
	t_elliptic_curve_list__arraylength = 0;
	t_elliptic_curve_list__arraylength = length() / 2;
	if ( t_begin_of_data + t_elliptic_curve_list__arraylength > t_end_of_data + 1 || t_begin_of_data + t_elliptic_curve_list__arraylength < t_begin_of_data )
		{
		t_elliptic_curve_list__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_elliptic_curve_list__arraylength < 0 )
		{
		t_elliptic_curve_list__arraylength = 0;
		}
	elliptic_curve_list__elem_ = 0;
	int t_elliptic_curve_list__elem__it;
	t_elliptic_curve_list__elem__it = 0;
	int t_elliptic_curve_list__size;
	elliptic_curve_list_ = new vector<uint16>;
	elliptic_curve_list_->reserve(t_elliptic_curve_list__arraylength);
	const_byteptr t_elliptic_curve_list__elem__dataptr = (t_begin_of_data + 2);
	for (; t_elliptic_curve_list__elem__it < t_elliptic_curve_list__arraylength; ++t_elliptic_curve_list__elem__it)
		{
		// Check &until(elliptic_curve_list__elem__dataptr >= end_of_data)
		if ( t_elliptic_curve_list__elem__dataptr >= t_end_of_data )
			{
			goto end_of_elliptic_curve_list;
			}
		// Checking out-of-bound for "EllipticCurves:elliptic_curve_list__elem"
		if ( t_elliptic_curve_list__elem__dataptr + (2) > t_end_of_data || t_elliptic_curve_list__elem__dataptr + (2) < t_elliptic_curve_list__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("EllipticCurves:elliptic_curve_list__elem",
				((t_elliptic_curve_list__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		elliptic_curve_list__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_elliptic_curve_list__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		elliptic_curve_list_->push_back(elliptic_curve_list__elem_);
		t_elliptic_curve_list__elem__dataptr += 2;
		BINPAC_ASSERT(t_elliptic_curve_list__elem__dataptr <= t_end_of_data);
		}
end_of_elliptic_curve_list: ;
	t_elliptic_curve_list__size = t_elliptic_curve_list__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_EllipticCurves__size;
	const_byteptr const t_dataptr_after_elliptic_curve_list = (t_begin_of_data + 2) + (t_elliptic_curve_list__size);
	BINPAC_ASSERT(t_dataptr_after_elliptic_curve_list <= t_end_of_data);
	t_EllipticCurves__size = t_dataptr_after_elliptic_curve_list - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_elliptic_curves(rec(), elliptic_curve_list());
	BINPAC_ASSERT(t_begin_of_data + (t_EllipticCurves__size) <= t_end_of_data);
	return t_EllipticCurves__size;
	}

ProtocolName::ProtocolName()
	{
	length_ = 0;
	}

ProtocolName::~ProtocolName()
	{
	name_.free();
	}

int ProtocolName::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ProtocolName:length"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ProtocolName:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name"
	int t_name__size;
	t_name__size = length();
	// Checking out-of-bound for "ProtocolName:name"
	if ( (t_begin_of_data + 1) + (t_name__size) > t_end_of_data || (t_begin_of_data + 1) + (t_name__size) < (t_begin_of_data + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ProtocolName:name",
			(1) + (t_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_name__size;
	int t_name_string_length;
	t_name_string_length = length();
	// check for negative sizes
	if ( t_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/tls-handshake-protocol.pac:879", t_name_string_length);
	name_.init((t_begin_of_data + 1), t_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ProtocolName__size;
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 1) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_ProtocolName__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ProtocolName__size) <= t_end_of_data);
	return t_ProtocolName__size;
	}

ApplicationLayerProtocolNegotiationExtension::ApplicationLayerProtocolNegotiationExtension(HandshakeRecord * rec)
	{
	length_ = 0;
	protocol_name_list_ = 0;
	protocol_name_list__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ApplicationLayerProtocolNegotiationExtension::~ApplicationLayerProtocolNegotiationExtension()
	{
	delete protocol_name_list__elem_;
	protocol_name_list__elem_ = 0;
	if ( protocol_name_list() )
		{
		for ( int i = 0; i < (int) protocol_name_list()->size(); ++i )
			{
			ProtocolName * protocol_name_list__elem_ = (*protocol_name_list_)[i];
			delete protocol_name_list__elem_;
			protocol_name_list__elem_ = 0;
			}
		}
	delete protocol_name_list_;
	}

int ApplicationLayerProtocolNegotiationExtension::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextTLSHandshake * t_context, int t_byteorder)
	{
	int t_ApplicationLayerProtocolNegotiationExtension__size;
	// Checking out-of-bound for "ApplicationLayerProtocolNegotiationExtension:length"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ApplicationLayerProtocolNegotiationExtension:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	t_ApplicationLayerProtocolNegotiationExtension__size = length() + 2;
	// Checking out-of-bound for "ApplicationLayerProtocolNegotiationExtension"
	if ( t_begin_of_data + (t_ApplicationLayerProtocolNegotiationExtension__size) > t_end_of_data || t_begin_of_data + (t_ApplicationLayerProtocolNegotiationExtension__size) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ApplicationLayerProtocolNegotiationExtension",
			(0) + (t_ApplicationLayerProtocolNegotiationExtension__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_ApplicationLayerProtocolNegotiationExtension__size;
	
	// Parse "protocol_name_list"
	int t_protocol_name_list__arraylength;
	t_protocol_name_list__arraylength = 0;
	protocol_name_list__elem_ = 0;
	int t_protocol_name_list__elem__it;
	t_protocol_name_list__elem__it = 0;
	int t_protocol_name_list__size;
	protocol_name_list_ = new vector<ProtocolName *>;
	const_byteptr t_protocol_name_list__elem__dataptr = (t_begin_of_data + 2);
	for (; /* forever */; ++t_protocol_name_list__elem__it)
		{
		// Check &until(protocol_name_list__elem__dataptr >= end_of_data)
		if ( t_protocol_name_list__elem__dataptr >= t_end_of_data )
			{
			protocol_name_list__elem_ = 0;
			goto end_of_protocol_name_list;
			}
		protocol_name_list__elem_ = new ProtocolName();
		int t_protocol_name_list__elem__size;
		t_protocol_name_list__elem__size = protocol_name_list__elem_->Parse(t_protocol_name_list__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		protocol_name_list_->push_back(protocol_name_list__elem_);
		t_protocol_name_list__elem__dataptr += t_protocol_name_list__elem__size;
		BINPAC_ASSERT(t_protocol_name_list__elem__dataptr <= t_end_of_data);
		protocol_name_list__elem_ = 0;
		}
end_of_protocol_name_list: ;
	t_protocol_name_list__size = t_protocol_name_list__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_apnl(rec(), protocol_name_list());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_ApplicationLayerProtocolNegotiationExtension__size) <= t_end_of_data);
	return t_ApplicationLayerProtocolNegotiationExtension__size;
	}

Handshake_Flow::Handshake_Flow(Handshake_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

Handshake_Flow::~Handshake_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void Handshake_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new HandshakePDU(is_orig());
				context_ = new ContextTLSHandshake(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
			if ( t_dataunit_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		flow_buffer_->DiscardData();
		throw;
		}
	}

void Handshake_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void Handshake_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
} // namespace TLSHandshake
}  // namespace binpac
