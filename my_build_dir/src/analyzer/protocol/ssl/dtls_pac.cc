// This file is automatically generated from /home/ubuntu/bro/src/analyzer/protocol/ssl/dtls.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/ubuntu/bro/my_build_dir/src/analyzer/protocol/ssl/dtls_pac.h"

namespace binpac {







namespace DTLS {
ContextDTLS::ContextDTLS(SSL_Conn * connection, DTLS_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextDTLS::~ContextDTLS()
	{
	}

SSL_Conn::SSL_Conn(DTLSAnalyzer const & bro_analyzer)
	{
	upflow_ = new DTLS_Flow(this, true);
	downflow_ = new DTLS_Flow(this, false);
	bro_analyzer_ = bro_analyzer;

		server_state_ = STATE_CLEAR;
		client_state_ = STATE_CLEAR;
		record_layer_version_ = UNKNOWN_VERSION;
	

		established_ = false;
	

		memset(&server, 0, sizeof(server));
		memset(&client, 0, sizeof(client));
	
	}

SSL_Conn::~SSL_Conn()
	{

	

		delete [] server.buffer;
		delete [] client.buffer;
	
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void SSL_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void SSL_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void SSL_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

int SSL_Conn::client_state()
	{
 return client_state_; 
	}

int SSL_Conn::server_state()
	{
 return client_state_; 
	}

int SSL_Conn::state(bool is_orig)
	{

		if ( is_orig )
			return client_state_;
		else
			return server_state_;
		
	}

bool SSL_Conn::startEncryption(bool is_orig)
	{

		if ( is_orig )
			client_state_ = STATE_ENCRYPTED;
		else
			server_state_ = STATE_ENCRYPTED;
		return true;
		
	}

uint16 SSL_Conn::dtls_version_ok(uint16 version)
	{

		switch ( version ) {
		case DTLSv10:
		case DTLSv12:
			return true;

		default:
			bro_analyzer()->ProtocolViolation(fmt("Invalid version in DTLS connection. Packet reported version: %d", version));			
			return false;
		}
		
	}

bool SSL_Conn::setEstablished()
	{

		established_ = true;
		return true;
		
	}

bool SSL_Conn::proc_alert(SSLRecord * rec, int level, int desc)
	{

		BifEvent::generate_ssl_alert(bro_analyzer(), bro_analyzer()->Conn(),
						rec->is_orig(), level, desc);
		return true;
		
	}

bool SSL_Conn::proc_unknown_record(SSLRecord * rec)
	{

		bro_analyzer()->ProtocolViolation(fmt("unknown SSL record type (%d) from %s",
				rec->content_type(),
				orig_label(rec->is_orig()).c_str()));
		return true;
		
	}

bool SSL_Conn::proc_ciphertext_record(SSLRecord * rec)
	{

		 if ( client_state_ == STATE_ENCRYPTED &&
		      server_state_ == STATE_ENCRYPTED &&
		      established_ == false )
			{
			established_ = true;
			BifEvent::generate_ssl_established(bro_analyzer(),
							bro_analyzer()->Conn());
			}

		BifEvent::generate_ssl_encrypted_data(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig(), rec->content_type(), rec->length());

		return true;
		
	}

bool SSL_Conn::proc_application_record(SSLRecord * rec)
	{

		BifEvent::generate_ssl_application_data(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig(), rec->length());

		return true;
		
	}

bool SSL_Conn::proc_heartbeat(SSLRecord * rec, uint8 type, uint16 payload_length, bytestring const & data)
	{

		BifEvent::generate_ssl_heartbeat(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig(), rec->length(), type, payload_length,
			new StringVal(data.length(), (const char*) data.data()));
		return true;
		
	}

bool SSL_Conn::proc_check_v2_server_hello_version(uint16 version)
	{

		if ( version != SSLv20 )
			{
			bro_analyzer()->ProtocolViolation(fmt("Invalid version in SSL server hello. Version: %d", version));
			bro_analyzer()->SetSkip(true);
			return false;
			}

		return true;
		
	}

bool SSL_Conn::proc_ccs(SSLRecord * rec)
	{

		BifEvent::generate_ssl_change_cipher_spec(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig());

		return true;
		
	}

bool SSL_Conn::proc_dtls(SSLRecord * pdu, uint64 sequence)
	{

		//fprintf(stderr, "Type: %d, sequence number: %d, epoch: %d\n", ${pdu.content_type}, sequence, ${pdu.epoch});

		return true;
		
	}

bool SSL_Conn::proc_handshake(SSLRecord * pdu, Handshake * rec)
	{

		uint32 foffset = to_int()(rec->fragment_offset());
		int64  flength = to_int()(rec->fragment_length());
		int64  length = to_int()(rec->length());
		uint64 sequence_number = to_int()(pdu->sequence_number());
		//fprintf(stderr, "Handshake type: %d, length: %u, seq: %u, foffset: %u, flength: %u\n", ${rec.msg_type}, to_int()(${rec.length}), ${rec.message_seq}, to_int()(${rec.fragment_offset}), to_int()(${rec.fragment_length}));

		if ( foffset == 0 && length == flength )
			{
			//fprintf(stderr, "Complete fragment, forwarding...\n");
			bro_analyzer()->SendHandshake(rec->msg_type(), length, rec->data().begin(), rec->data().end(), pdu->is_orig());
			return true;
			}

		// if we fall through here, the message has to be reassembled. Let's first get the right info record...
		message_info* i;
		if ( pdu->is_orig() )
			i = &client;
		else
			i = &server;

		if ( length > MAX_DTLS_HANDSHAKE_RECORD )
			{
			bro_analyzer()->ProtocolViolation(fmt("DTLS record length %" PRId64 " larger than allowed maximum.", length));
			return true;
			}

		if ( i->message_handshake_sequence != rec->message_seq() || i->message_length != length || i->buffer == 0 )
			{
			// cannot resume reassembling. Let's abandon the current data and try anew...
			delete [] i->buffer;
			memset(i, 0, sizeof(message_info));
			i->message_handshake_sequence = rec->message_seq();
			i->message_length = length;
			i->buffer = new u_char[length];
			// does not have to be the first sequence number - we cannot figure that out at this point. If it is not,
			// we will fix that later...
			i->message_first_sequence = sequence_number;
			}

		// if we arrive here, we are actually ready to resume.
		if ( i->message_first_sequence > sequence_number )
			{
			if ( i->first_sequence_seen )
				{
				bro_analyzer()->ProtocolViolation("Saw second and different first message fragment for handshake.");
				return true;
				}
			// first sequence number was incorrect, let's fix that.
			uint64 diff = i->message_first_sequence - sequence_number;
			i->message_sequence_seen = i->message_sequence_seen << diff;
			i->message_first_sequence = sequence_number;
			}

		// if we have offset 0, we know the smallest number...
		if ( foffset == 0 )
			i->first_sequence_seen = true;

		// check if we already saw the message
		if ( ( i->message_sequence_seen & ( 1 << (sequence_number - i->message_first_sequence) ) ) != 0 )
			return true; // do not handle same message fragment twice

		// copy data from fragment to buffer
		if ( rec->data().length() != flength )
			{
			bro_analyzer()->ProtocolViolation(fmt("DTLS handshake record length does not match packet length"));
			return true;
			}

		if ( foffset + flength > length )
			{
			bro_analyzer()->ProtocolViolation(fmt("DTLS handshake fragment trying to write past end of buffer"));
			return true;
			}

		// store that we handled fragment
		i->message_sequence_seen |= 1 << (sequence_number - i->message_first_sequence);
		memcpy(i->buffer + foffset, rec->data().data(), rec->data().length());

		//fprintf(stderr, "Copied to buffer offset %u length %u\n", foffset, ${rec.data}.length());

		// store last fragment information if this is the last fragment...

		// check if we saw all fragments so far. If yes, forward...
		if ( foffset + flength == length )
			i->message_last_sequence = sequence_number;

		if ( i->message_last_sequence != 0 && i->first_sequence_seen )
			{
			uint64 total_length = i->message_last_sequence - i->message_first_sequence;
			if ( total_length > 30 )
				{
				bro_analyzer()->ProtocolViolation(fmt("DTLS Message fragmented over more than 30 pieces. Cannot reassemble."));
				return true;
				}

			if ( ( ~(i->message_sequence_seen) & ( ( 1<<(total_length+1) ) -1 ) ) == 0 )
				{
				//fprintf(stderr, "ALl fragments here. Total length %u\n", length);
				bro_analyzer()->SendHandshake(rec->msg_type(), length, i->buffer, i->buffer + length, pdu->is_orig());
				}
			}


		return true;
		
	}

PlaintextRecord::PlaintextRecord(SSLRecord * rec)
	{
	val_case_index_ = -1;
	ch_cipher_ = 0;
	alert_ = 0;
	heartbeat_ = 0;
	app_data_ = 0;
	unknown_record_ = 0;
	handshake_ = 0;
	rec_ = rec;
	}

PlaintextRecord::~PlaintextRecord()
	{
	switch ( val_case_index() )
		{
		case 20:
			// Clean up "ch_cipher"
			{
			delete ch_cipher_;
			ch_cipher_ = 0;
			}
			break;
		case 21:
			// Clean up "alert"
			{
			delete alert_;
			alert_ = 0;
			}
			break;
		case 24:
			// Clean up "heartbeat"
			{
			delete heartbeat_;
			heartbeat_ = 0;
			}
			break;
		case 23:
			// Clean up "app_data"
			{
			delete app_data_;
			app_data_ = 0;
			}
			break;
		case 22:
			// Clean up "handshake"
			{
			delete handshake_;
			handshake_ = 0;
			}
			break;
		default:
			// Clean up "unknown_record"
			{
			delete unknown_record_;
			unknown_record_ = 0;
			}
			break;
		}
	}

int PlaintextRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = rec()->content_type();
	switch ( val_case_index() )
		{
		case 20:
			// Parse "ch_cipher"
			{
			ch_cipher_ = new ChangeCipherSpec(rec());
			ch_cipher_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 21:
			// Parse "alert"
			{
			alert_ = new Alert(rec());
			alert_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 2;
			}
			break;
		case 24:
			// Parse "heartbeat"
			{
			heartbeat_ = new Heartbeat(rec());
			int t_heartbeat__size;
			t_heartbeat__size = heartbeat_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_heartbeat__size;
			}
			break;
		case 23:
			// Parse "app_data"
			{
			app_data_ = new ApplicationData(rec());
			int t_app_data__size;
			t_app_data__size = app_data_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_app_data__size;
			}
			break;
		case 22:
			// Parse "handshake"
			{
			handshake_ = new Handshake(rec());
			int t_handshake__size;
			t_handshake__size = handshake_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_handshake__size;
			}
			break;
		default:
			// Parse "unknown_record"
			{
			unknown_record_ = new UnknownRecord(rec());
			int t_unknown_record__size;
			t_unknown_record__size = unknown_record_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown_record__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}


	string state_label(int state_nr)
		{
		switch ( state_nr ) {
		case STATE_CLEAR:
			return string("CLEAR");

		case STATE_ENCRYPTED:
			return string("ENCRYPTED");

		default:
			return string(fmt("UNKNOWN (%d)", state_nr));
		}
		}

ChangeCipherSpec::ChangeCipherSpec(SSLRecord * rec)
	{
	type_ = 0;
	rec_ = rec;
	state_changed_ = 0;
	proc_ = 0;
	}

ChangeCipherSpec::~ChangeCipherSpec()
	{
	}

int ChangeCipherSpec::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context)
	{
	// Checking out-of-bound for "ChangeCipherSpec"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ChangeCipherSpec",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 1;
	// Checking out-of-bound for "ChangeCipherSpec:type"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ChangeCipherSpec:type",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	state_changed_ = t_context->connection()->startEncryption(rec()->is_orig());
	proc_ = t_context->connection()->proc_ccs(rec());
	}
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

Alert::Alert(SSLRecord * rec)
	{
	level_ = 0;
	description_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Alert::~Alert()
	{
	}

int Alert::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context)
	{
	// Checking out-of-bound for "Alert"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Alert",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "level"
	level_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "description"
	description_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_alert(rec(), level(), description());
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

ApplicationData::ApplicationData(SSLRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

ApplicationData::~ApplicationData()
	{
	}

int ApplicationData::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/ssl-dtls-protocol.pac:69", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ApplicationData__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_ApplicationData__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_application_record(rec());
	BINPAC_ASSERT(t_begin_of_data + (t_ApplicationData__size) <= t_end_of_data);
	return t_ApplicationData__size;
	}

Heartbeat::Heartbeat(SSLRecord * rec)
	{
	type_ = 0;
	payload_length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Heartbeat::~Heartbeat()
	{
	data_.free();
	}

int Heartbeat::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "Heartbeat:payload_length"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data || (t_begin_of_data + 1) + (2) < (t_begin_of_data + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Heartbeat:payload_length",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "payload_length"
	payload_length_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 3));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/ssl-dtls-protocol.pac:79", t_data_string_length);
	data_.init((t_begin_of_data + 3), t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Heartbeat__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 3) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Heartbeat__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_heartbeat(rec(), type(), payload_length(), data());
	BINPAC_ASSERT(t_begin_of_data + (t_Heartbeat__size) <= t_end_of_data);
	return t_Heartbeat__size;
	}

UnknownRecord::UnknownRecord(SSLRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

UnknownRecord::~UnknownRecord()
	{
	}

int UnknownRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/ssl-dtls-protocol.pac:88", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_UnknownRecord__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_UnknownRecord__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_unknown_record(rec());
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownRecord__size) <= t_end_of_data);
	return t_UnknownRecord__size;
	}

CiphertextRecord::CiphertextRecord(SSLRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

CiphertextRecord::~CiphertextRecord()
	{
	}

int CiphertextRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/ssl-dtls-protocol.pac:92", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CiphertextRecord__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_CiphertextRecord__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ciphertext_record(rec());
	BINPAC_ASSERT(t_begin_of_data + (t_CiphertextRecord__size) <= t_end_of_data);
	return t_CiphertextRecord__size;
	}

DTLSPDU::DTLSPDU(bool is_orig)
	{
	records_ = 0;
	records__elem_ = 0;
	is_orig_ = is_orig;
	}

DTLSPDU::~DTLSPDU()
	{
	delete records__elem_;
	records__elem_ = 0;
	if ( records_ )
		{
		for ( int i = 0; i < (int) records_->size(); ++i )
			{
			SSLRecord * records__elem_ = (*records_)[i];
			delete records__elem_;
			records__elem_ = 0;
			}
		}
	delete records_;
	}

int DTLSPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context)
	{
	// Parse "records"
	int t_records__arraylength;
	t_records__arraylength = 0;
	records__elem_ = 0;
	int t_records__elem__it;
	t_records__elem__it = 0;
	int t_records__size;
	records_ = new vector<SSLRecord *>;
	const_byteptr t_records__elem__dataptr = t_begin_of_data;
	for (; /* forever */; ++t_records__elem__it)
		{
		// Check &until(records__elem__dataptr >= end_of_data)
		if ( t_records__elem__dataptr >= t_end_of_data )
			{
			records__elem_ = 0;
			goto end_of_records;
			}
		records__elem_ = new SSLRecord(is_orig());
		int t_records__elem__size;
		t_records__elem__size = records__elem_->Parse(t_records__elem__dataptr, t_end_of_data, t_context);
		// Evaluate 'let' and 'withinput' fields
		delete records__elem_;
		t_records__elem__dataptr += t_records__elem__size;
		BINPAC_ASSERT(t_records__elem__dataptr <= t_end_of_data);
		records__elem_ = 0;
		}
end_of_records: ;
	t_records__size = t_records__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DTLSPDU__size;
	const_byteptr const t_dataptr_after_records = t_begin_of_data + (t_records__size);
	BINPAC_ASSERT(t_dataptr_after_records <= t_end_of_data);
	t_DTLSPDU__size = t_dataptr_after_records - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DTLSPDU__size) <= t_end_of_data);
	return t_DTLSPDU__size;
	}

SSLRecord::SSLRecord(bool is_orig)
	{
	content_type_ = 0;
	version_ = 0;
	epoch_ = 0;
	sequence_number_ = 0;
	length_ = 0;
	cont_case_index_ = -1;
	rec_ = 0;
	rec__elem_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	valid_ = 0;
	proc_ = 0;
	}

SSLRecord::~SSLRecord()
	{
	delete sequence_number_;
	sequence_number_ = 0;
	switch ( cont_case_index() )
		{
		case 1:
			// Clean up "rec"
			{
			delete rec__elem_;
			rec__elem_ = 0;
			if ( rec() )
				{
				for ( int i = 0; i < (int) rec()->size(); ++i )
					{
					RecordText * rec__elem_ = (*rec_)[i];
					delete rec__elem_;
					rec__elem_ = 0;
					}
				}
			delete rec_;
			}
			break;
		case 0:
			// Clean up "swallow"
			{
			swallow_.free();
			}
			break;
		}
	}

int SSLRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context)
	{
	// Checking out-of-bound for "SSLRecord:length"
	if ( (t_begin_of_data + 11) + (2) > t_end_of_data || (t_begin_of_data + 11) + (2) < (t_begin_of_data + 11) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SSLRecord:length",
			(11) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "content_type"
	content_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "version"
	version_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "epoch"
	epoch_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "sequence_number"
	sequence_number_ = new uint48();
	sequence_number_->Parse((t_begin_of_data + 5), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cont"
	int t_cont__size;
	valid_ = t_context->connection()->dtls_version_ok(version());
	cont_case_index_ = valid();
	switch ( cont_case_index() )
		{
		case 1:
			// Parse "rec"
			{
			int t_rec__size;
			t_rec__size = length();
			// Checking out-of-bound for "SSLRecord:rec"
			if ( (t_begin_of_data + 13) + (t_rec__size) > t_end_of_data || (t_begin_of_data + 13) + (t_rec__size) < (t_begin_of_data + 13) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("SSLRecord:rec",
					(13) + (t_rec__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 13) + t_rec__size;
			int t_rec__arraylength;
			t_rec__arraylength = 0;
			rec__elem_ = 0;
			int t_rec__elem__it;
			t_rec__elem__it = 0;
			rec_ = new vector<RecordText *>;
			const_byteptr t_rec__elem__dataptr = (t_begin_of_data + 13);
			for (; /* forever */; ++t_rec__elem__it)
				{
				// Check &until(rec__elem__dataptr >= end_of_data)
				if ( t_rec__elem__dataptr >= t_end_of_data )
					{
					rec__elem_ = 0;
					goto end_of_rec;
					}
				rec__elem_ = new RecordText(this);
				int t_rec__elem__size;
				t_rec__elem__size = rec__elem_->Parse(t_rec__elem__dataptr, t_end_of_data, t_context, byteorder());
				// Evaluate 'let' and 'withinput' fields
				rec_->push_back(rec__elem_);
				t_rec__elem__dataptr += t_rec__elem__size;
				BINPAC_ASSERT(t_rec__elem__dataptr <= t_end_of_data);
				rec__elem_ = 0;
				}
		end_of_rec: ;
			// Evaluate 'let' and 'withinput' fields
			}
			t_cont__size = t_rec__size;
			}
			break;
		case 0:
			// Parse "swallow"
			{
			int t_swallow_string_length;
			t_swallow_string_length = (t_end_of_data) - ((t_begin_of_data + 13));
			int t_swallow__size;
			t_swallow__size = t_swallow_string_length;
			// check for negative sizes
			if ( t_swallow_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/dtls-protocol.pac:20", t_swallow_string_length);
			swallow_.init((t_begin_of_data + 13), t_swallow_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_cont__size = t_swallow__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SSLRecord", cont_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_SSLRecord__size;
	const_byteptr const t_dataptr_after_cont = (t_begin_of_data + 13) + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_SSLRecord__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_dtls(this, to_int()(sequence_number()));
	BINPAC_ASSERT(t_begin_of_data + (t_SSLRecord__size) <= t_end_of_data);
	return t_SSLRecord__size;
	}

RecordText::RecordText(SSLRecord * rec)
	{
	val_case_index_ = -1;
	plaintext_ = 0;
	ciphertext_ = 0;
	rec_ = rec;
	}

RecordText::~RecordText()
	{
	switch ( val_case_index() )
		{
		case 0:
			// Clean up "plaintext"
			{
			delete plaintext_;
			plaintext_ = 0;
			}
			break;
		default:
			// Clean up "ciphertext"
			{
			delete ciphertext_;
			ciphertext_ = 0;
			}
			break;
		}
	}

int RecordText::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = rec()->epoch();
	switch ( val_case_index() )
		{
		case 0:
			// Parse "plaintext"
			{
			plaintext_ = new PlaintextRecord(rec());
			int t_plaintext__size;
			t_plaintext__size = plaintext_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_plaintext__size;
			}
			break;
		default:
			// Parse "ciphertext"
			{
			ciphertext_ = new CiphertextRecord(rec());
			int t_ciphertext__size;
			t_ciphertext__size = ciphertext_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_ciphertext__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Handshake::Handshake(SSLRecord * rec)
	{
	msg_type_ = 0;
	length_ = 0;
	message_seq_ = 0;
	fragment_offset_ = 0;
	fragment_length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Handshake::~Handshake()
	{
	delete length_;
	length_ = 0;
	delete fragment_offset_;
	fragment_offset_ = 0;
	delete fragment_length_;
	fragment_length_ = 0;
	data_.free();
	}

int Handshake::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDTLS * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "Handshake:fragment_length"
	if ( (t_begin_of_data + 9) + (3) > t_end_of_data || (t_begin_of_data + 9) + (3) < (t_begin_of_data + 9) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake:fragment_length",
			(9) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "msg_type"
	msg_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = new uint24();
	length_->Parse((t_begin_of_data + 1), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "message_seq"
	message_seq_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fragment_offset"
	fragment_offset_ = new uint24();
	fragment_offset_->Parse((t_begin_of_data + 6), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fragment_length"
	fragment_length_ = new uint24();
	fragment_length_->Parse((t_begin_of_data + 9), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 12));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ssl/dtls-protocol.pac:42", t_data_string_length);
	data_.init((t_begin_of_data + 12), t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Handshake__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 12) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Handshake__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_handshake(rec(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_Handshake__size) <= t_end_of_data);
	return t_Handshake__size;
	}

DTLS_Flow::DTLS_Flow(SSL_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

DTLS_Flow::~DTLS_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void DTLS_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new DTLSPDU(is_orig());
		context_ = new ContextDTLS(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void DTLS_Flow::NewGap(int gap_length)
	{
	}
void DTLS_Flow::FlowEOF()
	{
	}
uint24::uint24()
	{
	byte1_ = 0;
	byte2_ = 0;
	byte3_ = 0;
	}

uint24::~uint24()
	{
	}

int uint24::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "uint24"
	if ( t_begin_of_data + (3) > t_end_of_data || t_begin_of_data + (3) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("uint24",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte1"
	byte1_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte2"
	byte2_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte3"
	byte3_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

uint48::uint48()
	{
	byte1_ = 0;
	byte2_ = 0;
	byte3_ = 0;
	byte4_ = 0;
	byte5_ = 0;
	byte6_ = 0;
	}

uint48::~uint48()
	{
	}

int uint48::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "uint48"
	if ( t_begin_of_data + (6) > t_end_of_data || t_begin_of_data + (6) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("uint48",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte1"
	byte1_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte2"
	byte2_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte3"
	byte3_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte4"
	byte4_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte5"
	byte5_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte6"
	byte6_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}


string orig_label(bool is_orig)
		{
		return string(is_orig ? "originator" :"responder");
		}

StringVal * to_string_val(vector<uint8> * data)
	{

	char tmp[32];
	memset(tmp, 0, sizeof(tmp));

	// Just return an empty string if the string is longer than 32 bytes
	if ( data && data->size() <= 32 )
		{
		for ( unsigned int i = data->size(); i > 0; --i )
			tmp[i-1] = (*data)[i-1];
		}

	return new StringVal(32, tmp);
	
	}

bool version_ok(uint16 vers)
	{

	if ( vers >> 8 == 0x7F ) // 1.3 draft
		return true;

	switch ( vers ) {
	case SSLv20:
	case SSLv30:
	case TLSv10:
	case TLSv11:
	case TLSv12:
	case TLSv13:
	case DTLSv10:
	case DTLSv12:
		return true;

	default:
		return false;
	}
	
	}

uint32 const MAX_DTLS_HANDSHAKE_RECORD = 100000;
} // namespace DTLS
}  // namespace binpac
