// This file was automatically generated by bifcl from /home/ubuntu/bro/src/analyzer/protocol/socks/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr socks_request; 
void BifEvent::generate_socks_request(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t version, bro_uint_t request_type, Val* sa, PortVal* p, StringVal* user)
	{
	// Note that it is intentional that here we do not
	// check if ::socks_request is NULL, which should happen *before*
	// BifEvent::generate_socks_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(version, TYPE_COUNT));
	vl->append(new Val(request_type, TYPE_COUNT));
	vl->append(sa);
	vl->append(p);
	vl->append(user);

	mgr.QueueEvent(::socks_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr socks_reply; 
void BifEvent::generate_socks_reply(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t version, bro_uint_t reply, Val* sa, PortVal* p)
	{
	// Note that it is intentional that here we do not
	// check if ::socks_reply is NULL, which should happen *before*
	// BifEvent::generate_socks_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(version, TYPE_COUNT));
	vl->append(new Val(reply, TYPE_COUNT));
	vl->append(sa);
	vl->append(p);

	mgr.QueueEvent(::socks_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr socks_login_userpass_request; 
void BifEvent::generate_socks_login_userpass_request(analyzer::Analyzer* analyzer, Connection* c, StringVal* user, StringVal* password)
	{
	// Note that it is intentional that here we do not
	// check if ::socks_login_userpass_request is NULL, which should happen *before*
	// BifEvent::generate_socks_login_userpass_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(user);
	vl->append(password);

	mgr.QueueEvent(::socks_login_userpass_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr socks_login_userpass_reply; 
void BifEvent::generate_socks_login_userpass_reply(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t code)
	{
	// Note that it is intentional that here we do not
	// check if ::socks_login_userpass_reply is NULL, which should happen *before*
	// BifEvent::generate_socks_login_userpass_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(code, TYPE_COUNT));

	mgr.QueueEvent(::socks_login_userpass_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
