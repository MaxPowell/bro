// This file is automatically generated from /home/ubuntu/bro/src/analyzer/protocol/sip/sip.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/ubuntu/bro/my_build_dir/src/analyzer/protocol/sip/sip_pac.h"

namespace binpac {







namespace SIP {
ContextSIP::ContextSIP(SIP_Conn * connection, SIP_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextSIP::~ContextSIP()
	{
	}

SIP_Conn::SIP_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new SIP_Flow(this, true);
	downflow_ = new SIP_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

SIP_Conn::~SIP_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void SIP_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void SIP_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void SIP_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

RegExMatcher SIP_TOKEN_re_001("[^()<>@,;:\\\"/\\[\\]?={} \\t]+");

RegExMatcher SIP_WS_re_002("[ \\t]*");

RegExMatcher SIP_URI_re_003("[[:alnum:]@[:punct:]]+");

SIP_PDU::SIP_PDU(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = 0;
	reply_ = 0;
	is_orig_ = is_orig;
	proc_ = 0;
	}

SIP_PDU::~SIP_PDU()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "reply"
			{
			delete reply_;
			reply_ = 0;
			}
			break;
		}
	}

bool SIP_PDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSIP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request"
			{
			if ( ! request_ )
				{
				request_ = new SIP_Request();
				}
			bool t_request_parsing_complete;
			t_request_parsing_complete = false;
			t_request_parsing_complete = request_->ParseBuffer(t_flow_buffer, t_context);
			if ( t_request_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			t_val_parsing_complete = t_request_parsing_complete;
			}
			break;
		case 0:
			// Parse "reply"
			{
			if ( ! reply_ )
				{
				reply_ = new SIP_Reply();
				}
			bool t_reply_parsing_complete;
			t_reply_parsing_complete = false;
			t_reply_parsing_complete = reply_->ParseBuffer(t_flow_buffer, t_context);
			if ( t_reply_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			t_val_parsing_complete = t_reply_parsing_complete;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SIP_PDU", val_case_index());
			break;
		}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		proc_ = t_context->flow()->proc_sip_message_done(this);
		}
	return t_val_parsing_complete;
	}

SIP_Request::SIP_Request()
	{
	request_ = 0;
	buffering_state_ = 0;
	buffering_state_ = 0;
	msg_ = 0;
	parsing_state_ = 0;
	parsing_state_ = 0;
	}

SIP_Request::~SIP_Request()
	{
	delete request_;
	request_ = 0;
	delete msg_;
	msg_ = 0;
	}

bool SIP_Request::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSIP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "request"
		if ( ! request_ )
			{
			request_ = new SIP_RequestLine();
			}
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->UnsetLineBreaker();
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		parsing_state_ = 1;
		/* fall through */
	case 1:
		{
		bool t_request_parsing_complete;
		t_request_parsing_complete = false;
		while ( ! t_request_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			t_request_parsing_complete = request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			if ( t_request_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! (t_request_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "msg"
		if ( ! msg_ )
			{
			msg_ = new SIP_Message();
			}
		parsing_state_ = 2;
		/* fall through */
	case 2:
		{
		bool t_msg_parsing_complete;
		t_msg_parsing_complete = false;
		t_msg_parsing_complete = msg_->ParseBuffer(t_flow_buffer, t_context);
		if ( t_msg_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_msg_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

SIP_Reply::SIP_Reply()
	{
	reply_ = 0;
	buffering_state_ = 0;
	buffering_state_ = 0;
	msg_ = 0;
	parsing_state_ = 0;
	parsing_state_ = 0;
	}

SIP_Reply::~SIP_Reply()
	{
	delete reply_;
	reply_ = 0;
	delete msg_;
	msg_ = 0;
	}

bool SIP_Reply::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSIP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "reply"
		if ( ! reply_ )
			{
			reply_ = new SIP_ReplyLine();
			}
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->UnsetLineBreaker();
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		parsing_state_ = 1;
		/* fall through */
	case 1:
		{
		bool t_reply_parsing_complete;
		t_reply_parsing_complete = false;
		while ( ! t_reply_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			t_reply_parsing_complete = reply_->Parse(t_begin_of_data, t_end_of_data, t_context);
			if ( t_reply_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! (t_reply_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "msg"
		if ( ! msg_ )
			{
			msg_ = new SIP_Message();
			}
		parsing_state_ = 2;
		/* fall through */
	case 2:
		{
		bool t_msg_parsing_complete;
		t_msg_parsing_complete = false;
		t_msg_parsing_complete = msg_->ParseBuffer(t_flow_buffer, t_context);
		if ( t_msg_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_msg_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

SIP_RequestLine::SIP_RequestLine()
	{
	version_ = 0;
	proc_ = 0;
	}

SIP_RequestLine::~SIP_RequestLine()
	{
	method_.free();
	uri_.free();
	delete version_;
	version_ = 0;
	}

int SIP_RequestLine::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSIP * t_context)
	{
	// Parse "method"
	int t_method_string_length;
	t_method_string_length = 
		SIP_TOKEN_re_001.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_method_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:21", "[^()<>@,;:\\\"/\\[\\]?={} \\t]+", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_method__size;
	t_method__size = t_method_string_length;
	// check for negative sizes
	if ( t_method_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:21", t_method_string_length);
	method_.init(t_begin_of_data, t_method_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_method = t_begin_of_data + (t_method__size);
	BINPAC_ASSERT(t_dataptr_after_method <= t_end_of_data);
	// Parse "anonymous_field_004"
	bytestring anonymous_field_004_;
	int t_anonymous_field_004_string_length;
	t_anonymous_field_004_string_length = 
		SIP_WS_re_002.MatchPrefix(
			t_dataptr_after_method,
			t_end_of_data - t_dataptr_after_method);
	if ( t_anonymous_field_004_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:22", "[ \\t]*", string((const char *) (t_dataptr_after_method), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_004__size;
	t_anonymous_field_004__size = t_anonymous_field_004_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_004_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_004 = t_dataptr_after_method + (t_anonymous_field_004__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_004 <= t_end_of_data);
	// Parse "uri"
	int t_uri_string_length;
	t_uri_string_length = 
		SIP_URI_re_003.MatchPrefix(
			t_dataptr_after_anonymous_field_004,
			t_end_of_data - t_dataptr_after_anonymous_field_004);
	if ( t_uri_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:23", "[[:alnum:]@[:punct:]]+", string((const char *) (t_dataptr_after_anonymous_field_004), (const char *) t_end_of_data).c_str());
		}
	int t_uri__size;
	t_uri__size = t_uri_string_length;
	// check for negative sizes
	if ( t_uri_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:23", t_uri_string_length);
	uri_.init(t_dataptr_after_anonymous_field_004, t_uri_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_uri = t_dataptr_after_anonymous_field_004 + (t_uri__size);
	BINPAC_ASSERT(t_dataptr_after_uri <= t_end_of_data);
	// Parse "anonymous_field_005"
	bytestring anonymous_field_005_;
	int t_anonymous_field_005_string_length;
	t_anonymous_field_005_string_length = 
		SIP_WS_re_002.MatchPrefix(
			t_dataptr_after_uri,
			t_end_of_data - t_dataptr_after_uri);
	if ( t_anonymous_field_005_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:24", "[ \\t]*", string((const char *) (t_dataptr_after_uri), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_005__size;
	t_anonymous_field_005__size = t_anonymous_field_005_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_005_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_005 = t_dataptr_after_uri + (t_anonymous_field_005__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_005 <= t_end_of_data);
	// Parse "version"
	version_ = new SIP_Version();
	int t_version__size;
	t_version__size = version_->Parse(t_dataptr_after_anonymous_field_005, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SIP_RequestLine__size;
	const_byteptr const t_dataptr_after_version = t_dataptr_after_anonymous_field_005 + (t_version__size);
	BINPAC_ASSERT(t_dataptr_after_version <= t_end_of_data);
	t_SIP_RequestLine__size = t_dataptr_after_version - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_sip_request(method(), uri(), version());
	BINPAC_ASSERT(t_begin_of_data + (t_SIP_RequestLine__size) <= t_end_of_data);
	return t_SIP_RequestLine__size;
	}

SIP_ReplyLine::SIP_ReplyLine()
	{
	version_ = 0;
	status_ = 0;
	proc_ = 0;
	}

SIP_ReplyLine::~SIP_ReplyLine()
	{
	delete version_;
	version_ = 0;
	delete status_;
	status_ = 0;
	reason_.free();
	}

int SIP_ReplyLine::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSIP * t_context)
	{
	// Parse "version"
	version_ = new SIP_Version();
	int t_version__size;
	t_version__size = version_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_version = t_begin_of_data + (t_version__size);
	BINPAC_ASSERT(t_dataptr_after_version <= t_end_of_data);
	// Parse "anonymous_field_006"
	bytestring anonymous_field_006_;
	int t_anonymous_field_006_string_length;
	t_anonymous_field_006_string_length = 
		SIP_WS_re_002.MatchPrefix(
			t_dataptr_after_version,
			t_end_of_data - t_dataptr_after_version);
	if ( t_anonymous_field_006_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:30", "[ \\t]*", string((const char *) (t_dataptr_after_version), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_006__size;
	t_anonymous_field_006__size = t_anonymous_field_006_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_006_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_006 = t_dataptr_after_version + (t_anonymous_field_006__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_006 <= t_end_of_data);
	// Parse "status"
	status_ = new SIP_Status();
	int t_status__size;
	t_status__size = status_->Parse(t_dataptr_after_anonymous_field_006, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_status = t_dataptr_after_anonymous_field_006 + (t_status__size);
	BINPAC_ASSERT(t_dataptr_after_status <= t_end_of_data);
	// Parse "anonymous_field_007"
	bytestring anonymous_field_007_;
	int t_anonymous_field_007_string_length;
	t_anonymous_field_007_string_length = 
		SIP_WS_re_002.MatchPrefix(
			t_dataptr_after_status,
			t_end_of_data - t_dataptr_after_status);
	if ( t_anonymous_field_007_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:32", "[ \\t]*", string((const char *) (t_dataptr_after_status), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_007__size;
	t_anonymous_field_007__size = t_anonymous_field_007_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_007_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_007 = t_dataptr_after_status + (t_anonymous_field_007__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_007 <= t_end_of_data);
	// Parse "reason"
	int t_reason_string_length;
	t_reason_string_length = (t_end_of_data) - (t_dataptr_after_anonymous_field_007);
	int t_reason__size;
	t_reason__size = t_reason_string_length;
	// check for negative sizes
	if ( t_reason_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:33", t_reason_string_length);
	reason_.init(t_dataptr_after_anonymous_field_007, t_reason_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SIP_ReplyLine__size;
	const_byteptr const t_dataptr_after_reason = t_dataptr_after_anonymous_field_007 + (t_reason__size);
	BINPAC_ASSERT(t_dataptr_after_reason <= t_end_of_data);
	t_SIP_ReplyLine__size = t_dataptr_after_reason - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_sip_reply(version(), status()->stat_num(), reason());
	BINPAC_ASSERT(t_begin_of_data + (t_SIP_ReplyLine__size) <= t_end_of_data);
	return t_SIP_ReplyLine__size;
	}

RegExMatcher SIP_Status_re_008("[0-9]{3}");

SIP_Status::SIP_Status()
	{
	stat_num_ = 0;
	}

SIP_Status::~SIP_Status()
	{
	stat_str_.free();
	}

int SIP_Status::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "stat_str"
	int t_stat_str_string_length;
	t_stat_str_string_length = 
		SIP_Status_re_008.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_stat_str_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:37", "[0-9]{3}", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_stat_str__size;
	t_stat_str__size = t_stat_str_string_length;
	// check for negative sizes
	if ( t_stat_str_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:37", t_stat_str_string_length);
	stat_str_.init(t_begin_of_data, t_stat_str_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SIP_Status__size;
	const_byteptr const t_dataptr_after_stat_str = t_begin_of_data + (t_stat_str__size);
	BINPAC_ASSERT(t_dataptr_after_stat_str <= t_end_of_data);
	t_SIP_Status__size = t_dataptr_after_stat_str - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	stat_num_ = bytestring_to_int(stat_str(), 10);
	BINPAC_ASSERT(t_begin_of_data + (t_SIP_Status__size) <= t_end_of_data);
	return t_SIP_Status__size;
	}

RegExMatcher SIP_Version_re_010("[0-9]+\\.[0-9]+");

SIP_Version::SIP_Version()
	{
	vers_num_ = 0;
	}

SIP_Version::~SIP_Version()
	{
	vers_str_.free();
	}

int SIP_Version::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SIP_Version:anonymous_field_009"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SIP_Version:anonymous_field_009",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "anonymous_field_009"
	bytestring anonymous_field_009_;
	if ( memcmp(t_begin_of_data, "SIP/", 4) != 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:43", "SIP/", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_009_.free();
	
	// Parse "vers_str"
	int t_vers_str_string_length;
	t_vers_str_string_length = 
		SIP_Version_re_010.MatchPrefix(
			(t_begin_of_data + 4),
			t_end_of_data - (t_begin_of_data + 4));
	if ( t_vers_str_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:44", "[0-9]+\\.[0-9]+", string((const char *) ((t_begin_of_data + 4)), (const char *) t_end_of_data).c_str());
		}
	int t_vers_str__size;
	t_vers_str__size = t_vers_str_string_length;
	// check for negative sizes
	if ( t_vers_str_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:44", t_vers_str_string_length);
	vers_str_.init((t_begin_of_data + 4), t_vers_str_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SIP_Version__size;
	const_byteptr const t_dataptr_after_vers_str = (t_begin_of_data + 4) + (t_vers_str__size);
	BINPAC_ASSERT(t_dataptr_after_vers_str <= t_end_of_data);
	t_SIP_Version__size = t_dataptr_after_vers_str - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	vers_num_ = bytestring_to_double(vers_str());
	BINPAC_ASSERT(t_begin_of_data + (t_SIP_Version__size) <= t_end_of_data);
	return t_SIP_Version__size;
	}

SIP_Headers::SIP_Headers()
	{
	val_ = 0;
	val__elem_ = 0;
	buffering_state_ = 0;
	buffering_state_ = 0;
	val__arraylength_ = 0;
	val__elem__it_ = 0;
	proc_ = 0;
	val__elem__it_ = -1;
	}

SIP_Headers::~SIP_Headers()
	{
	delete val__elem_;
	val__elem_ = 0;
	if ( val() )
		{
		for ( int i = 0; i < (int) val()->size(); ++i )
			{
			SIP_Header * val__elem_ = (*val_)[i];
			delete val__elem_;
			val__elem_ = 0;
			}
		}
	delete val_;
	}

bool SIP_Headers::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSIP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	if ( val__elem__it_ < 0 )
		{
		// Initialize only once
		val__elem__it_ = 0;
		val_ = new vector<SIP_Header *>;
		}
	for (; /* forever */; ++val__elem__it_)
		{
		if ( ! val__elem_ )
			{
			val__elem_ = new SIP_Header();
			}
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->UnsetLineBreaker();
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		bool t_val__elem_parsing_complete;
		t_val__elem_parsing_complete = false;
		while ( ! t_val__elem_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			const_bytestring t_val__elem_input(t_begin_of_data, t_end_of_data);
			// Check &until( ( @$input->length@() == ((int) 0) ) )
			if (  ( t_val__elem_input.length() == 0 )  )
				{
				t_val_parsing_complete = true;
				delete val__elem_;
				val__elem_ = 0;
				goto end_of_val;
				}
			t_val__elem_parsing_complete = val__elem_->ParseBuffer(t_flow_buffer, t_context);
			if ( t_val__elem_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! t_val__elem_parsing_complete )
			goto need_more_data;
		val_->push_back(val__elem_);
		val__elem_ = 0;
		}
end_of_val: ;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		proc_ = t_context->flow()->proc_sip_end_of_headers(this);
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

SIP_Message::SIP_Message()
	{
	headers_ = 0;
	body_ = 0;
	parsing_state_ = 0;
	parsing_state_ = 0;
	}

SIP_Message::~SIP_Message()
	{
	delete headers_;
	headers_ = 0;
	delete body_;
	body_ = 0;
	}

bool SIP_Message::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSIP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "headers"
		if ( ! headers_ )
			{
			headers_ = new SIP_Headers();
			}
		parsing_state_ = 1;
		/* fall through */
	case 1:
		{
		bool t_headers_parsing_complete;
		t_headers_parsing_complete = false;
		t_headers_parsing_complete = headers_->ParseBuffer(t_flow_buffer, t_context);
		if ( t_headers_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_headers_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "body"
		if ( ! body_ )
			{
			body_ = new SIP_Body();
			}
		parsing_state_ = 2;
		/* fall through */
	case 2:
		{
		bool t_body_parsing_complete;
		t_body_parsing_complete = false;
		t_body_parsing_complete = body_->ParseBuffer(t_flow_buffer, t_context);
		if ( t_body_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_body_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

RegExMatcher SIP_HEADER_NAME_re_011("[^: \\t]+");

SIP_Header::SIP_Header()
	{
	proc_ = 0;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

SIP_Header::~SIP_Header()
	{
	name_.free();
	value_.free();
	}

bool SIP_Header::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSIP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	// Parse "name"
	int t_name_string_length;
	t_name_string_length = 
		SIP_HEADER_NAME_re_011.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_name_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:58", "[^: \\t]+", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_name__size;
	t_name__size = t_name_string_length;
	// check for negative sizes
	if ( t_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:58", t_name_string_length);
	name_.init(t_begin_of_data, t_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_name = t_begin_of_data + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	// Parse "anonymous_field_012"
	bytestring anonymous_field_012_;
	int t_anonymous_field_012_string_length;
	t_anonymous_field_012_string_length = 
		SIP_WS_re_002.MatchPrefix(
			t_dataptr_after_name,
			t_end_of_data - t_dataptr_after_name);
	if ( t_anonymous_field_012_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:59", "[ \\t]*", string((const char *) (t_dataptr_after_name), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_012__size;
	t_anonymous_field_012__size = t_anonymous_field_012_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_012_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_012 = t_dataptr_after_name + (t_anonymous_field_012__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_012 <= t_end_of_data);
	// Checking out-of-bound for "SIP_Header:anonymous_field_013"
	if ( t_dataptr_after_anonymous_field_012 + (1) > t_end_of_data || t_dataptr_after_anonymous_field_012 + (1) < t_dataptr_after_anonymous_field_012 )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SIP_Header:anonymous_field_013",
			((t_dataptr_after_anonymous_field_012 - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "anonymous_field_013"
	bytestring anonymous_field_013_;
	if ( memcmp(t_dataptr_after_anonymous_field_012, ":", 1) != 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:60", ":", string((const char *) (t_dataptr_after_anonymous_field_012), (const char *) t_end_of_data).c_str());
		}
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_013_.free();
	
	// Parse "anonymous_field_014"
	bytestring anonymous_field_014_;
	int t_anonymous_field_014_string_length;
	t_anonymous_field_014_string_length = 
		SIP_WS_re_002.MatchPrefix(
			(t_dataptr_after_anonymous_field_012 + 1),
			t_end_of_data - (t_dataptr_after_anonymous_field_012 + 1));
	if ( t_anonymous_field_014_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:61", "[ \\t]*", string((const char *) ((t_dataptr_after_anonymous_field_012 + 1)), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_014__size;
	t_anonymous_field_014__size = t_anonymous_field_014_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_014_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_014 = (t_dataptr_after_anonymous_field_012 + 1) + (t_anonymous_field_014__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_014 <= t_end_of_data);
	// Parse "value"
	int t_value_string_length;
	t_value_string_length = (t_end_of_data) - (t_dataptr_after_anonymous_field_014);
	int t_value__size;
	t_value__size = t_value_string_length;
	// check for negative sizes
	if ( t_value_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:62", t_value_string_length);
	value_.init(t_dataptr_after_anonymous_field_014, t_value_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	t_val_parsing_complete = true;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		proc_ = t_context->flow()->proc_sip_header(name(), value());
		}
	buffering_state_ = 0;
	return t_val_parsing_complete;
	}

SIP_Body::SIP_Body()
	{
	buffering_state_ = 0;
	buffering_state_ = 0;
	parsing_state_ = 0;
	parsing_state_ = 0;
	}

SIP_Body::~SIP_Body()
	{
	body_.free();
	}

bool SIP_Body::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSIP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "body"
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->NewFrame(0, false);
			buffering_state_ = 1;
			}
		parsing_state_ = 1;
		/* fall through */
	case 1:
		{
		bool t_body_parsing_complete;
		t_body_parsing_complete = false;
		while ( ! t_body_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			switch ( buffering_state_ )
				{
				case 0:
					if ( buffering_state_ == 0 )
						{
						t_flow_buffer->NewFrame(0, false);
						buffering_state_ = 1;
						}
					buffering_state_ = 1;
					break;
				case 1:
					{
					buffering_state_ = 2;
					t_flow_buffer->GrowFrame(t_context->flow()->get_content_length());
					}
					break;
				case 2:
					BINPAC_ASSERT(t_flow_buffer->ready());
					if ( t_flow_buffer->ready() )
						{
						int t_body_string_length;
						t_body_string_length = t_context->flow()->get_content_length();
						// check for negative sizes
						if ( t_body_string_length < 0 )
						throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/sip/sip-protocol.pac:66", t_body_string_length);
						body_.init(t_begin_of_data, t_body_string_length);
						t_body_parsing_complete = true;
						if ( t_body_parsing_complete )
							{
							// Evaluate 'let' and 'withinput' fields
							}
						BINPAC_ASSERT(t_body_parsing_complete);
						buffering_state_ = 0;
						}
					break;
				default:
					BINPAC_ASSERT(buffering_state_ <= 2);
					break;
				}
			}
		if ( ! (t_body_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

SIP_Flow::SIP_Flow(SIP_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;

		content_length = 0;
		build_headers = bool(sip_all_headers);
	
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

SIP_Flow::~SIP_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void SIP_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new SIP_PDU(is_orig());
				context_ = new ContextSIP(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
			if ( t_dataunit_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		flow_buffer_->DiscardData();
		throw;
		}
	}

void SIP_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void SIP_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
int SIP_Flow::get_content_length()
	{

		return content_length;
		
	}

bool SIP_Flow::proc_sip_request(bytestring const & method, bytestring const & uri, SIP_Version * vers)
	{

		if ( sip_request )
			{
			BifEvent::generate_sip_request(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
						       bytestring_to_val(method), bytestring_to_val(uri),
						       bytestring_to_val(vers->vers_str()));
			}

		proc_sip_message_begin();

		return true;
		
	}

bool SIP_Flow::proc_sip_reply(SIP_Version * vers, int code, bytestring const & reason)
	{

		connection()->bro_analyzer()->ProtocolConfirmation();
		if ( sip_reply )
			{
			BifEvent::generate_sip_reply(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
						     bytestring_to_val(vers->vers_str()), code, bytestring_to_val(reason));
			}

		proc_sip_message_begin();

		return true;
		
	}

bool SIP_Flow::proc_sip_header(bytestring const & name, bytestring const & value)
	{

		if ( name == "Content-Length" || name == "L" )
			content_length = bytestring_to_int(value, 10);

		if ( sip_header )
			{
			BifEvent::generate_sip_header(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
						      is_orig(), bytestring_to_val(name)->ToUpper(), bytestring_to_val(value));
			}

		if ( build_headers )
			{
			headers.push_back(build_sip_header_val(name, value));
			}

		return true;
		
	}

BroVal SIP_Flow::build_sip_headers_val()
	{

		TableVal* t = new TableVal(mime_header_list);

		for ( unsigned int i = 0; i < headers.size(); ++i )
			{ // index starting from 1
			Val* index = new Val(i + 1, TYPE_COUNT);
			t->Assign(index, headers[i]);
			Unref(index);
			}

		return t;
		
	}

void SIP_Flow::gen_sip_all_headers()
	{

		if ( sip_all_headers )
			{
			BifEvent::generate_sip_all_headers(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
							   is_orig(), build_sip_headers_val());
			}

		headers.clear();
		
	}

bool SIP_Flow::proc_sip_end_of_headers(SIP_Headers * headers)
	{

		if ( build_headers )
			{
			gen_sip_all_headers();
			}

		return true;
		
	}

BroVal SIP_Flow::build_sip_header_val(const_bytestring const & name, const_bytestring const & value)
	{

		RecordVal* header_record = new RecordVal(mime_header_rec);

		StringVal* name_val = 0;
		if ( name.length() > 0 )
			{
			// Make it all uppercase.
			name_val = new StringVal(name.length(), (const char*) name.begin());
			name_val->ToUpper();
			}
		else
			{
			name_val = new StringVal("");
			}

		header_record->Assign(0, name_val);
		header_record->Assign(1, bytestring_to_val(value));

		return header_record;
		
	}

void SIP_Flow::proc_sip_message_begin()
	{

		if ( sip_begin_entity )
			{
			BifEvent::generate_sip_begin_entity(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), is_orig());
			}
		
	}

bool SIP_Flow::proc_sip_message_done(SIP_PDU * pdu)
	{

		if ( sip_end_entity )
			{
			BifEvent::generate_sip_end_entity(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), is_orig());
			}

		return true;
		
	}

} // namespace SIP
}  // namespace binpac
