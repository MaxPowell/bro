// This file was automatically generated by bifcl from /home/ubuntu/bro/src/analyzer/protocol/krb/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr krb_as_request; 
void BifEvent::generate_krb_as_request(analyzer::Analyzer* analyzer, Connection* c, Val* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_as_request is NULL, which should happen *before*
	// BifEvent::generate_krb_as_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);

	mgr.QueueEvent(::krb_as_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_as_response; 
void BifEvent::generate_krb_as_response(analyzer::Analyzer* analyzer, Connection* c, Val* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_as_response is NULL, which should happen *before*
	// BifEvent::generate_krb_as_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);

	mgr.QueueEvent(::krb_as_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_tgs_request; 
void BifEvent::generate_krb_tgs_request(analyzer::Analyzer* analyzer, Connection* c, Val* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_tgs_request is NULL, which should happen *before*
	// BifEvent::generate_krb_tgs_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);

	mgr.QueueEvent(::krb_tgs_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_tgs_response; 
void BifEvent::generate_krb_tgs_response(analyzer::Analyzer* analyzer, Connection* c, Val* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_tgs_response is NULL, which should happen *before*
	// BifEvent::generate_krb_tgs_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);

	mgr.QueueEvent(::krb_tgs_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_ap_request; 
void BifEvent::generate_krb_ap_request(analyzer::Analyzer* analyzer, Connection* c, Val* ticket, Val* opts)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_ap_request is NULL, which should happen *before*
	// BifEvent::generate_krb_ap_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(ticket);
	vl->append(opts);

	mgr.QueueEvent(::krb_ap_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_ap_response; 
void BifEvent::generate_krb_ap_response(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_ap_response is NULL, which should happen *before*
	// BifEvent::generate_krb_ap_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::krb_ap_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_priv; 
void BifEvent::generate_krb_priv(analyzer::Analyzer* analyzer, Connection* c, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_priv is NULL, which should happen *before*
	// BifEvent::generate_krb_priv is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::krb_priv, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_safe; 
void BifEvent::generate_krb_safe(analyzer::Analyzer* analyzer, Connection* c, int is_orig, Val* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_safe is NULL, which should happen *before*
	// BifEvent::generate_krb_safe is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(msg);

	mgr.QueueEvent(::krb_safe, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_cred; 
void BifEvent::generate_krb_cred(analyzer::Analyzer* analyzer, Connection* c, int is_orig, Val* tickets)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_cred is NULL, which should happen *before*
	// BifEvent::generate_krb_cred is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(tickets);

	mgr.QueueEvent(::krb_cred, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr krb_error; 
void BifEvent::generate_krb_error(analyzer::Analyzer* analyzer, Connection* c, Val* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::krb_error is NULL, which should happen *before*
	// BifEvent::generate_krb_error is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);

	mgr.QueueEvent(::krb_error, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
