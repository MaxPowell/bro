// This file is automatically generated from /home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/ubuntu/bro/my_build_dir/src/analyzer/protocol/ntlm/ntlm_pac.h"

namespace binpac {







namespace NTLM {
ContextNTLM::ContextNTLM(NTLM_Conn * connection, NTLM_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextNTLM::~ContextNTLM()
	{
	}

NTLM_Conn::NTLM_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new NTLM_Flow(this, true);
	downflow_ = new NTLM_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

NTLM_Conn::~NTLM_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void NTLM_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void NTLM_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void NTLM_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

Val * NTLM_Conn::filetime2brotime(uint64 ts)
	{

		double secs = (ts / 10000000.0);

		// Bro can't support times back to the 1600's
		// so we subtract a lot of seconds.
		Val* bro_ts = new Val(secs - 11644473600.0, TYPE_TIME);

		return bro_ts;
		
	}

BroVal NTLM_Conn::build_version_record(NTLM_Version * val)
	{

		RecordVal* result = new RecordVal(BifType::Record::NTLM::Version);
		result->Assign(0, new Val(val->major_version(), TYPE_COUNT));
		result->Assign(1, new Val(val->minor_version(), TYPE_COUNT));
		result->Assign(2, new Val(val->build_number(),  TYPE_COUNT));
		result->Assign(3, new Val(val->ntlm_revision(), TYPE_COUNT));

		return result;
		
	}

BroVal NTLM_Conn::build_av_record(NTLM_AV_Pair_Sequence * val)
	{

		RecordVal* result = new RecordVal(BifType::Record::NTLM::AVs);
		for ( uint i = 0; (*(val->pairs()))[i]->id() != 0; i++ )
			{
			switch ( (*(val->pairs()))[i]->id() )
				{
				case 1:
					result->Assign(0, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), (*(val->pairs()))[i]->nb_computer_name()->data()));
					break;
				case 2:
					result->Assign(1, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), (*(val->pairs()))[i]->nb_domain_name()->data()));
					break;
				case 3:
					result->Assign(2, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), (*(val->pairs()))[i]->dns_computer_name()->data()));
					break;
				case 4:
					result->Assign(3, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), (*(val->pairs()))[i]->dns_domain_name()->data()));
					break;
				case 5:
					result->Assign(4, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), (*(val->pairs()))[i]->dns_tree_name()->data()));
					break;
				case 6:
					result->Assign(5, new Val((*(val->pairs()))[i]->constrained_auth(), TYPE_BOOL));
					break;
				case 7:
					result->Assign(6, filetime2brotime((*(val->pairs()))[i]->timestamp()));
					break;
				case 8:
					result->Assign(7, new Val((*(val->pairs()))[i]->single_host()->machine_id(), TYPE_COUNT));
					break;
				case 9:
					result->Assign(8, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), (*(val->pairs()))[i]->target_name()->data()));
					break;
				}
			}
		return result;
		
	}

BroVal NTLM_Conn::build_negotiate_flag_record(NTLM_Negotiate_Flags * val)
	{

		RecordVal* flags = new RecordVal(BifType::Record::NTLM::NegotiateFlags);
		flags->Assign(0, new Val(val->negotiate_56(),                        TYPE_BOOL));
		flags->Assign(1, new Val(val->negotiate_key_exch(),                  TYPE_BOOL));
		flags->Assign(2, new Val(val->negotiate_128(),                       TYPE_BOOL));
		flags->Assign(3, new Val(val->negotiate_version(),                   TYPE_BOOL));
		flags->Assign(4, new Val(val->negotiate_target_info(),               TYPE_BOOL));
		flags->Assign(5, new Val(val->request_non_nt_session_key(),          TYPE_BOOL));
		flags->Assign(6, new Val(val->negotiate_identify(),                  TYPE_BOOL));
		flags->Assign(7, new Val(val->negotiate_extended_sessionsecurity(),  TYPE_BOOL));
		flags->Assign(8, new Val(val->target_type_server(),                  TYPE_BOOL));
		flags->Assign(9, new Val(val->target_type_domain(),                  TYPE_BOOL));
		flags->Assign(10, new Val(val->negotiate_always_sign(),              TYPE_BOOL));
		flags->Assign(11, new Val(val->negotiate_oem_workstation_supplied(), TYPE_BOOL));
		flags->Assign(12, new Val(val->negotiate_oem_domain_supplied(),      TYPE_BOOL));
		flags->Assign(13, new Val(val->negotiate_anonymous_connection(),     TYPE_BOOL));
		flags->Assign(14, new Val(val->negotiate_ntlm(),                     TYPE_BOOL));
		flags->Assign(15, new Val(val->negotiate_lm_key(),                   TYPE_BOOL));
		flags->Assign(16, new Val(val->negotiate_datagram(),                 TYPE_BOOL));
		flags->Assign(17, new Val(val->negotiate_seal(),                     TYPE_BOOL));
		flags->Assign(18, new Val(val->negotiate_sign(),                     TYPE_BOOL));
		flags->Assign(19, new Val(val->request_target(),                     TYPE_BOOL));
		flags->Assign(20, new Val(val->negotiate_oem(),                      TYPE_BOOL));
		flags->Assign(21, new Val(val->negotiate_unicode(),                  TYPE_BOOL));

		return flags;
		
	}

bool NTLM_Conn::proc_ntlm_negotiate(NTLM_Negotiate * val)
	{

		RecordVal* result = new RecordVal(BifType::Record::NTLM::Negotiate);
		result->Assign(0, build_negotiate_flag_record(val->flags()));

		if ( val->has_domain_name() )
		        result->Assign(1, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), val->domain_name()->string()->data()));

		if ( val->has_workstation() )
		        result->Assign(2, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), val->workstation()->string()->data()));

		if ( val->has_version() )
		        result->Assign(3, build_version_record(val->version()));

		BifEvent::generate_ntlm_negotiate(bro_analyzer(),
		                                  bro_analyzer()->Conn(),
		                                  result);

		return true;
		
	}

bool NTLM_Conn::proc_ntlm_challenge(NTLM_Challenge * val)
	{

		RecordVal* result = new RecordVal(BifType::Record::NTLM::Challenge);
		result->Assign(0, build_negotiate_flag_record(val->flags()));

		if ( val->has_target_name() )
			result->Assign(1, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), val->target_name()->string()->data()));

		if ( val->has_version() )
			result->Assign(2, build_version_record(val->version()));

		if ( val->has_target_info() )
			result->Assign(3, build_av_record(val->target_info()));

		BifEvent::generate_ntlm_challenge(bro_analyzer(),
		                                  bro_analyzer()->Conn(),
		                                  result);

		return true;
		
	}

bool NTLM_Conn::proc_ntlm_authenticate(NTLM_Authenticate * val)
	{

		RecordVal* result = new RecordVal(BifType::Record::NTLM::Authenticate);
		result->Assign(0, build_negotiate_flag_record(val->flags()));

		if ( val->has_domain_name() > 0 )
			result->Assign(1, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), val->domain_name()->string()->data()));

		if ( val->has_user_name() > 0 )
			result->Assign(2, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), val->user_name()->string()->data()));

		if ( val->has_workstation() > 0 )
			result->Assign(3, utf16_bytestring_to_utf8_val(bro_analyzer()->Conn(), val->workstation()->string()->data()));

		if ( val->has_encrypted_session_key() > 0 )
			result->Assign(4, bytestring_to_val(val->encrypted_session_key()->string()->data()));

		if ( val->has_version() )
			result->Assign(5, build_version_record(val->version()));

		BifEvent::generate_ntlm_authenticate(bro_analyzer(),
		                                     bro_analyzer()->Conn(),
		                                     result);
		return true;
		
	}

uint32 min(uint32 v1, uint32 v2)
	{

	return v1 < v2 ? v1 : v2;
	
	}

NTLM_SSP_Token::NTLM_SSP_Token(bool is_orig)
	{
	msg_type_ = 0;
	msg_case_index_ = -1;
	negotiate_ = 0;
	challenge_ = 0;
	authenticate_ = 0;
	is_orig_ = is_orig;
	byteorder_ = littleendian;
	}

NTLM_SSP_Token::~NTLM_SSP_Token()
	{
	signature_.free();
	switch ( msg_case_index() )
		{
		case 1:
			// Clean up "negotiate"
			{
			delete negotiate_;
			negotiate_ = 0;
			}
			break;
		case 2:
			// Clean up "challenge"
			{
			delete challenge_;
			challenge_ = 0;
			}
			break;
		case 3:
			// Clean up "authenticate"
			{
			delete authenticate_;
			authenticate_ = 0;
			}
			break;
		default:
			// Clean up "def"
			{
			}
			break;
		}
	}

int NTLM_SSP_Token::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNTLM * t_context)
	{
	// Parse "signature"
	// Checking out-of-bound for "NTLM_SSP_Token:signature"
	if ( t_begin_of_data + (8) > t_end_of_data || t_begin_of_data + (8) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_SSP_Token:signature",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 8;
	int t_signature_string_length;
	t_signature_string_length = 8;
	int t_signature__size;
	t_signature__size = t_signature_string_length;
	signature_.init(t_begin_of_data, t_signature_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_signature = t_begin_of_data + (8);
	BINPAC_ASSERT(t_dataptr_after_signature <= t_end_of_data);
	// Checking out-of-bound for "NTLM_SSP_Token:msg_type"
	if ( t_dataptr_after_signature + (4) > t_end_of_data || t_dataptr_after_signature + (4) < t_dataptr_after_signature )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_SSP_Token:msg_type",
			((t_dataptr_after_signature - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "msg_type"
	msg_type_ = FixByteOrder(byteorder(), *((uint32 const *) (t_dataptr_after_signature)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "msg"
	int t_msg__size;
	msg_case_index_ = msg_type();
	switch ( msg_case_index() )
		{
		case 1:
			// Parse "negotiate"
			{
			negotiate_ = new NTLM_Negotiate(((t_dataptr_after_signature + 4) - t_begin_of_data) - 0);
			int t_negotiate__size;
			t_negotiate__size = negotiate_->Parse((t_dataptr_after_signature + 4), t_end_of_data, t_context, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_msg__size = t_negotiate__size;
			}
			break;
		case 2:
			// Parse "challenge"
			{
			challenge_ = new NTLM_Challenge(((t_dataptr_after_signature + 4) - t_begin_of_data) - 0);
			int t_challenge__size;
			t_challenge__size = challenge_->Parse((t_dataptr_after_signature + 4), t_end_of_data, t_context, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_msg__size = t_challenge__size;
			}
			break;
		case 3:
			// Parse "authenticate"
			{
			authenticate_ = new NTLM_Authenticate(((t_dataptr_after_signature + 4) - t_begin_of_data) - 0);
			int t_authenticate__size;
			t_authenticate__size = authenticate_->Parse((t_dataptr_after_signature + 4), t_end_of_data, t_context, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_msg__size = t_authenticate__size;
			}
			break;
		default:
			// Parse "def"
			{
			int t_def_string_length;
			t_def_string_length = (t_end_of_data) - ((t_dataptr_after_signature + 4));
			int t_def__size;
			t_def__size = t_def_string_length;
			// check for negative sizes
			if ( t_def_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:14", t_def_string_length);
			def_.init((t_dataptr_after_signature + 4), t_def_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_msg__size = t_def__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLM_SSP_Token__size;
	const_byteptr const t_dataptr_after_msg = (t_dataptr_after_signature + 4) + (t_msg__size);
	BINPAC_ASSERT(t_dataptr_after_msg <= t_end_of_data);
	t_NTLM_SSP_Token__size = t_dataptr_after_msg - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_SSP_Token__size) <= t_end_of_data);
	return t_NTLM_SSP_Token__size;
	}

NTLM_Negotiate::NTLM_Negotiate(uint16 offset)
	{
	flags_ = 0;
	domain_name_fields_ = 0;
	workstation_fields_ = 0;
	offset_ = offset;
	absolute_offset_ = 0;
	version_ = 0;
	has_version_ = 0;
	domain_name_ = 0;
	has_domain_name_ = 0;
	workstation_ = 0;
	has_workstation_ = 0;
	proc_ = 0;
	}

NTLM_Negotiate::~NTLM_Negotiate()
	{
	delete flags_;
	flags_ = 0;
	delete domain_name_fields_;
	domain_name_fields_ = 0;
	delete workstation_fields_;
	workstation_fields_ = 0;
	payload_.free();
	delete version_;
	version_ = 0;
	delete domain_name_;
	domain_name_ = 0;
	delete workstation_;
	workstation_ = 0;
	}

int NTLM_Negotiate::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNTLM * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_Negotiate:workstation_fields"
	if ( (t_begin_of_data + 12) + (8) > t_end_of_data || (t_begin_of_data + 12) + (8) < (t_begin_of_data + 12) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Negotiate:workstation_fields",
			(12) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flags"
	flags_ = new NTLM_Negotiate_Flags();
	flags_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "domain_name_fields"
	domain_name_fields_ = new NTLM_StringData();
	domain_name_fields_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "workstation_fields"
	workstation_fields_ = new NTLM_StringData();
	workstation_fields_->Parse((t_begin_of_data + 12), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "payload"
	int t_payload_string_length;
	t_payload_string_length = (t_end_of_data) - ((t_begin_of_data + 20));
	int t_payload__size;
	t_payload__size = t_payload_string_length;
	// check for negative sizes
	if ( t_payload_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:22", t_payload_string_length);
	payload_.init((t_begin_of_data + 20), t_payload_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLM_Negotiate__size;
	const_byteptr const t_dataptr_after_payload = (t_begin_of_data + 20) + (t_payload__size);
	BINPAC_ASSERT(t_dataptr_after_payload <= t_end_of_data);
	t_NTLM_Negotiate__size = t_dataptr_after_payload - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	absolute_offset_ = 20 + offset();
	// Parse "version"
	has_version_ =  ( flags()->negotiate_version() &&  ( absolute_offset() < min(domain_name_fields()->offset(), workstation_fields()->offset()) )  ) ;
	if ( has_version() )
		{
		version_ = new NTLM_Version();
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		version_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "domain_name"
	has_domain_name_ =  ( flags()->negotiate_oem_domain_supplied() ) ;
	if ( has_domain_name() )
		{
		domain_name_ = new NTLM_String(domain_name_fields(), absolute_offset(), flags()->negotiate_unicode());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_domain_name__size;
		t_domain_name__size = domain_name_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "workstation"
	has_workstation_ =  ( flags()->negotiate_oem_workstation_supplied() ) ;
	if ( has_workstation() )
		{
		workstation_ = new NTLM_String(workstation_fields(), absolute_offset(), flags()->negotiate_unicode());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_workstation__size;
		t_workstation__size = workstation_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		}
	proc_ = t_context->connection()->proc_ntlm_negotiate(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_Negotiate__size) <= t_end_of_data);
	return t_NTLM_Negotiate__size;
	}

NTLM_Challenge::NTLM_Challenge(uint16 offset)
	{
	target_name_fields_ = 0;
	flags_ = 0;
	challenge_ = 0;
	target_info_fields_ = 0;
	offset_ = offset;
	absolute_offset_ = 0;
	version_ = 0;
	has_version_ = 0;
	target_name_ = 0;
	has_target_name_ = 0;
	target_info_ = 0;
	has_target_info_ = 0;
	proc_ = 0;
	}

NTLM_Challenge::~NTLM_Challenge()
	{
	delete target_name_fields_;
	target_name_fields_ = 0;
	delete flags_;
	flags_ = 0;
	delete target_info_fields_;
	target_info_fields_ = 0;
	payload_.free();
	delete version_;
	version_ = 0;
	delete target_name_;
	target_name_ = 0;
	delete target_info_;
	target_info_ = 0;
	}

int NTLM_Challenge::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNTLM * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_Challenge:target_info_fields"
	if ( (t_begin_of_data + 28) + (8) > t_end_of_data || (t_begin_of_data + 28) + (8) < (t_begin_of_data + 28) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Challenge:target_info_fields",
			(28) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "target_name_fields"
	target_name_fields_ = new NTLM_StringData();
	target_name_fields_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = new NTLM_Negotiate_Flags();
	flags_->Parse((t_begin_of_data + 8), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "challenge"
	challenge_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "target_info_fields"
	target_info_fields_ = new NTLM_StringData();
	target_info_fields_->Parse((t_begin_of_data + 28), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "payload"
	int t_payload_string_length;
	t_payload_string_length = (t_end_of_data) - ((t_begin_of_data + 36));
	int t_payload__size;
	t_payload__size = t_payload_string_length;
	// check for negative sizes
	if ( t_payload_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:36", t_payload_string_length);
	payload_.init((t_begin_of_data + 36), t_payload_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLM_Challenge__size;
	const_byteptr const t_dataptr_after_payload = (t_begin_of_data + 36) + (t_payload__size);
	BINPAC_ASSERT(t_dataptr_after_payload <= t_end_of_data);
	t_NTLM_Challenge__size = t_dataptr_after_payload - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	absolute_offset_ = 36 + offset();
	// Parse "version"
	has_version_ =  ( flags()->negotiate_version() &&  ( absolute_offset() < min(target_name_fields()->offset(), target_info_fields()->offset()) )  ) ;
	if ( has_version() )
		{
		version_ = new NTLM_Version();
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		version_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "target_name"
	has_target_name_ =  ( flags()->request_target() ) ;
	if ( has_target_name() )
		{
		target_name_ = new NTLM_String(target_name_fields(), absolute_offset(), flags()->negotiate_unicode());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_target_name__size;
		t_target_name__size = target_name_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "target_info"
	has_target_info_ =  ( flags()->negotiate_target_info() ) ;
	if ( has_target_info() )
		{
		target_info_ = new NTLM_AV_Pair_Sequence(target_info_fields()->offset() - absolute_offset());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_target_info__size;
		t_target_info__size = target_info_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		}
	proc_ = t_context->connection()->proc_ntlm_challenge(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_Challenge__size) <= t_end_of_data);
	return t_NTLM_Challenge__size;
	}

NTLM_Authenticate::NTLM_Authenticate(uint16 offset)
	{
	lm_challenge_response_fields_ = 0;
	nt_challenge_response_fields_ = 0;
	domain_name_fields_ = 0;
	user_name_fields_ = 0;
	workstation_fields_ = 0;
	encrypted_session_key_fields_ = 0;
	flags_ = 0;
	offset_ = offset;
	absolute_offset_ = 0;
	version_ = 0;
	has_version_ = 0;
	domain_name_ = 0;
	has_domain_name_ = 0;
	user_name_ = 0;
	has_user_name_ = 0;
	workstation_ = 0;
	has_workstation_ = 0;
	encrypted_session_key_ = 0;
	has_encrypted_session_key_ = 0;
	proc_ = 0;
	}

NTLM_Authenticate::~NTLM_Authenticate()
	{
	delete lm_challenge_response_fields_;
	lm_challenge_response_fields_ = 0;
	delete nt_challenge_response_fields_;
	nt_challenge_response_fields_ = 0;
	delete domain_name_fields_;
	domain_name_fields_ = 0;
	delete user_name_fields_;
	user_name_fields_ = 0;
	delete workstation_fields_;
	workstation_fields_ = 0;
	delete encrypted_session_key_fields_;
	encrypted_session_key_fields_ = 0;
	delete flags_;
	flags_ = 0;
	payload_.free();
	delete version_;
	version_ = 0;
	delete domain_name_;
	domain_name_ = 0;
	delete user_name_;
	user_name_ = 0;
	delete workstation_;
	workstation_ = 0;
	delete encrypted_session_key_;
	encrypted_session_key_ = 0;
	}

int NTLM_Authenticate::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNTLM * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_Authenticate:flags"
	if ( (t_begin_of_data + 48) + (4) > t_end_of_data || (t_begin_of_data + 48) + (4) < (t_begin_of_data + 48) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Authenticate:flags",
			(48) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "lm_challenge_response_fields"
	lm_challenge_response_fields_ = new NTLM_StringData();
	lm_challenge_response_fields_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "nt_challenge_response_fields"
	nt_challenge_response_fields_ = new NTLM_StringData();
	nt_challenge_response_fields_->Parse((t_begin_of_data + 8), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "domain_name_fields"
	domain_name_fields_ = new NTLM_StringData();
	domain_name_fields_->Parse((t_begin_of_data + 16), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "user_name_fields"
	user_name_fields_ = new NTLM_StringData();
	user_name_fields_->Parse((t_begin_of_data + 24), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "workstation_fields"
	workstation_fields_ = new NTLM_StringData();
	workstation_fields_->Parse((t_begin_of_data + 32), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "encrypted_session_key_fields"
	encrypted_session_key_fields_ = new NTLM_StringData();
	encrypted_session_key_fields_->Parse((t_begin_of_data + 40), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = new NTLM_Negotiate_Flags();
	flags_->Parse((t_begin_of_data + 48), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "payload"
	int t_payload_string_length;
	t_payload_string_length = (t_end_of_data) - ((t_begin_of_data + 52));
	int t_payload__size;
	t_payload__size = t_payload_string_length;
	// check for negative sizes
	if ( t_payload_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:57", t_payload_string_length);
	payload_.init((t_begin_of_data + 52), t_payload_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLM_Authenticate__size;
	const_byteptr const t_dataptr_after_payload = (t_begin_of_data + 52) + (t_payload__size);
	BINPAC_ASSERT(t_dataptr_after_payload <= t_end_of_data);
	t_NTLM_Authenticate__size = t_dataptr_after_payload - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	absolute_offset_ = 52 + offset();
	// Parse "version"
	has_version_ =  ( flags()->negotiate_version() &&  ( absolute_offset() < min(min(min(domain_name_fields()->offset(), user_name_fields()->offset()), workstation_fields()->offset()), encrypted_session_key_fields()->offset()) )  ) ;
	if ( has_version() )
		{
		version_ = new NTLM_Version();
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		version_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "domain_name"
	has_domain_name_ =  ( domain_name_fields()->length() > 0 ) ;
	if ( has_domain_name() )
		{
		domain_name_ = new NTLM_String(domain_name_fields(), absolute_offset(), flags()->negotiate_unicode());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_domain_name__size;
		t_domain_name__size = domain_name_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "user_name"
	has_user_name_ =  ( user_name_fields()->length() > 0 ) ;
	if ( has_user_name() )
		{
		user_name_ = new NTLM_String(user_name_fields(), absolute_offset(), flags()->negotiate_unicode());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_user_name__size;
		t_user_name__size = user_name_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "workstation"
	has_workstation_ =  ( workstation_fields()->length() > 0 ) ;
	if ( has_workstation() )
		{
		workstation_ = new NTLM_String(workstation_fields(), absolute_offset(), flags()->negotiate_unicode());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_workstation__size;
		t_workstation__size = workstation_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		}
	// Parse "encrypted_session_key"
	has_encrypted_session_key_ =  ( encrypted_session_key_fields()->length() > 0 ) ;
	if ( has_encrypted_session_key() )
		{
		encrypted_session_key_ = new NTLM_String(encrypted_session_key_fields(), absolute_offset(), flags()->negotiate_unicode());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(payload(), &t_begin_of_data, &t_end_of_data);
		int t_encrypted_session_key__size;
		t_encrypted_session_key__size = encrypted_session_key_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		}
	proc_ = t_context->connection()->proc_ntlm_authenticate(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_Authenticate__size) <= t_end_of_data);
	return t_NTLM_Authenticate__size;
	}

NTLM_Version::NTLM_Version()
	{
	major_version_ = 0;
	minor_version_ = 0;
	build_number_ = 0;
	ntlm_revision_ = 0;
	}

NTLM_Version::~NTLM_Version()
	{
	}

int NTLM_Version::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_Version"
	if ( t_begin_of_data + (8) > t_end_of_data || t_begin_of_data + (8) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Version",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "major_version"
	major_version_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "minor_version"
	minor_version_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "build_number"
	build_number_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "ntlm_revision"
	ntlm_revision_ = *((uint8 const *) ((t_begin_of_data + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

NTLM_StringData::NTLM_StringData()
	{
	length_ = 0;
	max_length_ = 0;
	offset_ = 0;
	}

NTLM_StringData::~NTLM_StringData()
	{
	}

int NTLM_StringData::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_StringData"
	if ( t_begin_of_data + (8) > t_end_of_data || t_begin_of_data + (8) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_StringData",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_length"
	max_length_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "offset"
	offset_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Fixed_Length_String::Fixed_Length_String(bool unicode)
	{
	unicode_ = unicode;
	}

Fixed_Length_String::~Fixed_Length_String()
	{
	data_.free();
	}

int Fixed_Length_String::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:82", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Fixed_Length_String__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Fixed_Length_String__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Fixed_Length_String__size) <= t_end_of_data);
	return t_Fixed_Length_String__size;
	}

NTLM_String::NTLM_String(NTLM_StringData * fields, uint16 offset, bool unicode)
	{
	string_ = 0;
	fields_ = fields;
	offset_ = offset;
	unicode_ = unicode;
	}

NTLM_String::~NTLM_String()
	{
	delete string_;
	string_ = 0;
	}

int NTLM_String::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	
	const_byteptr t_dataptr_after_pad1 = t_begin_of_data + (fields()->offset() - offset());
	if ( t_dataptr_after_pad1 < t_begin_of_data )
		{
		// throw binpac::ExceptionInvalidOffset("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:86:pad1", t_begin_of_data - t_begin_of_data, fields()->offset() - offset());
		t_dataptr_after_pad1 = t_begin_of_data;
		}
	if ( t_dataptr_after_pad1 > t_end_of_data )
		{
		throw binpac::ExceptionOutOfBound("NTLM_String:pad1",
			(fields()->offset() - offset()), 
			(t_end_of_data) - (t_dataptr_after_pad1));
		}
	// Parse "string"
	string_ = new Fixed_Length_String(unicode());
	int t_string__size;
	t_string__size = fields()->length();
	// Checking out-of-bound for "NTLM_String:string"
	if ( t_dataptr_after_pad1 + (t_string__size) > t_end_of_data || t_dataptr_after_pad1 + (t_string__size) < t_dataptr_after_pad1 )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_String:string",
			((t_dataptr_after_pad1 - t_begin_of_data)) + (t_string__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_pad1 + t_string__size;
	string_->Parse(t_dataptr_after_pad1, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_NTLM_String__size;
	const_byteptr const t_dataptr_after_string = t_dataptr_after_pad1 + (t_string__size);
	BINPAC_ASSERT(t_dataptr_after_string <= t_end_of_data);
	t_NTLM_String__size = t_dataptr_after_string - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_String__size) <= t_end_of_data);
	return t_NTLM_String__size;
	}

NTLM_AV_Pair_Sequence::NTLM_AV_Pair_Sequence(uint16 offset)
	{
	pairs_ = 0;
	pairs__elem_ = 0;
	offset_ = offset;
	}

NTLM_AV_Pair_Sequence::~NTLM_AV_Pair_Sequence()
	{
	delete pairs__elem_;
	pairs__elem_ = 0;
	if ( pairs() )
		{
		for ( int i = 0; i < (int) pairs()->size(); ++i )
			{
			NTLM_AV_Pair * pairs__elem_ = (*pairs_)[i];
			delete pairs__elem_;
			pairs__elem_ = 0;
			}
		}
	delete pairs_;
	}

int NTLM_AV_Pair_Sequence::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	
	const_byteptr t_dataptr_after_pad1 = t_begin_of_data + (offset());
	if ( t_dataptr_after_pad1 < t_begin_of_data )
		{
		// throw binpac::ExceptionInvalidOffset("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:91:pad1", t_begin_of_data - t_begin_of_data, offset());
		t_dataptr_after_pad1 = t_begin_of_data;
		}
	if ( t_dataptr_after_pad1 > t_end_of_data )
		{
		throw binpac::ExceptionOutOfBound("NTLM_AV_Pair_Sequence:pad1",
			(offset()), 
			(t_end_of_data) - (t_dataptr_after_pad1));
		}
	// Parse "pairs"
	int t_pairs__arraylength;
	t_pairs__arraylength = 0;
	pairs__elem_ = 0;
	int t_pairs__elem__it;
	t_pairs__elem__it = 0;
	int t_pairs__size;
	pairs_ = new vector<NTLM_AV_Pair *>;
	const_byteptr t_pairs__elem__dataptr = t_dataptr_after_pad1;
	for (; /* forever */; ++t_pairs__elem__it)
		{
		// Check &until(pairs__elem__dataptr >= end_of_data)
		if ( t_pairs__elem__dataptr >= t_end_of_data )
			{
			pairs__elem_ = 0;
			goto end_of_pairs;
			}
		pairs__elem_ = new NTLM_AV_Pair();
		int t_pairs__elem__size;
		t_pairs__elem__size = pairs__elem_->Parse(t_pairs__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		pairs_->push_back(pairs__elem_);
		t_pairs__elem__dataptr += t_pairs__elem__size;
		BINPAC_ASSERT(t_pairs__elem__dataptr <= t_end_of_data);
		// Check &until( ( @$element->last@ ) )
		if (  ( pairs__elem_->last() )  )
			{
			pairs__elem_ = 0;
			goto end_of_pairs;
			}
		pairs__elem_ = 0;
		}
end_of_pairs: ;
	t_pairs__size = t_pairs__elem__dataptr - (t_dataptr_after_pad1);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLM_AV_Pair_Sequence__size;
	const_byteptr const t_dataptr_after_pairs = t_dataptr_after_pad1 + (t_pairs__size);
	BINPAC_ASSERT(t_dataptr_after_pairs <= t_end_of_data);
	t_NTLM_AV_Pair_Sequence__size = t_dataptr_after_pairs - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_AV_Pair_Sequence__size) <= t_end_of_data);
	return t_NTLM_AV_Pair_Sequence__size;
	}

NTLM_AV_Pair::NTLM_AV_Pair()
	{
	id_ = 0;
	length_ = 0;
	value_case_case_index_ = -1;
	nb_computer_name_ = 0;
	nb_domain_name_ = 0;
	dns_computer_name_ = 0;
	dns_domain_name_ = 0;
	dns_tree_name_ = 0;
	av_flags_ = 0;
	timestamp_ = 0;
	single_host_ = 0;
	target_name_ = 0;
	channel_bindings_ = 0;
	last_ = 0;
	constrained_auth_ = 0;
	has_constrained_auth_ = 0;
	mic_present_ = 0;
	has_mic_present_ = 0;
	untrusted_source_ = 0;
	has_untrusted_source_ = 0;
	}

NTLM_AV_Pair::~NTLM_AV_Pair()
	{
	switch ( value_case_case_index() )
		{
		case 0:
			// Clean up "av_eol"
			{
			}
			break;
		case 1:
			// Clean up "nb_computer_name"
			{
			delete nb_computer_name_;
			nb_computer_name_ = 0;
			}
			break;
		case 2:
			// Clean up "nb_domain_name"
			{
			delete nb_domain_name_;
			nb_domain_name_ = 0;
			}
			break;
		case 3:
			// Clean up "dns_computer_name"
			{
			delete dns_computer_name_;
			dns_computer_name_ = 0;
			}
			break;
		case 4:
			// Clean up "dns_domain_name"
			{
			delete dns_domain_name_;
			dns_domain_name_ = 0;
			}
			break;
		case 5:
			// Clean up "dns_tree_name"
			{
			delete dns_tree_name_;
			dns_tree_name_ = 0;
			}
			break;
		case 6:
			// Clean up "av_flags"
			{
			}
			break;
		case 7:
			// Clean up "timestamp"
			{
			}
			break;
		case 8:
			// Clean up "single_host"
			{
			delete single_host_;
			single_host_ = 0;
			}
			break;
		case 9:
			// Clean up "target_name"
			{
			delete target_name_;
			target_name_ = 0;
			}
			break;
		case 10:
			// Clean up "channel_bindings"
			{
			}
			break;
		}
	}

int NTLM_AV_Pair::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_AV_Pair:length"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:length",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "id"
	id_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_case"
	int t_value_case__size;
	value_case_case_index_ = id();
	switch ( value_case_case_index() )
		{
		case 0:
			// Parse "av_eol"
			{
			// Evaluate 'let' and 'withinput' fields
			t_value_case__size = 0;
			}
			break;
		case 1:
			// Parse "nb_computer_name"
			{
			nb_computer_name_ = new Fixed_Length_String(true);
			int t_nb_computer_name__size;
			t_nb_computer_name__size = length();
			// Checking out-of-bound for "NTLM_AV_Pair:nb_computer_name"
			if ( (t_begin_of_data + 4) + (t_nb_computer_name__size) > t_end_of_data || (t_begin_of_data + 4) + (t_nb_computer_name__size) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:nb_computer_name",
					(4) + (t_nb_computer_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_nb_computer_name__size;
			nb_computer_name_->Parse((t_begin_of_data + 4), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value_case__size = t_nb_computer_name__size;
			}
			break;
		case 2:
			// Parse "nb_domain_name"
			{
			nb_domain_name_ = new Fixed_Length_String(true);
			int t_nb_domain_name__size;
			t_nb_domain_name__size = length();
			// Checking out-of-bound for "NTLM_AV_Pair:nb_domain_name"
			if ( (t_begin_of_data + 4) + (t_nb_domain_name__size) > t_end_of_data || (t_begin_of_data + 4) + (t_nb_domain_name__size) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:nb_domain_name",
					(4) + (t_nb_domain_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_nb_domain_name__size;
			nb_domain_name_->Parse((t_begin_of_data + 4), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value_case__size = t_nb_domain_name__size;
			}
			break;
		case 3:
			// Parse "dns_computer_name"
			{
			dns_computer_name_ = new Fixed_Length_String(true);
			int t_dns_computer_name__size;
			t_dns_computer_name__size = length();
			// Checking out-of-bound for "NTLM_AV_Pair:dns_computer_name"
			if ( (t_begin_of_data + 4) + (t_dns_computer_name__size) > t_end_of_data || (t_begin_of_data + 4) + (t_dns_computer_name__size) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:dns_computer_name",
					(4) + (t_dns_computer_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_dns_computer_name__size;
			dns_computer_name_->Parse((t_begin_of_data + 4), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value_case__size = t_dns_computer_name__size;
			}
			break;
		case 4:
			// Parse "dns_domain_name"
			{
			dns_domain_name_ = new Fixed_Length_String(true);
			int t_dns_domain_name__size;
			t_dns_domain_name__size = length();
			// Checking out-of-bound for "NTLM_AV_Pair:dns_domain_name"
			if ( (t_begin_of_data + 4) + (t_dns_domain_name__size) > t_end_of_data || (t_begin_of_data + 4) + (t_dns_domain_name__size) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:dns_domain_name",
					(4) + (t_dns_domain_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_dns_domain_name__size;
			dns_domain_name_->Parse((t_begin_of_data + 4), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value_case__size = t_dns_domain_name__size;
			}
			break;
		case 5:
			// Parse "dns_tree_name"
			{
			dns_tree_name_ = new Fixed_Length_String(true);
			int t_dns_tree_name__size;
			t_dns_tree_name__size = length();
			// Checking out-of-bound for "NTLM_AV_Pair:dns_tree_name"
			if ( (t_begin_of_data + 4) + (t_dns_tree_name__size) > t_end_of_data || (t_begin_of_data + 4) + (t_dns_tree_name__size) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:dns_tree_name",
					(4) + (t_dns_tree_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_dns_tree_name__size;
			dns_tree_name_->Parse((t_begin_of_data + 4), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value_case__size = t_dns_tree_name__size;
			}
			break;
		case 6:
			// Parse "av_flags"
			{
			// Checking out-of-bound for "NTLM_AV_Pair:av_flags"
			if ( (t_begin_of_data + 4) + (4) > t_end_of_data || (t_begin_of_data + 4) + (4) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:av_flags",
					(4) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			av_flags_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
			// Evaluate 'let' and 'withinput' fields
			t_value_case__size = 4;
			}
			break;
		case 7:
			// Parse "timestamp"
			{
			// Checking out-of-bound for "NTLM_AV_Pair:timestamp"
			if ( (t_begin_of_data + 4) + (8) > t_end_of_data || (t_begin_of_data + 4) + (8) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:timestamp",
					(4) + (8), 
					(t_end_of_data) - (t_begin_of_data));
				}
			timestamp_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 4))));
			// Evaluate 'let' and 'withinput' fields
			t_value_case__size = 8;
			}
			break;
		case 8:
			// Parse "single_host"
			{
			single_host_ = new NTLM_Single_Host();
			int t_single_host__size;
			t_single_host__size = single_host_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_value_case__size = t_single_host__size;
			}
			break;
		case 9:
			// Parse "target_name"
			{
			target_name_ = new Fixed_Length_String(true);
			int t_target_name__size;
			t_target_name__size = length();
			// Checking out-of-bound for "NTLM_AV_Pair:target_name"
			if ( (t_begin_of_data + 4) + (t_target_name__size) > t_end_of_data || (t_begin_of_data + 4) + (t_target_name__size) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:target_name",
					(4) + (t_target_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_target_name__size;
			target_name_->Parse((t_begin_of_data + 4), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value_case__size = t_target_name__size;
			}
			break;
		case 10:
			// Parse "channel_bindings"
			{
			// Checking out-of-bound for "NTLM_AV_Pair:channel_bindings"
			if ( (t_begin_of_data + 4) + (2) > t_end_of_data || (t_begin_of_data + 4) + (2) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_AV_Pair:channel_bindings",
					(4) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			channel_bindings_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 4))));
			// Evaluate 'let' and 'withinput' fields
			t_value_case__size = 2;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("NTLM_AV_Pair", value_case_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLM_AV_Pair__size;
	const_byteptr const t_dataptr_after_value_case = (t_begin_of_data + 4) + (t_value_case__size);
	BINPAC_ASSERT(t_dataptr_after_value_case <= t_end_of_data);
	t_NTLM_AV_Pair__size = t_dataptr_after_value_case - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	last_ =  ( id() == 0x0000 ) ;
	has_constrained_auth_ =  ( id() == 0x0006 ) ;
	if ( has_constrained_auth() )
		{
		constrained_auth_ =  ( av_flags() & 0x00000001 )  > 0;
		}
	has_mic_present_ =  ( id() == 0x0006 ) ;
	if ( has_mic_present() )
		{
		mic_present_ =  ( av_flags() & 0x00000002 )  > 0;
		}
	has_untrusted_source_ =  ( id() == 0x0006 ) ;
	if ( has_untrusted_source() )
		{
		untrusted_source_ =  ( av_flags() & 0x00000004 )  > 0;
		}
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_AV_Pair__size) <= t_end_of_data);
	return t_NTLM_AV_Pair__size;
	}

NTLM_Single_Host::NTLM_Single_Host()
	{
	size_ = 0;
	data_present_ = 0;
	optional_case_index_ = -1;
	machine_id_ = 0;
	custom_data_present_ = 0;
	}

NTLM_Single_Host::~NTLM_Single_Host()
	{
	switch ( optional_case_index() )
		{
		case 1:
			// Clean up "custom_data"
			{
			custom_data_.free();
			}
			break;
		case 0:
			// Clean up "nothing"
			{
			}
			break;
		}
	}

int NTLM_Single_Host::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_Single_Host:data_present"
	if ( (t_begin_of_data + 8) + (4) > t_end_of_data || (t_begin_of_data + 8) + (4) < (t_begin_of_data + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Single_Host:data_present",
			(8) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "size"
	size_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "data_present"
	data_present_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "optional"
	int t_optional__size;
	custom_data_present_ =  ( data_present() & 0x00000001 )  > 0;
	optional_case_index_ = custom_data_present();
	switch ( optional_case_index() )
		{
		case 1:
			// Parse "custom_data"
			{
			// Checking out-of-bound for "NTLM_Single_Host:custom_data"
			if ( (t_begin_of_data + 12) + (4) > t_end_of_data || (t_begin_of_data + 12) + (4) < (t_begin_of_data + 12) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("NTLM_Single_Host:custom_data",
					(12) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 12) + 4;
			int t_custom_data_string_length;
			t_custom_data_string_length = 4;
			int t_custom_data__size;
			t_custom_data__size = t_custom_data_string_length;
			custom_data_.init((t_begin_of_data + 12), t_custom_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_optional__size = 4;
			}
			break;
		case 0:
			// Parse "nothing"
			{
			// Evaluate 'let' and 'withinput' fields
			t_optional__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("NTLM_Single_Host", optional_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_optional = (t_begin_of_data + 12) + (t_optional__size);
	BINPAC_ASSERT(t_dataptr_after_optional <= t_end_of_data);
	// Checking out-of-bound for "NTLM_Single_Host:machine_id"
	if ( t_dataptr_after_optional + (4) > t_end_of_data || t_dataptr_after_optional + (4) < t_dataptr_after_optional )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Single_Host:machine_id",
			((t_dataptr_after_optional - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "machine_id"
	machine_id_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_optional)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLM_Single_Host__size;
	t_NTLM_Single_Host__size = (t_dataptr_after_optional + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_Single_Host__size) <= t_end_of_data);
	return t_NTLM_Single_Host__size;
	}

LM_Response::LM_Response(uint16 offset)
	{
	offset_ = offset;
	}

LM_Response::~LM_Response()
	{
	response_.free();
	}

int LM_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	
	const_byteptr t_dataptr_after_padpad = t_begin_of_data + (offset());
	if ( t_dataptr_after_padpad < t_begin_of_data )
		{
		// throw binpac::ExceptionInvalidOffset("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:136:padpad", t_begin_of_data - t_begin_of_data, offset());
		t_dataptr_after_padpad = t_begin_of_data;
		}
	if ( t_dataptr_after_padpad > t_end_of_data )
		{
		throw binpac::ExceptionOutOfBound("LM_Response:padpad",
			(offset()), 
			(t_end_of_data) - (t_dataptr_after_padpad));
		}
	// Parse "response"
	// Checking out-of-bound for "LM_Response:response"
	if ( t_dataptr_after_padpad + (24) > t_end_of_data || t_dataptr_after_padpad + (24) < t_dataptr_after_padpad )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("LM_Response:response",
			((t_dataptr_after_padpad - t_begin_of_data)) + (24), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_padpad + 24;
	int t_response_string_length;
	t_response_string_length = 24;
	int t_response__size;
	t_response__size = t_response_string_length;
	response_.init(t_dataptr_after_padpad, t_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_LM_Response__size;
	const_byteptr const t_dataptr_after_response = t_dataptr_after_padpad + (24);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	t_LM_Response__size = t_dataptr_after_response - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_LM_Response__size) <= t_end_of_data);
	return t_LM_Response__size;
	}

NTLM_Response::NTLM_Response(uint16 offset)
	{
	offset_ = offset;
	}

NTLM_Response::~NTLM_Response()
	{
	response_.free();
	}

int NTLM_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	
	const_byteptr t_dataptr_after_padpad = t_begin_of_data + (offset());
	if ( t_dataptr_after_padpad < t_begin_of_data )
		{
		// throw binpac::ExceptionInvalidOffset("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:141:padpad", t_begin_of_data - t_begin_of_data, offset());
		t_dataptr_after_padpad = t_begin_of_data;
		}
	if ( t_dataptr_after_padpad > t_end_of_data )
		{
		throw binpac::ExceptionOutOfBound("NTLM_Response:padpad",
			(offset()), 
			(t_end_of_data) - (t_dataptr_after_padpad));
		}
	// Parse "response"
	// Checking out-of-bound for "NTLM_Response:response"
	if ( t_dataptr_after_padpad + (24) > t_end_of_data || t_dataptr_after_padpad + (24) < t_dataptr_after_padpad )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Response:response",
			((t_dataptr_after_padpad - t_begin_of_data)) + (24), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_padpad + 24;
	int t_response_string_length;
	t_response_string_length = 24;
	int t_response__size;
	t_response__size = t_response_string_length;
	response_.init(t_dataptr_after_padpad, t_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_NTLM_Response__size;
	const_byteptr const t_dataptr_after_response = t_dataptr_after_padpad + (24);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	t_NTLM_Response__size = t_dataptr_after_response - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NTLM_Response__size) <= t_end_of_data);
	return t_NTLM_Response__size;
	}

NTLMv2_Response::NTLMv2_Response(NTLM_Negotiate_Flags * flags, uint16 offset)
	{
	client_challenge_ = 0;
	flags_ = flags;
	offset_ = offset;
	}

NTLMv2_Response::~NTLMv2_Response()
	{
	response_.free();
	delete client_challenge_;
	client_challenge_ = 0;
	}

int NTLMv2_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	
	const_byteptr t_dataptr_after_padpad = t_begin_of_data + (offset());
	if ( t_dataptr_after_padpad < t_begin_of_data )
		{
		// throw binpac::ExceptionInvalidOffset("/home/ubuntu/bro/src/analyzer/protocol/ntlm/ntlm-protocol.pac:146:padpad", t_begin_of_data - t_begin_of_data, offset());
		t_dataptr_after_padpad = t_begin_of_data;
		}
	if ( t_dataptr_after_padpad > t_end_of_data )
		{
		throw binpac::ExceptionOutOfBound("NTLMv2_Response:padpad",
			(offset()), 
			(t_end_of_data) - (t_dataptr_after_padpad));
		}
	// Parse "response"
	// Checking out-of-bound for "NTLMv2_Response:response"
	if ( t_dataptr_after_padpad + (16) > t_end_of_data || t_dataptr_after_padpad + (16) < t_dataptr_after_padpad )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLMv2_Response:response",
			((t_dataptr_after_padpad - t_begin_of_data)) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_padpad + 16;
	int t_response_string_length;
	t_response_string_length = 16;
	int t_response__size;
	t_response__size = t_response_string_length;
	response_.init(t_dataptr_after_padpad, t_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_response = t_dataptr_after_padpad + (16);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	// Parse "client_challenge"
	client_challenge_ = new NTLMv2_Client_Challenge(flags());
	int t_client_challenge__size;
	t_client_challenge__size = client_challenge_->Parse(t_dataptr_after_response, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLMv2_Response__size;
	const_byteptr const t_dataptr_after_client_challenge = t_dataptr_after_response + (t_client_challenge__size);
	BINPAC_ASSERT(t_dataptr_after_client_challenge <= t_end_of_data);
	t_NTLMv2_Response__size = t_dataptr_after_client_challenge - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NTLMv2_Response__size) <= t_end_of_data);
	return t_NTLMv2_Response__size;
	}

NTLMv2_Client_Challenge::NTLMv2_Client_Challenge(NTLM_Negotiate_Flags * flags)
	{
	resp_type_ = 0;
	max_resp_type_ = 0;
	timestamp_ = 0;
	av_pairs_ = 0;
	flags_ = flags;
	}

NTLMv2_Client_Challenge::~NTLMv2_Client_Challenge()
	{
	client_challenge_.free();
	delete av_pairs_;
	av_pairs_ = 0;
	}

int NTLMv2_Client_Challenge::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NTLMv2_Client_Challenge:timestamp"
	if ( (t_begin_of_data + 8) + (8) > t_end_of_data || (t_begin_of_data + 8) + (8) < (t_begin_of_data + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLMv2_Client_Challenge:timestamp",
			(8) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "resp_type"
	resp_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_resp_type"
	max_resp_type_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "timestamp"
	timestamp_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "client_challenge"
	// Checking out-of-bound for "NTLMv2_Client_Challenge:client_challenge"
	if ( (t_begin_of_data + 16) + (8) > t_end_of_data || (t_begin_of_data + 16) + (8) < (t_begin_of_data + 16) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLMv2_Client_Challenge:client_challenge",
			(16) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 16) + 8;
	int t_client_challenge_string_length;
	t_client_challenge_string_length = 8;
	int t_client_challenge__size;
	t_client_challenge__size = t_client_challenge_string_length;
	client_challenge_.init((t_begin_of_data + 16), t_client_challenge_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	
	const_byteptr const t_dataptr_after_client_challenge = (t_begin_of_data + 16) + (8);
	BINPAC_ASSERT(t_dataptr_after_client_challenge <= t_end_of_data);
	// Parse "av_pairs"
	av_pairs_ = new NTLM_AV_Pair_Sequence(0);
	int t_av_pairs__size;
	t_av_pairs__size = av_pairs_->Parse((t_dataptr_after_client_challenge + 4), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NTLMv2_Client_Challenge__size;
	const_byteptr const t_dataptr_after_av_pairs = (t_dataptr_after_client_challenge + 4) + (t_av_pairs__size);
	BINPAC_ASSERT(t_dataptr_after_av_pairs <= t_end_of_data);
	t_NTLMv2_Client_Challenge__size = t_dataptr_after_av_pairs - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NTLMv2_Client_Challenge__size) <= t_end_of_data);
	return t_NTLMv2_Client_Challenge__size;
	}

NTLM_Negotiate_Flags::NTLM_Negotiate_Flags()
	{
	flags_ = 0;
	negotiate_56_ = 0;
	negotiate_key_exch_ = 0;
	negotiate_128_ = 0;
	negotiate_version_ = 0;
	negotiate_target_info_ = 0;
	request_non_nt_session_key_ = 0;
	negotiate_identify_ = 0;
	negotiate_extended_sessionsecurity_ = 0;
	target_type_server_ = 0;
	target_type_domain_ = 0;
	negotiate_always_sign_ = 0;
	negotiate_oem_workstation_supplied_ = 0;
	negotiate_oem_domain_supplied_ = 0;
	negotiate_anonymous_connection_ = 0;
	negotiate_ntlm_ = 0;
	negotiate_lm_key_ = 0;
	negotiate_datagram_ = 0;
	negotiate_seal_ = 0;
	negotiate_sign_ = 0;
	request_target_ = 0;
	negotiate_oem_ = 0;
	negotiate_unicode_ = 0;
	is_oem_ = 0;
	is_invalid_ = 0;
	}

NTLM_Negotiate_Flags::~NTLM_Negotiate_Flags()
	{
	}

int NTLM_Negotiate_Flags::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NTLM_Negotiate_Flags"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NTLM_Negotiate_Flags",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flags"
	flags_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	negotiate_56_ =  ( flags() & 0x80000000 )  > 0;
	negotiate_key_exch_ =  ( flags() & 0x40000000 )  > 0;
	negotiate_128_ =  ( flags() & 0x20000000 )  > 0;
	negotiate_version_ =  ( flags() & 0x02000000 )  > 0;
	negotiate_target_info_ =  ( flags() & 0x00800000 )  > 0;
	request_non_nt_session_key_ =  ( flags() & 0x00400000 )  > 0;
	negotiate_identify_ =  ( flags() & 0x00100000 )  > 0;
	negotiate_extended_sessionsecurity_ =  ( flags() & 0x00040000 )  > 0;
	target_type_server_ =  ( flags() & 0x00020000 )  > 0;
	target_type_domain_ =  ( flags() & 0x00010000 )  > 0;
	negotiate_always_sign_ =  ( flags() & 0x00008000 )  > 0;
	negotiate_oem_workstation_supplied_ =  ( flags() & 0x00002000 )  > 0;
	negotiate_oem_domain_supplied_ =  ( flags() & 0x00001000 )  > 0;
	negotiate_anonymous_connection_ =  ( flags() & 0x00000400 )  > 0;
	negotiate_ntlm_ =  ( flags() & 0x00000100 )  > 0;
	negotiate_lm_key_ =  ( flags() & 0x00000080 )  > 0;
	negotiate_datagram_ =  ( flags() & 0x00000040 )  > 0;
	negotiate_seal_ =  ( flags() & 0x00000020 )  > 0;
	negotiate_sign_ =  ( flags() & 0x00000008 )  > 0;
	request_target_ =  ( flags() & 0x00000004 )  > 0;
	negotiate_oem_ =  ( flags() & 0x00000002 )  > 0;
	negotiate_unicode_ =  ( flags() & 0x00000001 )  > 0;
	is_oem_ = ! negotiate_unicode() && negotiate_oem();
	is_invalid_ = ! negotiate_unicode() && ! negotiate_oem();
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

ASN1Encoding::ASN1Encoding()
	{
	meta_ = 0;
	}

ASN1Encoding::~ASN1Encoding()
	{
	delete meta_;
	meta_ = 0;
	content_.free();
	}

int ASN1Encoding::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "meta"
	meta_ = new ASN1EncodingMeta();
	int t_meta__size;
	t_meta__size = meta_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_meta = t_begin_of_data + (t_meta__size);
	BINPAC_ASSERT(t_dataptr_after_meta <= t_end_of_data);
	// Parse "content"
	int t_content__size;
	t_content__size = meta()->length();
	// Checking out-of-bound for "ASN1Encoding:content"
	if ( t_dataptr_after_meta + (t_content__size) > t_end_of_data || t_dataptr_after_meta + (t_content__size) < t_dataptr_after_meta )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ASN1Encoding:content",
			((t_dataptr_after_meta - t_begin_of_data)) + (t_content__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_meta + t_content__size;
	int t_content_string_length;
	t_content_string_length = meta()->length();
	// check for negative sizes
	if ( t_content_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ntlm/../asn1/asn1.pac:28", t_content_string_length);
	content_.init(t_dataptr_after_meta, t_content_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ASN1Encoding__size;
	const_byteptr const t_dataptr_after_content = t_dataptr_after_meta + (t_content__size);
	BINPAC_ASSERT(t_dataptr_after_content <= t_end_of_data);
	t_ASN1Encoding__size = t_dataptr_after_content - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1Encoding__size) <= t_end_of_data);
	return t_ASN1Encoding__size;
	}

ASN1EncodingMeta::ASN1EncodingMeta()
	{
	tag_ = 0;
	len_ = 0;
	long_len_ = 0;
	length_ = 0;
	index_ = 0;
	}

ASN1EncodingMeta::~ASN1EncodingMeta()
	{
	more_len_.free();
	}

int ASN1EncodingMeta::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ASN1EncodingMeta:len"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data || (t_begin_of_data + 1) + (1) < (t_begin_of_data + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ASN1EncodingMeta:len",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "tag"
	tag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "len"
	len_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "more_len"
	int t_more_len__size;
	long_len_ =  ( len() & 0x80 )  > 0;
	t_more_len__size = long_len() ? len() & 0x7f : 0;
	// Checking out-of-bound for "ASN1EncodingMeta:more_len"
	if ( (t_begin_of_data + 2) + (t_more_len__size) > t_end_of_data || (t_begin_of_data + 2) + (t_more_len__size) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ASN1EncodingMeta:more_len",
			(2) + (t_more_len__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_more_len__size;
	int t_more_len_string_length;
	t_more_len_string_length = long_len() ? len() & 0x7f : 0;
	// check for negative sizes
	if ( t_more_len_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/ntlm/../asn1/asn1.pac:34", t_more_len_string_length);
	more_len_.init((t_begin_of_data + 2), t_more_len_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ASN1EncodingMeta__size;
	const_byteptr const t_dataptr_after_more_len = (t_begin_of_data + 2) + (t_more_len__size);
	BINPAC_ASSERT(t_dataptr_after_more_len <= t_end_of_data);
	t_ASN1EncodingMeta__size = t_dataptr_after_more_len - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	length_ = long_len() ? binary_to_int64(more_len()) : len();
	index_ = tag() - ASN1_INDEX_TAG_OFFSET;
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1EncodingMeta__size) <= t_end_of_data);
	return t_ASN1EncodingMeta__size;
	}

ASN1OptionalEncodingMeta::ASN1OptionalEncodingMeta(bool is_present, ASN1EncodingMeta * previous_metadata)
	{
	val_case_index_ = -1;
	data_ = 0;
	is_present_ = is_present;
	previous_metadata_ = previous_metadata;
	length_ = 0;
	}

ASN1OptionalEncodingMeta::~ASN1OptionalEncodingMeta()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "data"
			{
			delete data_;
			data_ = 0;
			}
			break;
		case 0:
			// Clean up "none"
			{
			}
			break;
		}
	}

int ASN1OptionalEncodingMeta::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__size;
	val_case_index_ = is_present();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "data"
			{
			data_ = new ASN1EncodingMeta();
			int t_data__size;
			t_data__size = data_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_data__size;
			}
			break;
		case 0:
			// Parse "none"
			{
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("ASN1OptionalEncodingMeta", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	length_ = is_present() ? data()->length() : previous_metadata()->length();
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

ASN1SequenceMeta::ASN1SequenceMeta()
	{
	encoding_ = 0;
	}

ASN1SequenceMeta::~ASN1SequenceMeta()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1SequenceMeta::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "encoding"
	encoding_ = new ASN1EncodingMeta();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1SequenceMeta__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1SequenceMeta__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1SequenceMeta__size) <= t_end_of_data);
	return t_ASN1SequenceMeta__size;
	}

ASN1Integer::ASN1Integer()
	{
	encoding_ = 0;
	}

ASN1Integer::~ASN1Integer()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1Integer::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1Integer__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1Integer__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1Integer__size) <= t_end_of_data);
	return t_ASN1Integer__size;
	}

ASN1OctetString::ASN1OctetString()
	{
	encoding_ = 0;
	}

ASN1OctetString::~ASN1OctetString()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1OctetString::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1OctetString__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1OctetString__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1OctetString__size) <= t_end_of_data);
	return t_ASN1OctetString__size;
	}

ASN1ObjectIdentifier::ASN1ObjectIdentifier()
	{
	encoding_ = 0;
	}

ASN1ObjectIdentifier::~ASN1ObjectIdentifier()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1ObjectIdentifier::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1ObjectIdentifier__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1ObjectIdentifier__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1ObjectIdentifier__size) <= t_end_of_data);
	return t_ASN1ObjectIdentifier__size;
	}

ASN1Boolean::ASN1Boolean()
	{
	encoding_ = 0;
	}

ASN1Boolean::~ASN1Boolean()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1Boolean::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1Boolean__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1Boolean__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1Boolean__size) <= t_end_of_data);
	return t_ASN1Boolean__size;
	}

ASN1Enumerated::ASN1Enumerated()
	{
	encoding_ = 0;
	}

ASN1Enumerated::~ASN1Enumerated()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1Enumerated::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1Enumerated__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1Enumerated__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1Enumerated__size) <= t_end_of_data);
	return t_ASN1Enumerated__size;
	}

SequenceElement::SequenceElement(bool grab_content)
	{
	index_meta_ = 0;
	have_content_case_index_ = -1;
	data_ = 0;
	meta_ = 0;
	grab_content_ = grab_content;
	index_ = 0;
	length_ = 0;
	}

SequenceElement::~SequenceElement()
	{
	delete index_meta_;
	index_meta_ = 0;
	switch ( have_content_case_index() )
		{
		case 1:
			// Clean up "data"
			{
			delete data_;
			data_ = 0;
			}
			break;
		case 0:
			// Clean up "meta"
			{
			delete meta_;
			meta_ = 0;
			}
			break;
		}
	}

int SequenceElement::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "index_meta"
	index_meta_ = new ASN1EncodingMeta();
	int t_index_meta__size;
	t_index_meta__size = index_meta_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_index_meta = t_begin_of_data + (t_index_meta__size);
	BINPAC_ASSERT(t_dataptr_after_index_meta <= t_end_of_data);
	// Parse "have_content"
	int t_have_content__size;
	have_content_case_index_ = grab_content();
	switch ( have_content_case_index() )
		{
		case 1:
			// Parse "data"
			{
			data_ = new ASN1Encoding();
			int t_data__size;
			t_data__size = data_->Parse(t_dataptr_after_index_meta, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_have_content__size = t_data__size;
			}
			break;
		case 0:
			// Parse "meta"
			{
			meta_ = new ASN1EncodingMeta();
			int t_meta__size;
			t_meta__size = meta_->Parse(t_dataptr_after_index_meta, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_have_content__size = t_meta__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SequenceElement", have_content_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_SequenceElement__size;
	const_byteptr const t_dataptr_after_have_content = t_dataptr_after_index_meta + (t_have_content__size);
	BINPAC_ASSERT(t_dataptr_after_have_content <= t_end_of_data);
	t_SequenceElement__size = t_dataptr_after_have_content - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	index_ = index_meta()->index();
	length_ = index_meta()->length();
	BINPAC_ASSERT(t_begin_of_data + (t_SequenceElement__size) <= t_end_of_data);
	return t_SequenceElement__size;
	}

Array::Array()
	{
	array_meta_ = 0;
	data_ = 0;
	data__elem_ = 0;
	}

Array::~Array()
	{
	delete array_meta_;
	array_meta_ = 0;
	delete data__elem_;
	data__elem_ = 0;
	if ( data() )
		{
		for ( int i = 0; i < (int) data()->size(); ++i )
			{
			ASN1Encoding * data__elem_ = (*data_)[i];
			delete data__elem_;
			data__elem_ = 0;
			}
		}
	delete data_;
	}

int Array::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "array_meta"
	array_meta_ = new ASN1EncodingMeta();
	int t_array_meta__size;
	t_array_meta__size = array_meta_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_array_meta = t_begin_of_data + (t_array_meta__size);
	BINPAC_ASSERT(t_dataptr_after_array_meta <= t_end_of_data);
	// Parse "data"
	int t_data__arraylength;
	t_data__arraylength = 0;
	data__elem_ = 0;
	int t_data__elem__it;
	t_data__elem__it = 0;
	int t_data__size;
	data_ = new vector<ASN1Encoding *>;
	const_byteptr t_data__elem__dataptr = t_dataptr_after_array_meta;
	for (; /* forever */; ++t_data__elem__it)
		{
		// Check &until(data__elem__dataptr >= end_of_data)
		if ( t_data__elem__dataptr >= t_end_of_data )
			{
			data__elem_ = 0;
			goto end_of_data;
			}
		data__elem_ = new ASN1Encoding();
		int t_data__elem__size;
		t_data__elem__size = data__elem_->Parse(t_data__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		data_->push_back(data__elem_);
		t_data__elem__dataptr += t_data__elem__size;
		BINPAC_ASSERT(t_data__elem__dataptr <= t_end_of_data);
		data__elem_ = 0;
		}
end_of_data: ;
	t_data__size = t_data__elem__dataptr - (t_dataptr_after_array_meta);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Array__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_array_meta + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Array__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Array__size) <= t_end_of_data);
	return t_Array__size;
	}

int64 binary_to_int64(bytestring const & bs)
	{

	int64 rval = 0;

	for ( int i = 0; i < bs.length(); ++i )
		{
		uint64 byte = bs[i];
		rval |= byte << (8 * (bs.length() - (i + 1)));
		}

	return rval;
	
	}



Val* asn1_integer_to_val(const ASN1Integer* i, TypeTag t)
	{
	return asn1_integer_to_val(i->encoding(), t);
	}

Val* asn1_integer_to_val(const ASN1Encoding* i, TypeTag t)
	{
	return new Val(binary_to_int64(i->content()), t);
	}

StringVal* asn1_oid_to_val(const ASN1ObjectIdentifier* oid)
	{
	return asn1_oid_to_val(oid->encoding());
	}

StringVal* asn1_oid_to_val(const ASN1Encoding* oid)
	{
	vector<uint64> oid_components;
	vector<vector<uint8> > subidentifiers;
	vector<uint64> subidentifier_values;
	vector<uint8> subidentifier;
	bytestring const& bs = oid->content();

	for ( int i = 0; i < bs.length(); ++i )
		{
		if ( bs[i] & 0x80 )
			subidentifier.push_back(bs[i] & 0x7f);
		else
			{
			subidentifier.push_back(bs[i]);
			subidentifiers.push_back(subidentifier);
			subidentifier.clear();
			}
		}

	if ( ! subidentifier.empty() || subidentifiers.size() < 1 )
		// Underflow.
		return new StringVal("");

	for ( size_t i = 0; i < subidentifiers.size(); ++i )
		{
		subidentifier = subidentifiers[i];
		uint64 value = 0;

		for ( size_t j = 0; j < subidentifier.size(); ++j )
			{
			uint64 byte = subidentifier[j];
			value |= byte << (7 * (subidentifier.size() - (j + 1)));
			}

		subidentifier_values.push_back(value);
		}

	string rval;

	for ( size_t i = 0; i < subidentifier_values.size(); ++i )
		{
		char tmp[32];

		if ( i > 0 )
			{
			rval += ".";
			snprintf(tmp, sizeof(tmp), "%" PRIu64, subidentifier_values[i]);
			rval += tmp;
			}
		else
			{
			std::div_t result = std::div(subidentifier_values[i], 40);
			snprintf(tmp, sizeof(tmp), "%d", result.quot);
			rval += tmp;
			rval += ".";
			snprintf(tmp, sizeof(tmp), "%d", result.rem);
			rval += tmp;
			}
		}

	return new StringVal(rval);
	}

StringVal* asn1_octet_string_to_val(const ASN1OctetString* s)
	{
	return asn1_octet_string_to_val(s->encoding());
	}

StringVal* asn1_octet_string_to_val(const ASN1Encoding* s)
	{
	bytestring const& bs = s->content();
	return new StringVal(bs.length(), reinterpret_cast<const char*>(bs.data()));
	}

NTLM_Flow::NTLM_Flow(NTLM_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

NTLM_Flow::~NTLM_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void NTLM_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new NTLM_SSP_Token(is_orig());
		context_ = new ContextNTLM(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void NTLM_Flow::NewGap(int gap_length)
	{
	}
void NTLM_Flow::FlowEOF()
	{
	}
} // namespace NTLM
}  // namespace binpac
