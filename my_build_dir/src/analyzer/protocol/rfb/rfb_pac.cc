// This file is automatically generated from /home/ubuntu/bro/src/analyzer/protocol/rfb/rfb.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/ubuntu/bro/my_build_dir/src/analyzer/protocol/rfb/rfb_pac.h"

namespace binpac {







namespace RFB {
ContextRFB::ContextRFB(RFB_Conn * connection, RFB_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextRFB::~ContextRFB()
	{
	}

RFB_Conn::RFB_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new RFB_Flow(this, true);
	downflow_ = new RFB_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

RFB_Conn::~RFB_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void RFB_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void RFB_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void RFB_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

int RFB_Conn::get_state(bool client)
	{

		return state;
		
	}

bool RFB_Conn::handle_banners(bool client, RFBProtocolVersion * msg)
	{

		if ( client )
			{
			// Set protocol version on client's version
			int minor_version = bytestring_to_int(msg->minor_ver(),10);
			version = minor_version;

			// Apple specifies minor version "889" but talks v37
			if ( minor_version >= 7 )
				state = AWAITING_SERVER_AUTH_TYPES37;
			else
				state = AWAITING_SERVER_AUTH_TYPES;
			}
			else
				state = AWAITING_CLIENT_BANNER;

		return true;
		
	}

bool RFB_Conn::handle_ard_challenge()
	{

		state = AWAITING_CLIENT_ARD_RESPONSE;
		return true;
		
	}

bool RFB_Conn::handle_ard_response()
	{

		state = AWAITING_SERVER_AUTH_RESULT;
		return true;
		
	}

bool RFB_Conn::handle_auth_request()
	{

		state = AWAITING_CLIENT_RESPONSE;
		return true;
		
	}

bool RFB_Conn::handle_auth_response()
	{

		state = AWAITING_SERVER_AUTH_RESULT;
		return true;
		
	}

bool RFB_Conn::handle_security_result(RFBSecurityResult * msg)
	{

		if ( msg->result() == 0 )
			{
			state = AWAITING_CLIENT_SHARE_FLAG;
			}
		return true;
		
	}

bool RFB_Conn::handle_client_init(RFBClientInit * msg)
	{

		state = AWAITING_SERVER_PARAMS;
		return true;
		
	}

bool RFB_Conn::handle_server_init(RFBServerInit * msg)
	{

		state = RFB_MESSAGE;
		return true;
		
	}

bool RFB_Conn::handle_security_types(RFBSecurityTypes * msg)
	{

		if ( msg->sectype() == 0 )
			{ // No auth
			state = AWAITING_CLIENT_SHARE_FLAG;
			return true;
			}

		if ( msg->sectype() == 2 )
			{ // VNC
			if ( msg->possible_challenge().length() == 16 )
				// Challenge was already sent with this message
				state = AWAITING_CLIENT_RESPONSE;
			else
				state = AWAITING_SERVER_CHALLENGE;
			}
		return true;
		
	}

bool RFB_Conn::handle_security_types37(RFBSecurityTypes37 * msg)
	{

		if ( msg->count() == 0 )
			{ // No auth
			state = AWAITING_CLIENT_SHARE_FLAG;
			return true;
			}
		state = AWAITING_CLIENT_AUTH_TYPE_SELECTED37;
		return true;
		
	}

bool RFB_Conn::handle_auth_type_selected(RFBAuthTypeSelected * msg)
	{

		if ( msg->type() == 30 )
			{ // Apple Remote Desktop
				state = AWAITING_SERVER_ARD_CHALLENGE;
				return true;
			}

		if ( msg->type() == 1 )
			{
				if ( version > 7 )
					state = AWAITING_SERVER_AUTH_RESULT;
				else
					state = AWAITING_CLIENT_SHARE_FLAG;
			}
		else
			state = AWAITING_SERVER_CHALLENGE;

		return true;
		
	}

RFBProtocolVersion::RFBProtocolVersion(bool client)
	{
	pad_ = 0;
	client_ = client;
	proc_ = 0;
	proc2_ = 0;
	}

RFBProtocolVersion::~RFBProtocolVersion()
	{
	header_.free();
	major_ver_.free();
	dot_.free();
	minor_ver_.free();
	}

int RFBProtocolVersion::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Checking out-of-bound for "RFBProtocolVersion:header"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBProtocolVersion:header",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	if ( memcmp(t_begin_of_data, "RFB ", 4) != 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:19", "RFB ", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	// check for negative sizes
	if ( 4 < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:19", 4);
	header_.init(t_begin_of_data, 4);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "major_ver"
	// Checking out-of-bound for "RFBProtocolVersion:major_ver"
	if ( (t_begin_of_data + 4) + (3) > t_end_of_data || (t_begin_of_data + 4) + (3) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBProtocolVersion:major_ver",
			(4) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 3;
	int t_major_ver_string_length;
	t_major_ver_string_length = 3;
	int t_major_ver__size;
	t_major_ver__size = t_major_ver_string_length;
	major_ver_.init((t_begin_of_data + 4), t_major_ver_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_major_ver = (t_begin_of_data + 4) + (3);
	BINPAC_ASSERT(t_dataptr_after_major_ver <= t_end_of_data);
	// Checking out-of-bound for "RFBProtocolVersion:dot"
	if ( t_dataptr_after_major_ver + (1) > t_end_of_data || t_dataptr_after_major_ver + (1) < t_dataptr_after_major_ver )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBProtocolVersion:dot",
			((t_dataptr_after_major_ver - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dot"
	if ( memcmp(t_dataptr_after_major_ver, ".", 1) != 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:21", ".", string((const char *) (t_dataptr_after_major_ver), (const char *) t_end_of_data).c_str());
		}
	// check for negative sizes
	if ( 1 < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:21", 1);
	dot_.init(t_dataptr_after_major_ver, 1);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "minor_ver"
	// Checking out-of-bound for "RFBProtocolVersion:minor_ver"
	if ( (t_dataptr_after_major_ver + 1) + (3) > t_end_of_data || (t_dataptr_after_major_ver + 1) + (3) < (t_dataptr_after_major_ver + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBProtocolVersion:minor_ver",
			(((t_dataptr_after_major_ver + 1) - t_begin_of_data)) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_major_ver + 1) + 3;
	int t_minor_ver_string_length;
	t_minor_ver_string_length = 3;
	int t_minor_ver__size;
	t_minor_ver__size = t_minor_ver_string_length;
	minor_ver_.init((t_dataptr_after_major_ver + 1), t_minor_ver_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_minor_ver = (t_dataptr_after_major_ver + 1) + (3);
	BINPAC_ASSERT(t_dataptr_after_minor_ver <= t_end_of_data);
	// Checking out-of-bound for "RFBProtocolVersion:pad"
	if ( t_dataptr_after_minor_ver + (1) > t_end_of_data || t_dataptr_after_minor_ver + (1) < t_dataptr_after_minor_ver )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBProtocolVersion:pad",
			((t_dataptr_after_minor_ver - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "pad"
	pad_ = *((uint8 const *) (t_dataptr_after_minor_ver));
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFBProtocolVersion__size;
	t_RFBProtocolVersion__size = (t_dataptr_after_minor_ver + 1) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_banners(client(), this);
	proc2_ = t_context->flow()->proc_rfb_version(client(), major_ver(), minor_ver());
	BINPAC_ASSERT(t_begin_of_data + (t_RFBProtocolVersion__size) <= t_end_of_data);
	return t_RFBProtocolVersion__size;
	}

RFBSecurityTypes::RFBSecurityTypes()
	{
	sectype_ = 0;
	proc_ = 0;
	proc2_ = 0;
	}

RFBSecurityTypes::~RFBSecurityTypes()
	{
	possible_challenge_.free();
	}

int RFBSecurityTypes::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "RFBSecurityTypes:sectype"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBSecurityTypes:sectype",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sectype"
	sectype_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "possible_challenge"
	int t_possible_challenge_string_length;
	t_possible_challenge_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
	int t_possible_challenge__size;
	t_possible_challenge__size = t_possible_challenge_string_length;
	// check for negative sizes
	if ( t_possible_challenge_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:31", t_possible_challenge_string_length);
	possible_challenge_.init((t_begin_of_data + 4), t_possible_challenge_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFBSecurityTypes__size;
	const_byteptr const t_dataptr_after_possible_challenge = (t_begin_of_data + 4) + (t_possible_challenge__size);
	BINPAC_ASSERT(t_dataptr_after_possible_challenge <= t_end_of_data);
	t_RFBSecurityTypes__size = t_dataptr_after_possible_challenge - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_security_types(this);
	proc2_ = t_context->flow()->proc_security_types(this);
	BINPAC_ASSERT(t_begin_of_data + (t_RFBSecurityTypes__size) <= t_end_of_data);
	return t_RFBSecurityTypes__size;
	}

RFBSecurityTypes37::RFBSecurityTypes37()
	{
	count_ = 0;
	types_ = 0;
	types__elem_ = 0;
	proc_ = 0;
	}

RFBSecurityTypes37::~RFBSecurityTypes37()
	{
	delete types_;
	}

int RFBSecurityTypes37::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Checking out-of-bound for "RFBSecurityTypes37:count"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBSecurityTypes37:count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "count"
	count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "types"
	int t_types__arraylength;
	t_types__arraylength = 0;
	t_types__arraylength = count();
	if ( t_begin_of_data + t_types__arraylength > t_end_of_data + 1 || t_begin_of_data + t_types__arraylength < t_begin_of_data )
		{
		t_types__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_types__arraylength < 0 )
		{
		t_types__arraylength = 0;
		}
	types__elem_ = 0;
	int t_types__elem__it;
	t_types__elem__it = 0;
	int t_types__size;
	types_ = new vector<uint8>;
	types_->reserve(t_types__arraylength);
	const_byteptr t_types__elem__dataptr = (t_begin_of_data + 1);
	for (; t_types__elem__it < t_types__arraylength; ++t_types__elem__it)
		{
		// Check &until(types__elem__dataptr >= end_of_data)
		if ( t_types__elem__dataptr >= t_end_of_data )
			{
			goto end_of_types;
			}
		// Checking out-of-bound for "RFBSecurityTypes37:types__elem"
		if ( t_types__elem__dataptr + (1) > t_end_of_data || t_types__elem__dataptr + (1) < t_types__elem__dataptr )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("RFBSecurityTypes37:types__elem",
				((t_types__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		types__elem_ = *((uint8 const *) (t_types__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		types_->push_back(types__elem_);
		t_types__elem__dataptr += 1;
		BINPAC_ASSERT(t_types__elem__dataptr <= t_end_of_data);
		}
end_of_types: ;
	t_types__size = t_types__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFBSecurityTypes37__size;
	const_byteptr const t_dataptr_after_types = (t_begin_of_data + 1) + (t_types__size);
	BINPAC_ASSERT(t_dataptr_after_types <= t_end_of_data);
	t_RFBSecurityTypes37__size = t_dataptr_after_types - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_security_types37(this);
	BINPAC_ASSERT(t_begin_of_data + (t_RFBSecurityTypes37__size) <= t_end_of_data);
	return t_RFBSecurityTypes37__size;
	}

RFBAuthTypeSelected::RFBAuthTypeSelected()
	{
	type_ = 0;
	proc_ = 0;
	proc2_ = 0;
	}

RFBAuthTypeSelected::~RFBAuthTypeSelected()
	{
	}

int RFBAuthTypeSelected::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Checking out-of-bound for "RFBAuthTypeSelected"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBAuthTypeSelected",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_auth_type_selected(this);
	proc2_ = t_context->flow()->proc_security_types37(this);
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

RFBSecurityResult::RFBSecurityResult()
	{
	result_ = 0;
	proc_ = 0;
	proc2_ = 0;
	}

RFBSecurityResult::~RFBSecurityResult()
	{
	}

int RFBSecurityResult::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "RFBSecurityResult"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBSecurityResult",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "result"
	result_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_security_result(this);
	proc2_ = t_context->flow()->proc_handle_security_result(result());
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

RFBSecurityResultReason::RFBSecurityResultReason()
	{
	len_ = 0;
	}

RFBSecurityResultReason::~RFBSecurityResultReason()
	{
	reason_.free();
	}

int RFBSecurityResultReason::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "RFBSecurityResultReason:len"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBSecurityResultReason:len",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "len"
	len_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reason"
	int t_reason__size;
	t_reason__size = len();
	// Checking out-of-bound for "RFBSecurityResultReason:reason"
	if ( (t_begin_of_data + 4) + (t_reason__size) > t_end_of_data || (t_begin_of_data + 4) + (t_reason__size) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBSecurityResultReason:reason",
			(4) + (t_reason__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_reason__size;
	int t_reason_string_length;
	t_reason_string_length = len();
	// check for negative sizes
	if ( t_reason_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:60", t_reason_string_length);
	reason_.init((t_begin_of_data + 4), t_reason_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_RFBSecurityResultReason__size;
	const_byteptr const t_dataptr_after_reason = (t_begin_of_data + 4) + (t_reason__size);
	BINPAC_ASSERT(t_dataptr_after_reason <= t_end_of_data);
	t_RFBSecurityResultReason__size = t_dataptr_after_reason - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_RFBSecurityResultReason__size) <= t_end_of_data);
	return t_RFBSecurityResultReason__size;
	}

RFBVNCAuthenticationRequest::RFBVNCAuthenticationRequest()
	{
	proc_ = 0;
	}

RFBVNCAuthenticationRequest::~RFBVNCAuthenticationRequest()
	{
	challenge_.free();
	}

int RFBVNCAuthenticationRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Parse "challenge"
	// Checking out-of-bound for "RFBVNCAuthenticationRequest:challenge"
	if ( t_begin_of_data + (16) > t_end_of_data || t_begin_of_data + (16) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBVNCAuthenticationRequest:challenge",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 16;
	int t_challenge_string_length;
	t_challenge_string_length = 16;
	int t_challenge__size;
	t_challenge__size = t_challenge_string_length;
	challenge_.init(t_begin_of_data, t_challenge_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_RFBVNCAuthenticationRequest__size;
	const_byteptr const t_dataptr_after_challenge = t_begin_of_data + (16);
	BINPAC_ASSERT(t_dataptr_after_challenge <= t_end_of_data);
	t_RFBVNCAuthenticationRequest__size = t_dataptr_after_challenge - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_auth_request();
	BINPAC_ASSERT(t_begin_of_data + (t_RFBVNCAuthenticationRequest__size) <= t_end_of_data);
	return t_RFBVNCAuthenticationRequest__size;
	}

RFBVNCAuthenticationResponse::RFBVNCAuthenticationResponse()
	{
	proc_ = 0;
	}

RFBVNCAuthenticationResponse::~RFBVNCAuthenticationResponse()
	{
	response_.free();
	}

int RFBVNCAuthenticationResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Parse "response"
	// Checking out-of-bound for "RFBVNCAuthenticationResponse:response"
	if ( t_begin_of_data + (16) > t_end_of_data || t_begin_of_data + (16) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBVNCAuthenticationResponse:response",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 16;
	int t_response_string_length;
	t_response_string_length = 16;
	int t_response__size;
	t_response__size = t_response_string_length;
	response_.init(t_begin_of_data, t_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_RFBVNCAuthenticationResponse__size;
	const_byteptr const t_dataptr_after_response = t_begin_of_data + (16);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	t_RFBVNCAuthenticationResponse__size = t_dataptr_after_response - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_auth_response();
	BINPAC_ASSERT(t_begin_of_data + (t_RFBVNCAuthenticationResponse__size) <= t_end_of_data);
	return t_RFBVNCAuthenticationResponse__size;
	}

RFBSecurityARDChallenge::RFBSecurityARDChallenge()
	{
	proc_ = 0;
	}

RFBSecurityARDChallenge::~RFBSecurityARDChallenge()
	{
	challenge_.free();
	}

int RFBSecurityARDChallenge::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Parse "challenge"
	int t_challenge_string_length;
	t_challenge_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_challenge__size;
	t_challenge__size = t_challenge_string_length;
	// check for negative sizes
	if ( t_challenge_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:76", t_challenge_string_length);
	challenge_.init(t_begin_of_data, t_challenge_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFBSecurityARDChallenge__size;
	const_byteptr const t_dataptr_after_challenge = t_begin_of_data + (t_challenge__size);
	BINPAC_ASSERT(t_dataptr_after_challenge <= t_end_of_data);
	t_RFBSecurityARDChallenge__size = t_dataptr_after_challenge - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_ard_challenge();
	BINPAC_ASSERT(t_begin_of_data + (t_RFBSecurityARDChallenge__size) <= t_end_of_data);
	return t_RFBSecurityARDChallenge__size;
	}

RFBSecurityARDResponse::RFBSecurityARDResponse()
	{
	proc_ = 0;
	}

RFBSecurityARDResponse::~RFBSecurityARDResponse()
	{
	response_.free();
	}

int RFBSecurityARDResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Parse "response"
	int t_response_string_length;
	t_response_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_response__size;
	t_response__size = t_response_string_length;
	// check for negative sizes
	if ( t_response_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:82", t_response_string_length);
	response_.init(t_begin_of_data, t_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFBSecurityARDResponse__size;
	const_byteptr const t_dataptr_after_response = t_begin_of_data + (t_response__size);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	t_RFBSecurityARDResponse__size = t_dataptr_after_response - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_ard_response();
	BINPAC_ASSERT(t_begin_of_data + (t_RFBSecurityARDResponse__size) <= t_end_of_data);
	return t_RFBSecurityARDResponse__size;
	}

RFBClientInit::RFBClientInit()
	{
	shared_flag_ = 0;
	proc_ = 0;
	proc2_ = 0;
	}

RFBClientInit::~RFBClientInit()
	{
	}

int RFBClientInit::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Checking out-of-bound for "RFBClientInit"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBClientInit",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "shared_flag"
	shared_flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_client_init(this);
	proc2_ = t_context->flow()->proc_rfb_share_flag(shared_flag());
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

RFBServerInit::RFBServerInit()
	{
	width_ = 0;
	height_ = 0;
	len_ = 0;
	proc_ = 0;
	proc2_ = 0;
	}

RFBServerInit::~RFBServerInit()
	{
	pixel_format_.free();
	name_.free();
	}

int RFBServerInit::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "RFBServerInit:height"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBServerInit:height",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "width"
	width_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "height"
	height_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pixel_format"
	// Checking out-of-bound for "RFBServerInit:pixel_format"
	if ( (t_begin_of_data + 4) + (16) > t_end_of_data || (t_begin_of_data + 4) + (16) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBServerInit:pixel_format",
			(4) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 16;
	int t_pixel_format_string_length;
	t_pixel_format_string_length = 16;
	int t_pixel_format__size;
	t_pixel_format__size = t_pixel_format_string_length;
	pixel_format_.init((t_begin_of_data + 4), t_pixel_format_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_pixel_format = (t_begin_of_data + 4) + (16);
	BINPAC_ASSERT(t_dataptr_after_pixel_format <= t_end_of_data);
	// Checking out-of-bound for "RFBServerInit:len"
	if ( t_dataptr_after_pixel_format + (4) > t_end_of_data || t_dataptr_after_pixel_format + (4) < t_dataptr_after_pixel_format )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBServerInit:len",
			((t_dataptr_after_pixel_format - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "len"
	len_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_pixel_format)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name"
	int t_name__size;
	t_name__size = len();
	// Checking out-of-bound for "RFBServerInit:name"
	if ( (t_dataptr_after_pixel_format + 4) + (t_name__size) > t_end_of_data || (t_dataptr_after_pixel_format + 4) + (t_name__size) < (t_dataptr_after_pixel_format + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RFBServerInit:name",
			(((t_dataptr_after_pixel_format + 4) - t_begin_of_data)) + (t_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_pixel_format + 4) + t_name__size;
	int t_name_string_length;
	t_name_string_length = len();
	// check for negative sizes
	if ( t_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:99", t_name_string_length);
	name_.init((t_dataptr_after_pixel_format + 4), t_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_RFBServerInit__size;
	const_byteptr const t_dataptr_after_name = (t_dataptr_after_pixel_format + 4) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_RFBServerInit__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->handle_server_init(this);
	proc2_ = t_context->flow()->proc_handle_server_params(this);
	BINPAC_ASSERT(t_begin_of_data + (t_RFBServerInit__size) <= t_end_of_data);
	return t_RFBServerInit__size;
	}

RFB_PDU_request::RFB_PDU_request()
	{
	request_case_index_ = -1;
	version_ = 0;
	response_ = 0;
	shareflag_ = 0;
	authtype_ = 0;
	ard_response_ = 0;
	state_ = 0;
	}

RFB_PDU_request::~RFB_PDU_request()
	{
	switch ( request_case_index() )
		{
		case 1:
			// Clean up "version"
			{
			delete version_;
			version_ = 0;
			}
			break;
		case 4:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		case 6:
			// Clean up "shareflag"
			{
			delete shareflag_;
			shareflag_ = 0;
			}
			break;
		case 12:
			// Clean up "authtype"
			{
			delete authtype_;
			authtype_ = 0;
			}
			break;
		case 10:
			// Clean up "ard_response"
			{
			delete ard_response_;
			ard_response_ = 0;
			}
			break;
		case 13:
			// Clean up "ignore"
			{
			}
			break;
		default:
			// Clean up "data"
			{
			}
			break;
		}
	}

int RFB_PDU_request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Parse "request"
	state_ = t_context->connection()->get_state(true);
	int t_request__size;
	request_case_index_ = state();
	switch ( request_case_index() )
		{
		case 1:
			// Parse "version"
			{
			version_ = new RFBProtocolVersion(true);
			int t_version__size;
			t_version__size = version_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_version__size;
			}
			break;
		case 4:
			// Parse "response"
			{
			response_ = new RFBVNCAuthenticationResponse();
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_response__size;
			}
			break;
		case 6:
			// Parse "shareflag"
			{
			shareflag_ = new RFBClientInit();
			shareflag_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = 1;
			}
			break;
		case 12:
			// Parse "authtype"
			{
			authtype_ = new RFBAuthTypeSelected();
			authtype_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = 1;
			}
			break;
		case 10:
			// Parse "ard_response"
			{
			ard_response_ = new RFBSecurityARDResponse();
			int t_ard_response__size;
			t_ard_response__size = ard_response_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_ard_response__size;
			}
			break;
		case 13:
			// Parse "ignore"
			{
			int t_ignore_string_length;
			t_ignore_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_ignore__size;
			t_ignore__size = t_ignore_string_length;
			// check for negative sizes
			if ( t_ignore_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:112", t_ignore_string_length);
			ignore_.init(t_begin_of_data, t_ignore_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_ignore__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:113", t_data_string_length);
			data_.init(t_begin_of_data, t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFB_PDU_request__size;
	const_byteptr const t_dataptr_after_request = t_begin_of_data + (t_request__size);
	BINPAC_ASSERT(t_dataptr_after_request <= t_end_of_data);
	t_RFB_PDU_request__size = t_dataptr_after_request - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_RFB_PDU_request__size) <= t_end_of_data);
	return t_RFB_PDU_request__size;
	}

RFB_PDU_response::RFB_PDU_response()
	{
	request_case_index_ = -1;
	version_ = 0;
	auth_types_ = 0;
	auth_types37_ = 0;
	challenge_ = 0;
	authresult_ = 0;
	ard_challenge_ = 0;
	serverinit_ = 0;
	rstate_ = 0;
	}

RFB_PDU_response::~RFB_PDU_response()
	{
	switch ( request_case_index() )
		{
		case 0:
			// Clean up "version"
			{
			delete version_;
			version_ = 0;
			}
			break;
		case 2:
			// Clean up "auth_types"
			{
			delete auth_types_;
			auth_types_ = 0;
			}
			break;
		case 11:
			// Clean up "auth_types37"
			{
			delete auth_types37_;
			auth_types37_ = 0;
			}
			break;
		case 3:
			// Clean up "challenge"
			{
			delete challenge_;
			challenge_ = 0;
			}
			break;
		case 5:
			// Clean up "authresult"
			{
			delete authresult_;
			authresult_ = 0;
			}
			break;
		case 9:
			// Clean up "ard_challenge"
			{
			delete ard_challenge_;
			ard_challenge_ = 0;
			}
			break;
		case 7:
			// Clean up "serverinit"
			{
			delete serverinit_;
			serverinit_ = 0;
			}
			break;
		case 13:
			// Clean up "ignore"
			{
			}
			break;
		default:
			// Clean up "data"
			{
			}
			break;
		}
	}

int RFB_PDU_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context, int t_byteorder)
	{
	// Parse "request"
	rstate_ = t_context->connection()->get_state(false);
	int t_request__size;
	request_case_index_ = rstate();
	switch ( request_case_index() )
		{
		case 0:
			// Parse "version"
			{
			version_ = new RFBProtocolVersion(false);
			int t_version__size;
			t_version__size = version_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_version__size;
			}
			break;
		case 2:
			// Parse "auth_types"
			{
			auth_types_ = new RFBSecurityTypes();
			int t_auth_types__size;
			t_auth_types__size = auth_types_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_auth_types__size;
			}
			break;
		case 11:
			// Parse "auth_types37"
			{
			auth_types37_ = new RFBSecurityTypes37();
			int t_auth_types37__size;
			t_auth_types37__size = auth_types37_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_auth_types37__size;
			}
			break;
		case 3:
			// Parse "challenge"
			{
			challenge_ = new RFBVNCAuthenticationRequest();
			int t_challenge__size;
			t_challenge__size = challenge_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_challenge__size;
			}
			break;
		case 5:
			// Parse "authresult"
			{
			authresult_ = new RFBSecurityResult();
			authresult_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = 4;
			}
			break;
		case 9:
			// Parse "ard_challenge"
			{
			ard_challenge_ = new RFBSecurityARDChallenge();
			int t_ard_challenge__size;
			t_ard_challenge__size = ard_challenge_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_ard_challenge__size;
			}
			break;
		case 7:
			// Parse "serverinit"
			{
			serverinit_ = new RFBServerInit();
			int t_serverinit__size;
			t_serverinit__size = serverinit_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_serverinit__size;
			}
			break;
		case 13:
			// Parse "ignore"
			{
			int t_ignore_string_length;
			t_ignore_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_ignore__size;
			t_ignore__size = t_ignore_string_length;
			// check for negative sizes
			if ( t_ignore_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:128", t_ignore_string_length);
			ignore_.init(t_begin_of_data, t_ignore_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_ignore__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ubuntu/bro/src/analyzer/protocol/rfb/rfb-protocol.pac:129", t_data_string_length);
			data_.init(t_begin_of_data, t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_request__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFB_PDU_response__size;
	const_byteptr const t_dataptr_after_request = t_begin_of_data + (t_request__size);
	BINPAC_ASSERT(t_dataptr_after_request <= t_end_of_data);
	t_RFB_PDU_response__size = t_dataptr_after_request - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_RFB_PDU_response__size) <= t_end_of_data);
	return t_RFB_PDU_response__size;
	}

RFB_PDU::RFB_PDU(bool is_orig)
	{
	payload_case_index_ = -1;
	request_ = 0;
	response_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	proc_ = 0;
	}

RFB_PDU::~RFB_PDU()
	{
	switch ( payload_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		}
	}

int RFB_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRFB * t_context)
	{
	// Parse "payload"
	int t_payload__size;
	payload_case_index_ = is_orig();
	switch ( payload_case_index() )
		{
		case 1:
			// Parse "request"
			{
			request_ = new RFB_PDU_request();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_payload__size = t_request__size;
			}
			break;
		case 0:
			// Parse "response"
			{
			response_ = new RFB_PDU_response();
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data, t_context, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_payload__size = t_response__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("RFB_PDU", payload_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_RFB_PDU__size;
	const_byteptr const t_dataptr_after_payload = t_begin_of_data + (t_payload__size);
	BINPAC_ASSERT(t_dataptr_after_payload <= t_end_of_data);
	t_RFB_PDU__size = t_dataptr_after_payload - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_rfb_message(this);
	BINPAC_ASSERT(t_begin_of_data + (t_RFB_PDU__size) <= t_end_of_data);
	return t_RFB_PDU__size;
	}

RFB_Flow::RFB_Flow(RFB_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

RFB_Flow::~RFB_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void RFB_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new RFB_PDU(is_orig());
		context_ = new ContextRFB(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void RFB_Flow::NewGap(int gap_length)
	{
	}
void RFB_Flow::FlowEOF()
	{
	}
bool RFB_Flow::proc_rfb_message(RFB_PDU * msg)
	{

		BifEvent::generate_rfb_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn());
		return true;
		
	}

bool RFB_Flow::proc_rfb_version(bool client, bytestring const & major, bytestring const & minor)
	{

		if (client)
			{
			BifEvent::generate_rfb_client_version(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), bytestring_to_val(major), bytestring_to_val(minor));

			connection()->bro_analyzer()->ProtocolConfirmation();
			}
			else
			{
			BifEvent::generate_rfb_server_version(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), bytestring_to_val(major), bytestring_to_val(minor));
			}
		return true;
		
	}

bool RFB_Flow::proc_rfb_share_flag(bool shared)
	{

		BifEvent::generate_rfb_share_flag(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), shared);
		return true;
		
	}

bool RFB_Flow::proc_security_types(RFBSecurityTypes * msg)
	{

		BifEvent::generate_rfb_authentication_type(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), msg->sectype());
		return true;
		
	}

bool RFB_Flow::proc_security_types37(RFBAuthTypeSelected * msg)
	{

		BifEvent::generate_rfb_authentication_type(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), msg->type());
		return true;
		
	}

bool RFB_Flow::proc_handle_server_params(RFBServerInit * msg)
	{

		BifEvent::generate_rfb_server_parameters(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), bytestring_to_val(msg->name()), msg->width(), msg->height());
		return true;
		
	}

bool RFB_Flow::proc_handle_security_result(uint32 result)
	{

		BifEvent::generate_rfb_auth_result(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), result);
		return true;
		
	}

} // namespace RFB
}  // namespace binpac
