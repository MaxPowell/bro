// This file was automatically generated by bifcl from option.bif.


#line 6 "option.bif"

#include "NetVar.h"

#line 22 "option.bif"
Val* BifFunc::Option::bro_set(Frame* frame, val_list* BiF_ARGS)
	
#line 23 "option.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("Option::set() takes exactly 3 argument(s)");
		return 0;
		}
	StringVal* ID = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	Val* val = (Val*) ((*BiF_ARGS)[1]);
	StringVal* location = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());

#line 23 "option.bif"

	auto i = global_scope()->Lookup(ID->CheckString());
	if ( ! i )
		{
		builtin_error(fmt("Could not find ID named '%s'", ID->CheckString()));
		return new Val(0, TYPE_BOOL);
		}

	if ( ! i->HasVal() )
		{
		// should be impossible because initialization is enforced
		builtin_error(fmt("ID '%s' has no value", ID->CheckString()));
		return new Val(0, TYPE_BOOL);
		}

	if ( ! i->IsOption() )
		{
		builtin_error(fmt("ID '%s' is not an option", ID->CheckString()));
		return new Val(0, TYPE_BOOL);
		}

	if ( ! same_type(i->Type(), val->Type()) )
		{
		builtin_error(fmt("Incompatible type for set of ID '%s': got '%s', need '%s'",
			ID->CheckString(), type_name(val->Type()->Tag()), type_name(i->Type()->Tag())));
		}

	val->Ref();
	if ( i->HasOptionHandlers() )
		{
		for ( auto handler_function : i->GetOptionHandlers() )
			{
			val_list vl(2);
			vl.append(ID->Ref());
			vl.append(val);
			if ( handler_function->FType()->AsFuncType()->ArgTypes()->Types()->length() == 3 )
				vl.append(location->Ref());

			val = handler_function->Call(&vl); // consumed by next call.
			if ( ! val )
				{
				// Someone messed up, don't change value and just return
				return new Val(0, TYPE_BOOL);
				}
			}
		}

	// clone to prevent changes
	i->SetVal(val->Clone());
	Unref(val); // Either ref'd once or function call result.
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::Option::bro_set

#line 74 "option.bif"

#line 100 "option.bif"
Val* BifFunc::Option::bro_set_change_handler(Frame* frame, val_list* BiF_ARGS)
	
#line 101 "option.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("Option::set_change_handler() takes exactly 3 argument(s)");
		return 0;
		}
	StringVal* ID = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	Val* on_change = (Val*) ((*BiF_ARGS)[1]);
	bro_int_t priority = (bro_int_t) ((*BiF_ARGS)[2]->AsInt());

#line 101 "option.bif"

	auto i = global_scope()->Lookup(ID->CheckString());
	if ( ! i )
		{
		builtin_error(fmt("Could not find ID named '%s'", ID->CheckString()));
		return new Val(0, TYPE_BOOL);
		}

	if ( ! i->IsOption() )
		{
		builtin_error(fmt("ID '%s' is not an option", ID->CheckString()));
		return new Val(0, TYPE_BOOL);
		}

	if ( on_change->Type()->Tag() != TYPE_FUNC )
		{
		builtin_error(fmt("Option::on_change needs function argument; got '%s' for ID '%s'",
			type_name(on_change->Type()->Tag()), ID->CheckString()));
		return new Val(0, TYPE_BOOL);
		}

	if ( on_change->Type()->AsFuncType()->Flavor() != FUNC_FLAVOR_FUNCTION )
		{
		builtin_error("Option::on_change needs function argument; not hook or event");
		return new Val(0, TYPE_BOOL);
		}

	const type_list* args = on_change->Type()->AsFuncType()->ArgTypes()->Types();
	if ( args->length() < 2 || args->length() > 3 )
		{
		builtin_error(fmt("Wrong number of arguments for passed function in Option::on_change for ID '%s'; expected 2 or 3, got %d",
			ID->CheckString(), args->length()));
		return new Val(0, TYPE_BOOL);
		}

	if ( (*args)[0]->Tag() != TYPE_STRING )
		{
		builtin_error(fmt("First argument of passed function has to be string in Option::on_change for ID '%s'; got '%s'",
			ID->CheckString(), type_name((*args)[0]->Tag())));
		return new Val(0, TYPE_BOOL);
		}

	if ( ! same_type((*args)[1], i->Type()) )
		{
		builtin_error(fmt("Second argument of passed function has to be %s in Option::on_change for ID '%s'; got '%s'",
			type_name(i->Type()->Tag()), ID->CheckString(), type_name((*args)[1]->Tag())));
		return new Val(0, TYPE_BOOL);
		}

	if ( args->length() == 3 && (*args)[2]->Tag() != TYPE_STRING )
		{
		builtin_error(fmt("Third argument of passed function has to be string in Option::on_change for ID '%s'; got '%s'",
			ID->CheckString(), type_name((*args)[2]->Tag())));
		return new Val(0, TYPE_BOOL);
		}

	if ( ! same_type(on_change->Type()->AsFuncType()->YieldType(), i->Type()) )
		{
		builtin_error(fmt("Passed function needs to return type '%s' for ID '%s'; got '%s'",
			type_name(i->Type()->Tag()), ID->CheckString(), type_name(on_change->Type()->AsFuncType()->YieldType()->Tag())));
		return new Val(0, TYPE_BOOL);
		}

	i->AddOptionHandler(on_change->Ref()->AsFunc(), -priority);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::Option::bro_set_change_handler

#line 166 "option.bif"
