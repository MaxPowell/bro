// This file was automatically generated by bifcl from /home/ubuntu/bro/src/file_analysis/analyzer/x509/ocsp_events.bif (plugin mode).


#include "ocsp_events.bif.h"

EventHandlerPtr ocsp_request; 
void BifEvent::generate_ocsp_request(analyzer::Analyzer* analyzer, Val* f, bro_uint_t version, StringVal* requestorName)
	{
	// Note that it is intentional that here we do not
	// check if ::ocsp_request is NULL, which should happen *before*
	// BifEvent::generate_ocsp_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(new Val(version, TYPE_COUNT));
	vl->append(requestorName);

	mgr.QueueEvent(::ocsp_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
EventHandlerPtr ocsp_request_certificate; 
void BifEvent::generate_ocsp_request_certificate(analyzer::Analyzer* analyzer, Val* f, StringVal* hashAlgorithm, StringVal* issuerNameHash, StringVal* issuerKeyHash, StringVal* serialNumber)
	{
	// Note that it is intentional that here we do not
	// check if ::ocsp_request_certificate is NULL, which should happen *before*
	// BifEvent::generate_ocsp_request_certificate is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(hashAlgorithm);
	vl->append(issuerNameHash);
	vl->append(issuerKeyHash);
	vl->append(serialNumber);

	mgr.QueueEvent(::ocsp_request_certificate, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
EventHandlerPtr ocsp_response_status; 
void BifEvent::generate_ocsp_response_status(analyzer::Analyzer* analyzer, Val* f, StringVal* status)
	{
	// Note that it is intentional that here we do not
	// check if ::ocsp_response_status is NULL, which should happen *before*
	// BifEvent::generate_ocsp_response_status is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(status);

	mgr.QueueEvent(::ocsp_response_status, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
EventHandlerPtr ocsp_response_bytes; 
void BifEvent::generate_ocsp_response_bytes(analyzer::Analyzer* analyzer, Val* f, Val* resp_ref, StringVal* status, bro_uint_t version, StringVal* responderId, double producedAt, StringVal* signatureAlgorithm, Val* certs)
	{
	// Note that it is intentional that here we do not
	// check if ::ocsp_response_bytes is NULL, which should happen *before*
	// BifEvent::generate_ocsp_response_bytes is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(resp_ref);
	vl->append(status);
	vl->append(new Val(version, TYPE_COUNT));
	vl->append(responderId);
	vl->append(new Val(producedAt, TYPE_TIME));
	vl->append(signatureAlgorithm);
	vl->append(certs);

	mgr.QueueEvent(::ocsp_response_bytes, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
EventHandlerPtr ocsp_response_certificate; 
void BifEvent::generate_ocsp_response_certificate(analyzer::Analyzer* analyzer, Val* f, StringVal* hashAlgorithm, StringVal* issuerNameHash, StringVal* issuerKeyHash, StringVal* serialNumber, StringVal* certStatus, double revokeTime, StringVal* revokeReason, double thisUpdate, double nextUpdate)
	{
	// Note that it is intentional that here we do not
	// check if ::ocsp_response_certificate is NULL, which should happen *before*
	// BifEvent::generate_ocsp_response_certificate is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(hashAlgorithm);
	vl->append(issuerNameHash);
	vl->append(issuerKeyHash);
	vl->append(serialNumber);
	vl->append(certStatus);
	vl->append(new Val(revokeTime, TYPE_TIME));
	vl->append(revokeReason);
	vl->append(new Val(thisUpdate, TYPE_TIME));
	vl->append(new Val(nextUpdate, TYPE_TIME));

	mgr.QueueEvent(::ocsp_response_certificate, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
EventHandlerPtr ocsp_extension; 
void BifEvent::generate_ocsp_extension(analyzer::Analyzer* analyzer, Val* f, Val* ext, int global_resp)
	{
	// Note that it is intentional that here we do not
	// check if ::ocsp_extension is NULL, which should happen *before*
	// BifEvent::generate_ocsp_extension is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(ext);
	vl->append(new Val(global_resp, TYPE_BOOL));

	mgr.QueueEvent(::ocsp_extension, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
