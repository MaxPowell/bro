// This file was automatically generated by bifcl from bro.bif.


#line 10 "bro.bif"
 // C segment
#include <math.h>
#include <vector>
#include <algorithm>
#include <cmath>
#include <sys/stat.h>
#include <cstdio>
#include <time.h>

#include "digest.h"
#include "Reporter.h"
#include "IPAddr.h"
#include "util.h"
#include "file_analysis/Manager.h"
#include "iosource/Manager.h"
#include "iosource/Packet.h"

using namespace std;

TableType* var_sizes;

static iosource::PktDumper* addl_pkt_dumper = 0;

bro_int_t parse_int(const char*& fmt)
	{
	bro_int_t k = 0;
	while ( isdigit(*fmt) )
		{
		k = k * 10 + (*fmt - '0');
		++fmt;
		}

	return k;
	}

static TypeTag ok_d_fmt[] = {
	TYPE_BOOL, TYPE_ENUM, TYPE_INT, TYPE_COUNT, TYPE_COUNTER, TYPE_PORT,
	TYPE_SUBNET,
	TYPE_ERROR
};
static TypeTag ok_f_fmt[] = {
	TYPE_DOUBLE, TYPE_TIME, TYPE_INTERVAL,
	TYPE_ERROR
};

static int check_fmt_type(TypeTag t, TypeTag ok[])
	{
	for ( int i = 0; ok[i] != TYPE_ERROR; ++i )
		if ( ok[i] == t )
			return 1;

	return 0;
	}

static void do_fmt(const char*& fmt, Val* v, ODesc* d)
	{
	TypeTag t = v->Type()->Tag();
	InternalTypeTag it = v->Type()->InternalType();

	bool zero_pad = false;
	bool left_just = false;
	int field_width = -1;

	// Left-align, if requested.
	if ( *fmt == '-' )
		{
		left_just = true;
		++fmt;
		}

	// Parse field width, if given.
	if ( isdigit(*fmt) )
		{
		// If field width starts with zero, do zero-padding.
		if ( *fmt == '0' )
			{
			zero_pad = true;
			++fmt;
			}

		field_width = parse_int(fmt);
		}

	int precision = -1;
	if ( *fmt == '.' )
		{
		++fmt;
		precision = parse_int(fmt);
		}

	if ( field_width > 128 || precision > 128 )
		{
		builtin_error("excessive field width or precision");
		return;
		}

	// Create the numerical format string.
	char num_fmt[64];
	num_fmt[0] = '\0';

	if ( field_width >= 0 )
		{
		// Like sprintf(), ignore '0' if '-' is given.
		const char* align = left_just ? "-" : (zero_pad ? "0" : "");
		snprintf(num_fmt, sizeof(num_fmt), "%s%d", align, field_width);
		}

	if ( precision >= 0 )
		snprintf(num_fmt + strlen(num_fmt),
			sizeof(num_fmt) - strlen(num_fmt), ".%d", precision);

	char fmt_buf[512];
	char out_buf[512];

	ODesc s;
	s.SetStyle(RAW_STYLE);

	if ( precision >= 0 && *fmt != 'e' && *fmt != 'f' && *fmt != 'g' )
		builtin_error("precision specified for non-floating point");

	switch ( *fmt ) {
	case 'D':
	case 'T':	// ISO Timestamp with microsecond precision.
		{
		if ( t != TYPE_TIME )
			{
			builtin_error("bad type for Date/Time format", v);
			break;
			}

		time_t time = time_t(v->InternalDouble());
		struct tm t;

		int is_time_fmt = *fmt == 'T';

		if ( ! localtime_r(&time, &t) )
			s.AddSP("<problem getting time>");

		if ( ! strftime(out_buf, sizeof(out_buf),
				is_time_fmt ?
					"%Y-%m-%d-%H:%M" : "%Y-%m-%d-%H:%M:%S",
				&t) )
			s.AddSP("<bad time>");

		else
			{
			s.Add(out_buf);

			if ( is_time_fmt )
				{
				double secs = v->CoerceToUnsigned() % 60;

				secs += v->InternalDouble();
				secs -= v->CoerceToUnsigned();

				snprintf(out_buf, sizeof(out_buf),
					":%012.9f", secs);
				s.Add(out_buf);
				}
			}
		}
		break;

	case 'd':
	case 'x':
		{
		if ( *fmt == 'x' && it == TYPE_INTERNAL_ADDR )
			{
			// Deficiency: we don't support num_fmt in this case.
			// This makes only a very slight difference, so not
			// clear it would e worth the hassle.

			snprintf(out_buf, sizeof(out_buf), "%s",
			         v->AsAddr().AsHexString().c_str());
			}

		else if ( ! check_fmt_type(t, ok_d_fmt) )
			{
			builtin_error("bad type for %d/%x format", v);
			break;
			}

		else if ( it == TYPE_INTERNAL_UNSIGNED )
			{
			bro_uint_t u = v->CoerceToUnsigned();

			if ( v->Type()->IsNetworkOrder() )
				{
				if ( v->Type()->Tag() == TYPE_PORT )
					u = v->AsPortVal()->Port();
				else
					u = ntohl(uint32(u));
				}

			snprintf(fmt_buf, sizeof(fmt_buf), "%%%s%s", num_fmt,
					*fmt == 'd' ? "llu" : "llx");
			snprintf(out_buf, sizeof(out_buf), fmt_buf, u);
			}

		else
			{
			snprintf(fmt_buf, sizeof(fmt_buf), "%%%s%s", num_fmt,
					*fmt == 'd' ? "lld" : "llx");
			snprintf(out_buf, sizeof(out_buf), fmt_buf,
					v->CoerceToInt());
			}

		s.Add(out_buf);
		}
		break;

	case 's':
		v->Describe(&s);
		break;

	case 'e':
	case 'f':
	case 'g':
		{
		if ( ! check_fmt_type(t, ok_f_fmt) )
			{
			builtin_error("bad type for floating-point format", v);
			break;
			}

		snprintf(fmt_buf, sizeof(fmt_buf), "%%%s%c", num_fmt, *fmt);
		snprintf(out_buf, sizeof(out_buf), fmt_buf, v->CoerceToDouble());
		s.Add(out_buf);
		}
		break;

	default:
		builtin_error("bad format");
	}

	// Left-padding with whitespace, if any.
	if ( field_width > 0 && ! left_just )
		{
		int sl = strlen(s.Description());
		while ( ++sl <= field_width )
			d->Add(" ");
		}

	d->AddN((const char*)(s.Bytes()), s.Len());

	// Right-padding with whitespace, if any.
	if ( field_width > 0 && left_just )
		{
		int sl = s.Len();
		while ( ++sl <= field_width )
			d->Add(" ");
		}

	++fmt;
	}

static int next_fmt(const char*& fmt, val_list* args, ODesc* d, int& n)
	{
	const char* fp = fmt;

	// Skip up to next format indicator.
	while ( *fp && *fp != '%' )
		++fp;

	d->AddN(fmt, fp - fmt);

	if ( *fp == '\0' )
		// No more to do.
		return 0;

	fmt = fp + 1;
	if ( *fmt == '%' )
		{
		// "%%" -> '%'
		d->Add("%");
		++fmt;
		return next_fmt(fmt, args, d, n);
		}

	if ( ++n >= args->length() )
		return 0;

	do_fmt(fmt, (*args)[n], d);

	return *fmt != '\0';
	}

#line 315 "bro.bif"
Val* BifFunc::bro_current_time(Frame* frame, val_list* BiF_ARGS)
	
#line 316 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("current_time() takes exactly 0 argument(s)");
		return 0;
		}

#line 316 "bro.bif"

	return new Val(current_time(), TYPE_TIME);
	} // end of BifFunc::bro_current_time

#line 318 "bro.bif"

#line 327 "bro.bif"
Val* BifFunc::bro_network_time(Frame* frame, val_list* BiF_ARGS)
	
#line 328 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("network_time() takes exactly 0 argument(s)");
		return 0;
		}

#line 328 "bro.bif"

	return new Val(network_time, TYPE_TIME);
	} // end of BifFunc::bro_network_time

#line 330 "bro.bif"

#line 340 "bro.bif"
Val* BifFunc::bro_getenv(Frame* frame, val_list* BiF_ARGS)
	
#line 341 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("getenv() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* var = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 341 "bro.bif"

	const char* env_val = getenv(var->CheckString());
	if ( ! env_val )
		env_val = "";	// ###
	return new StringVal(env_val);
	} // end of BifFunc::bro_getenv

#line 346 "bro.bif"

#line 357 "bro.bif"
Val* BifFunc::bro_setenv(Frame* frame, val_list* BiF_ARGS)
	
#line 358 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("setenv() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* var = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* val = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 358 "bro.bif"

	int result = setenv(var->AsString()->CheckString(),
	                    val->AsString()->CheckString(), 1);

	if ( result < 0 )
		return new Val(0, TYPE_BOOL);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_setenv

#line 365 "bro.bif"

#line 372 "bro.bif"
Val* BifFunc::bro_exit(Frame* frame, val_list* BiF_ARGS)
	
#line 373 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("exit() takes exactly 1 argument(s)");
		return 0;
		}
	bro_int_t code = (bro_int_t) ((*BiF_ARGS)[0]->AsInt());

#line 373 "bro.bif"

	exit(code);
	return 0;
	} // end of BifFunc::bro_exit

#line 376 "bro.bif"

#line 384 "bro.bif"
Val* BifFunc::bro_terminate(Frame* frame, val_list* BiF_ARGS)
	
#line 385 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("terminate() takes exactly 0 argument(s)");
		return 0;
		}

#line 385 "bro.bif"

	if ( terminating )
		return new Val(0, TYPE_BOOL);

	terminate_processing();
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_terminate

#line 391 "bro.bif"

#line 393 "bro.bif"

// Turns the table into environment variables (if 'set' is true) or removes
// all environment variables previously generated from this table (if 'set'
// is false).
static bool prepare_environment(TableVal* tbl, bool set)
	{
	ListVal* idxs = tbl->ConvertToPureList();

	for ( int i = 0; i < idxs->Length(); ++i )
		{
		Val* key = idxs->Index(i);
		Val* val = tbl->Lookup(key, false);

		if ( key->Type()->Tag() != TYPE_STRING ||
		     val->Type()->Tag() != TYPE_STRING )
			{
			builtin_error("system_env() needs a table[string] of string");
			return false;
			}

		char* tmp = copy_string(key->AsString()->CheckString());
		to_upper(tmp);
		const char* var = fmt("BRO_ARG_%s", tmp);
		delete [] tmp;

		if ( set )
			setenv(var, val->AsString()->CheckString(), 1);
		else
			unsetenv(var);
		}

	return true;
	}

static int do_system(const char* s)
	{
	const char* system_fmt = "(%s) 1>&2 &";	// output to stderr
	char* cmd = new char[strlen(system_fmt) + strlen(s) + 1];

	sprintf(cmd, system_fmt, s);
	int status = system(cmd);
	delete [] cmd;

	return status;
	}

#line 457 "bro.bif"
Val* BifFunc::bro_system(Frame* frame, val_list* BiF_ARGS)
	
#line 458 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("system() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 458 "bro.bif"

	int result = do_system(str->CheckString());
	return new Val(result, TYPE_INT);
	} // end of BifFunc::bro_system

#line 461 "bro.bif"

#line 476 "bro.bif"
Val* BifFunc::bro_system_env(Frame* frame, val_list* BiF_ARGS)
	
#line 477 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("system_env() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	Val* env = (Val*) ((*BiF_ARGS)[1]);

#line 477 "bro.bif"

	if ( env->Type()->Tag() != TYPE_TABLE )
		{
		builtin_error("system_env() requires a table argument");
		return new Val(-1, TYPE_INT);
		}

	if ( ! prepare_environment(env->AsTableVal(), true) )
		return new Val(-1, TYPE_INT);

	int result = do_system(str->CheckString());

	prepare_environment(env->AsTableVal(), false);

	return new Val(result, TYPE_INT);
	} // end of BifFunc::bro_system_env

#line 492 "bro.bif"

#line 504 "bro.bif"
Val* BifFunc::bro_piped_exec(Frame* frame, val_list* BiF_ARGS)
	
#line 505 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("piped_exec() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* program = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* to_write = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 505 "bro.bif"

	const char* prog = program->CheckString();

	FILE* f = popen(prog, "w");
	if ( ! f )
		{
		reporter->Error("Failed to popen %s", prog);
		return new Val(0, TYPE_BOOL);
		}

	const u_char* input_data = to_write->Bytes();
	int input_data_len = to_write->Len();

	int bytes_written = fwrite(input_data, 1, input_data_len, f);

	pclose(f);

	if ( bytes_written != input_data_len )
		{
		reporter->Error("Failed to write all given data to %s", prog);
		return new Val(0, TYPE_BOOL);
		}

	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_piped_exec

#line 529 "bro.bif"

#line 531 "bro.bif"

#include "OpaqueVal.h"

#line 548 "bro.bif"
Val* BifFunc::bro_md5_hash(Frame* frame, val_list* BiF_ARGS)
	
#line 549 "bro.bif"
{
#line 549 "bro.bif"

	unsigned char digest[MD5_DIGEST_LENGTH];
	MD5Val::digest((*BiF_ARGS), digest);
	return new StringVal(md5_digest_print(digest));
	} // end of BifFunc::bro_md5_hash

#line 553 "bro.bif"

#line 568 "bro.bif"
Val* BifFunc::bro_sha1_hash(Frame* frame, val_list* BiF_ARGS)
	
#line 569 "bro.bif"
{
#line 569 "bro.bif"

	unsigned char digest[SHA_DIGEST_LENGTH];
	SHA1Val::digest((*BiF_ARGS), digest);
	return new StringVal(sha1_digest_print(digest));
	} // end of BifFunc::bro_sha1_hash

#line 573 "bro.bif"

#line 588 "bro.bif"
Val* BifFunc::bro_sha256_hash(Frame* frame, val_list* BiF_ARGS)
	
#line 589 "bro.bif"
{
#line 589 "bro.bif"

	unsigned char digest[SHA256_DIGEST_LENGTH];
	SHA256Val::digest((*BiF_ARGS), digest);
	return new StringVal(sha256_digest_print(digest));
	} // end of BifFunc::bro_sha256_hash

#line 593 "bro.bif"

#line 604 "bro.bif"
Val* BifFunc::bro_md5_hmac(Frame* frame, val_list* BiF_ARGS)
	
#line 605 "bro.bif"
{
#line 605 "bro.bif"

	unsigned char hmac[MD5_DIGEST_LENGTH];
	MD5Val::hmac((*BiF_ARGS), shared_hmac_md5_key, hmac);
	return new StringVal(md5_digest_print(hmac));
	} // end of BifFunc::bro_md5_hmac

#line 609 "bro.bif"

#line 629 "bro.bif"
Val* BifFunc::bro_md5_hash_init(Frame* frame, val_list* BiF_ARGS)
	
#line 630 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("md5_hash_init() takes exactly 0 argument(s)");
		return 0;
		}

#line 630 "bro.bif"

	HashVal* digest = new MD5Val();
	digest->Init();
	return digest;
	} // end of BifFunc::bro_md5_hash_init

#line 634 "bro.bif"

#line 654 "bro.bif"
Val* BifFunc::bro_sha1_hash_init(Frame* frame, val_list* BiF_ARGS)
	
#line 655 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("sha1_hash_init() takes exactly 0 argument(s)");
		return 0;
		}

#line 655 "bro.bif"

	HashVal* digest = new SHA1Val();
	digest->Init();
	return digest;
	} // end of BifFunc::bro_sha1_hash_init

#line 659 "bro.bif"

#line 679 "bro.bif"
Val* BifFunc::bro_sha256_hash_init(Frame* frame, val_list* BiF_ARGS)
	
#line 680 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("sha256_hash_init() takes exactly 0 argument(s)");
		return 0;
		}

#line 680 "bro.bif"

	HashVal* digest = new SHA256Val();
	digest->Init();
	return digest;
	} // end of BifFunc::bro_sha256_hash_init

#line 684 "bro.bif"

#line 699 "bro.bif"
Val* BifFunc::bro_md5_hash_update(Frame* frame, val_list* BiF_ARGS)
	
#line 700 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("md5_hash_update() takes exactly 2 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);
	StringVal* data = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 700 "bro.bif"

	bool rc = static_cast<HashVal*>(handle)->Feed(data->Bytes(), data->Len());
	return new Val(rc, TYPE_BOOL);
	} // end of BifFunc::bro_md5_hash_update

#line 703 "bro.bif"

#line 718 "bro.bif"
Val* BifFunc::bro_sha1_hash_update(Frame* frame, val_list* BiF_ARGS)
	
#line 719 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("sha1_hash_update() takes exactly 2 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);
	StringVal* data = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 719 "bro.bif"

	bool rc = static_cast<HashVal*>(handle)->Feed(data->Bytes(), data->Len());
	return new Val(rc, TYPE_BOOL);
	} // end of BifFunc::bro_sha1_hash_update

#line 722 "bro.bif"

#line 737 "bro.bif"
Val* BifFunc::bro_sha256_hash_update(Frame* frame, val_list* BiF_ARGS)
	
#line 738 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("sha256_hash_update() takes exactly 2 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);
	StringVal* data = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 738 "bro.bif"

	bool rc = static_cast<HashVal*>(handle)->Feed(data->Bytes(), data->Len());
	return new Val(rc, TYPE_BOOL);
	} // end of BifFunc::bro_sha256_hash_update

#line 741 "bro.bif"

#line 752 "bro.bif"
Val* BifFunc::bro_md5_hash_finish(Frame* frame, val_list* BiF_ARGS)
	
#line 753 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("md5_hash_finish() takes exactly 1 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);

#line 753 "bro.bif"

	return static_cast<HashVal*>(handle)->Get();
	} // end of BifFunc::bro_md5_hash_finish

#line 755 "bro.bif"

#line 766 "bro.bif"
Val* BifFunc::bro_sha1_hash_finish(Frame* frame, val_list* BiF_ARGS)
	
#line 767 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("sha1_hash_finish() takes exactly 1 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);

#line 767 "bro.bif"

	return static_cast<HashVal*>(handle)->Get();
	} // end of BifFunc::bro_sha1_hash_finish

#line 769 "bro.bif"

#line 780 "bro.bif"
Val* BifFunc::bro_sha256_hash_finish(Frame* frame, val_list* BiF_ARGS)
	
#line 781 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("sha256_hash_finish() takes exactly 1 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);

#line 781 "bro.bif"

	return static_cast<HashVal*>(handle)->Get();
	} // end of BifFunc::bro_sha256_hash_finish

#line 783 "bro.bif"

#line 797 "bro.bif"
Val* BifFunc::bro_rand(Frame* frame, val_list* BiF_ARGS)
	
#line 798 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("rand() takes exactly 1 argument(s)");
		return 0;
		}
	bro_uint_t max = (bro_uint_t) ((*BiF_ARGS)[0]->AsCount());

#line 798 "bro.bif"

	auto result = bro_uint_t(double(max) * double(bro_random()) / (RAND_MAX + 1.0));
	return new Val(result, TYPE_COUNT);
	} // end of BifFunc::bro_rand

#line 801 "bro.bif"

#line 813 "bro.bif"
Val* BifFunc::bro_srand(Frame* frame, val_list* BiF_ARGS)
	
#line 814 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("srand() takes exactly 1 argument(s)");
		return 0;
		}
	bro_uint_t seed = (bro_uint_t) ((*BiF_ARGS)[0]->AsCount());

#line 814 "bro.bif"

	bro_srandom(seed);
	return 0;
	} // end of BifFunc::bro_srand

#line 817 "bro.bif"

#line 819 "bro.bif"

#include <syslog.h>

#line 826 "bro.bif"
Val* BifFunc::bro_syslog(Frame* frame, val_list* BiF_ARGS)
	
#line 827 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("syslog() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 827 "bro.bif"

	reporter->Syslog("%s", s->CheckString());
	return 0;
	} // end of BifFunc::bro_syslog

#line 830 "bro.bif"

#line 844 "bro.bif"
Val* BifFunc::bro_identify_data(Frame* frame, val_list* BiF_ARGS)
	
#line 845 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("identify_data() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* data = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	int return_mime = (int) ((*BiF_ARGS)[1]->AsBool());

#line 845 "bro.bif"

	if ( ! return_mime )
		reporter->Warning("identify_data() builtin-function only returns MIME types, but verbose file info requested");

	string strongest_match = file_mgr->DetectMIME(data->Bytes(), data->Len());

	if ( strongest_match.empty() )
		return new StringVal("<unknown>");

	return new StringVal(strongest_match);
	} // end of BifFunc::bro_identify_data

#line 855 "bro.bif"

#line 865 "bro.bif"
Val* BifFunc::bro_file_magic(Frame* frame, val_list* BiF_ARGS)
	
#line 866 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("file_magic() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* data = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 866 "bro.bif"

	RuleMatcher::MIME_Matches matches;
	file_mgr->DetectMIME(data->Bytes(), data->Len(), &matches);
	return file_analysis::GenMIMEMatchesVal(matches);
	} // end of BifFunc::bro_file_magic

#line 870 "bro.bif"

#line 912 "bro.bif"
Val* BifFunc::bro_find_entropy(Frame* frame, val_list* BiF_ARGS)
	
#line 913 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("find_entropy() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* data = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 913 "bro.bif"

	double montepi, scc, ent, mean, chisq;
	montepi = scc = ent = mean = chisq = 0.0;
	EntropyVal e;
	e.Feed(data->Bytes(), data->Len());
	e.Get(&ent, &chisq, &mean, &montepi, &scc);

	RecordVal* ent_result = new RecordVal(entropy_test_result);
	ent_result->Assign(0, new Val(ent,     TYPE_DOUBLE));
	ent_result->Assign(1, new Val(chisq,   TYPE_DOUBLE));
	ent_result->Assign(2, new Val(mean,    TYPE_DOUBLE));
	ent_result->Assign(3, new Val(montepi, TYPE_DOUBLE));
	ent_result->Assign(4, new Val(scc,     TYPE_DOUBLE));
	return ent_result;
	} // end of BifFunc::bro_find_entropy

#line 927 "bro.bif"

#line 934 "bro.bif"
Val* BifFunc::bro_entropy_test_init(Frame* frame, val_list* BiF_ARGS)
	
#line 935 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("entropy_test_init() takes exactly 0 argument(s)");
		return 0;
		}

#line 935 "bro.bif"

	return new EntropyVal();
	} // end of BifFunc::bro_entropy_test_init

#line 937 "bro.bif"

#line 948 "bro.bif"
Val* BifFunc::bro_entropy_test_add(Frame* frame, val_list* BiF_ARGS)
	
#line 949 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("entropy_test_add() takes exactly 2 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);
	StringVal* data = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 949 "bro.bif"

	bool status = static_cast<EntropyVal*>(handle)->Feed(data->Bytes(),
	                                                     data->Len());
	return new Val(status, TYPE_BOOL);
	} // end of BifFunc::bro_entropy_test_add

#line 953 "bro.bif"

#line 965 "bro.bif"
Val* BifFunc::bro_entropy_test_finish(Frame* frame, val_list* BiF_ARGS)
	
#line 966 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("entropy_test_finish() takes exactly 1 argument(s)");
		return 0;
		}
	Val* handle = (Val*) ((*BiF_ARGS)[0]);

#line 966 "bro.bif"

	double montepi, scc, ent, mean, chisq;
	montepi = scc = ent = mean = chisq = 0.0;
	static_cast<EntropyVal*>(handle)->Get(&ent, &chisq, &mean, &montepi, &scc);

	RecordVal* ent_result = new RecordVal(entropy_test_result);
	ent_result->Assign(0, new Val(ent,     TYPE_DOUBLE));
	ent_result->Assign(1, new Val(chisq,   TYPE_DOUBLE));
	ent_result->Assign(2, new Val(mean,    TYPE_DOUBLE));
	ent_result->Assign(3, new Val(montepi, TYPE_DOUBLE));
	ent_result->Assign(4, new Val(scc,     TYPE_DOUBLE));
	return ent_result;
	} // end of BifFunc::bro_entropy_test_finish

#line 978 "bro.bif"

#line 987 "bro.bif"
Val* BifFunc::bro_unique_id(Frame* frame, val_list* BiF_ARGS) 
	
#line 988 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("unique_id() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* prefix = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 988 "bro.bif"

	char tmp[20];
	uint64 uid = calculate_unique_id(UID_POOL_DEFAULT_SCRIPT);
	return new StringVal(uitoa_n(uid, tmp, sizeof(tmp), 62, prefix->CheckString()));
	} // end of BifFunc::bro_unique_id

#line 992 "bro.bif"

#line 1003 "bro.bif"
Val* BifFunc::bro_unique_id_from(Frame* frame, val_list* BiF_ARGS) 
	
#line 1004 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("unique_id_from() takes exactly 2 argument(s)");
		return 0;
		}
	bro_int_t pool = (bro_int_t) ((*BiF_ARGS)[0]->AsInt());
	StringVal* prefix = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 1004 "bro.bif"

	pool += UID_POOL_CUSTOM_SCRIPT; // Make sure we don't conflict with internal pool.

	char tmp[20];
	uint64 uid = calculate_unique_id(pool);
	return new StringVal(uitoa_n(uid, tmp, sizeof(tmp), 62, prefix->CheckString()));
	} // end of BifFunc::bro_unique_id_from

#line 1010 "bro.bif"

#line 1021 "bro.bif"
Val* BifFunc::bro_clear_table(Frame* frame, val_list* BiF_ARGS)
	
#line 1022 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("clear_table() takes exactly 1 argument(s)");
		return 0;
		}
	Val* v = (Val*) ((*BiF_ARGS)[0]);

#line 1022 "bro.bif"

	if ( v->Type()->Tag() == TYPE_TABLE )
		v->AsTableVal()->RemoveAll();
	else
		builtin_error("clear_table() requires a table/set argument");

	return 0;
	} // end of BifFunc::bro_clear_table

#line 1029 "bro.bif"

#line 1038 "bro.bif"
Val* BifFunc::bro_matching_subnets(Frame* frame, val_list* BiF_ARGS)
	
#line 1039 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("matching_subnets() takes exactly 2 argument(s)");
		return 0;
		}
	SubNetVal* search = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());
	Val* t = (Val*) ((*BiF_ARGS)[1]);

#line 1039 "bro.bif"

	if ( t->Type()->Tag() != TYPE_TABLE || ! t->Type()->AsTableType()->IsSubNetIndex() )
		{
		reporter->Error("matching_subnets needs to be called on a set[subnet]/table[subnet].");
		return nullptr;
		}

	return t->AsTableVal()->LookupSubnets(search);
	} // end of BifFunc::bro_matching_subnets

#line 1047 "bro.bif"

#line 1057 "bro.bif"
Val* BifFunc::bro_filter_subnet_table(Frame* frame, val_list* BiF_ARGS)
	
#line 1058 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("filter_subnet_table() takes exactly 2 argument(s)");
		return 0;
		}
	SubNetVal* search = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());
	Val* t = (Val*) ((*BiF_ARGS)[1]);

#line 1058 "bro.bif"

	if ( t->Type()->Tag() != TYPE_TABLE || ! t->Type()->AsTableType()->IsSubNetIndex() )
		{
		reporter->Error("filter_subnet_table needs to be called on a set[subnet]/table[subnet].");
		return nullptr;
		}

	return t->AsTableVal()->LookupSubnetValues(search);
	} // end of BifFunc::bro_filter_subnet_table

#line 1066 "bro.bif"

#line 1077 "bro.bif"
Val* BifFunc::bro_check_subnet(Frame* frame, val_list* BiF_ARGS)
	
#line 1078 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("check_subnet() takes exactly 2 argument(s)");
		return 0;
		}
	SubNetVal* search = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());
	Val* t = (Val*) ((*BiF_ARGS)[1]);

#line 1078 "bro.bif"

	if ( t->Type()->Tag() != TYPE_TABLE || ! t->Type()->AsTableType()->IsSubNetIndex() )
		{
		reporter->Error("check_subnet needs to be called on a set[subnet]/table[subnet].");
		return nullptr;
		}

	const PrefixTable* pt = t->AsTableVal()->Subnets();
	if ( ! pt )
		{
		reporter->Error("check_subnet encountered nonexisting prefix table.");
		return nullptr;
		}

	void* res = pt->Lookup(search, true);

	return new Val (res != nullptr, TYPE_BOOL);
	} // end of BifFunc::bro_check_subnet

#line 1095 "bro.bif"

#line 1106 "bro.bif"
Val* BifFunc::bro_same_object(Frame* frame, val_list* BiF_ARGS)
	
#line 1107 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("same_object() takes exactly 2 argument(s)");
		return 0;
		}
	Val* o1 = (Val*) ((*BiF_ARGS)[0]);
	Val* o2 = (Val*) ((*BiF_ARGS)[1]);

#line 1107 "bro.bif"

	return new Val(o1 == o2, TYPE_BOOL);
	} // end of BifFunc::bro_same_object

#line 1109 "bro.bif"

#line 1116 "bro.bif"
Val* BifFunc::bro_val_size(Frame* frame, val_list* BiF_ARGS)
	
#line 1117 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("val_size() takes exactly 1 argument(s)");
		return 0;
		}
	Val* v = (Val*) ((*BiF_ARGS)[0]);

#line 1117 "bro.bif"

	return new Val(v->MemoryAllocation(), TYPE_COUNT);
	} // end of BifFunc::bro_val_size

#line 1119 "bro.bif"

#line 1128 "bro.bif"
Val* BifFunc::bro_resize(Frame* frame, val_list* BiF_ARGS) 
	
#line 1129 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("resize() takes exactly 2 argument(s)");
		return 0;
		}
	Val* aggr = (Val*) ((*BiF_ARGS)[0]);
	bro_uint_t newsize = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());

#line 1129 "bro.bif"

	if ( aggr->Type()->Tag() != TYPE_VECTOR )
		{
		builtin_error("resize() operates on vectors");
		return 0;
		}

	return new Val(aggr->AsVectorVal()->Resize(newsize), TYPE_COUNT);
	} // end of BifFunc::bro_resize

#line 1137 "bro.bif"

#line 1147 "bro.bif"
Val* BifFunc::bro_any_set(Frame* frame, val_list* BiF_ARGS) 
	
#line 1148 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("any_set() takes exactly 1 argument(s)");
		return 0;
		}
	Val* v = (Val*) ((*BiF_ARGS)[0]);

#line 1148 "bro.bif"

	if ( v->Type()->Tag() != TYPE_VECTOR ||
	     v->Type()->YieldType()->Tag() != TYPE_BOOL )
		{
		builtin_error("any_set() requires vector of bool");
		return new Val(false, TYPE_BOOL);
		}

	VectorVal* vv = v->AsVectorVal();
	for ( unsigned int i = 0; i < vv->Size(); ++i )
		if ( vv->Lookup(i) && vv->Lookup(i)->AsBool() )
			return new Val(true, TYPE_BOOL);

	return new Val(false, TYPE_BOOL);
	} // end of BifFunc::bro_any_set

#line 1162 "bro.bif"

#line 1176 "bro.bif"
Val* BifFunc::bro_all_set(Frame* frame, val_list* BiF_ARGS) 
	
#line 1177 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("all_set() takes exactly 1 argument(s)");
		return 0;
		}
	Val* v = (Val*) ((*BiF_ARGS)[0]);

#line 1177 "bro.bif"

	if ( v->Type()->Tag() != TYPE_VECTOR ||
	     v->Type()->YieldType()->Tag() != TYPE_BOOL )
		{
		builtin_error("all_set() requires vector of bool");
		return new Val(false, TYPE_BOOL);
		}

	VectorVal* vv = v->AsVectorVal();
	for ( unsigned int i = 0; i < vv->Size(); ++i )
		if ( ! vv->Lookup(i) || ! vv->Lookup(i)->AsBool() )
			return new Val(false, TYPE_BOOL);

	return new Val(true, TYPE_BOOL);
	} // end of BifFunc::bro_all_set

#line 1191 "bro.bif"

#line 1193 "bro.bif"

static Func* sort_function_comp = 0;
static Val** index_map = 0;	// used for indirect sorting to support order()

bool sort_function(Val* a, Val* b)
	{
	// Sort missing values as "high".
	if ( ! a )
		return 0;
	if ( ! b )
		return 1;

	val_list sort_func_args;
	sort_func_args.append(a->Ref());
	sort_func_args.append(b->Ref());

	Val* result = sort_function_comp->Call(&sort_func_args);
	int int_result = result->CoerceToInt();
	Unref(result);

	return int_result < 0;
	}

bool indirect_sort_function(size_t a, size_t b)
	{
	return sort_function(index_map[a], index_map[b]);
	}

bool signed_sort_function (Val* a, Val* b)
	{
	if ( ! a )
		return 0;
	if ( ! b )
		return 1;

	auto ia = a->CoerceToInt();
	auto ib = b->CoerceToInt();

	return ia < ib;
	}

bool unsigned_sort_function (Val* a, Val* b)
	{
	if ( ! a )
		return 0;
	if ( ! b )
		return 1;

	auto ia = a->CoerceToUnsigned();
	auto ib = b->CoerceToUnsigned();

	return ia < ib;
	}

bool indirect_signed_sort_function(size_t a, size_t b)
	{
	return signed_sort_function(index_map[a], index_map[b]);
	}

bool indirect_unsigned_sort_function(size_t a, size_t b)
	{
	return unsigned_sort_function(index_map[a], index_map[b]);
	}

#line 1271 "bro.bif"
Val* BifFunc::bro_sort(Frame* frame, val_list* BiF_ARGS) 
	
#line 1272 "bro.bif"
{
	if ( BiF_ARGS->length() < 1 )
		{
		reporter->Error("sort() takes at least 1 argument(s)");
		return 0;
		}
	Val* v = (Val*) ((*BiF_ARGS)[0]);

#line 1272 "bro.bif"

	v->Ref();	// we always return v

	if ( v->Type()->Tag() != TYPE_VECTOR )
		{
		builtin_error("sort() requires vector");
		return v;
		}

	BroType* elt_type = v->Type()->YieldType();
	Func* comp = 0;

	if ( (*BiF_ARGS).length() > 2 )
		builtin_error("sort() called with extraneous argument");

	if ( (*BiF_ARGS).length() == 2 )
		{
		Val* comp_val = (*BiF_ARGS)[1];
		if ( ! IsFunc(comp_val->Type()->Tag()) )
			{
			builtin_error("second argument to sort() needs to be comparison function");
			return v;
			}

		comp = comp_val->AsFunc();
		}

	if ( ! comp && ! IsIntegral(elt_type->Tag()) )
		builtin_error("comparison function required for sort() with non-integral types");

	vector<Val*>& vv = *v->AsVector();

	if ( comp )
		{
		FuncType* comp_type = comp->FType()->AsFuncType();
		if ( comp_type->YieldType()->Tag() != TYPE_INT ||
		     ! comp_type->ArgTypes()->AllMatch(elt_type, 0) )
			{
			builtin_error("invalid comparison function in call to sort()");
			return v;
			}

		sort_function_comp = comp;

		sort(vv.begin(), vv.end(), sort_function);
		}
	else
		{
		if ( elt_type->InternalType() == TYPE_INTERNAL_UNSIGNED )
			sort(vv.begin(), vv.end(), unsigned_sort_function);
		else
			sort(vv.begin(), vv.end(), signed_sort_function);
		}

	return v;
	} // end of BifFunc::bro_sort

#line 1327 "bro.bif"

#line 1340 "bro.bif"
Val* BifFunc::bro_order(Frame* frame, val_list* BiF_ARGS) 
	
#line 1341 "bro.bif"
{
	if ( BiF_ARGS->length() < 1 )
		{
		reporter->Error("order() takes at least 1 argument(s)");
		return 0;
		}
	Val* v = (Val*) ((*BiF_ARGS)[0]);

#line 1341 "bro.bif"

	VectorVal* result_v = new VectorVal(
	    internal_type("index_vec")->AsVectorType());

	if ( v->Type()->Tag() != TYPE_VECTOR )
		{
		builtin_error("order() requires vector");
		return result_v;
		}

	BroType* elt_type = v->Type()->YieldType();
	Func* comp = 0;

	if ( (*BiF_ARGS).length() > 2 )
		builtin_error("order() called with extraneous argument");

	if ( (*BiF_ARGS).length() == 2 )
		{
		Val* comp_val = (*BiF_ARGS)[1];
		if ( ! IsFunc(comp_val->Type()->Tag()) )
			{
			builtin_error("second argument to order() needs to be comparison function");
			return v;
			}

		comp = comp_val->AsFunc();
		}

	if ( ! comp && ! IsIntegral(elt_type->Tag()) )
		builtin_error("comparison function required for order() with non-integral types");

	vector<Val*>& vv = *v->AsVector();
	auto n = vv.size();

	// Set up initial mapping of indices directly to corresponding
	// elements.
	vector<size_t> ind_vv(n);
	index_map = new Val*[n];
	size_t i;
	for ( i = 0; i < n; ++i )
		{
		ind_vv[i] = i;
		index_map[i] = vv[i];
		}

	if ( comp )
		{
		FuncType* comp_type = comp->FType()->AsFuncType();
		if ( comp_type->YieldType()->Tag() != TYPE_INT ||
		     ! comp_type->ArgTypes()->AllMatch(elt_type, 0) )
			{
			builtin_error("invalid comparison function in call to order()");
			return v;
			}

		sort_function_comp = comp;

		sort(ind_vv.begin(), ind_vv.end(), indirect_sort_function);
		}
	else
		{
		if ( elt_type->InternalType() == TYPE_INTERNAL_UNSIGNED )
			sort(ind_vv.begin(), ind_vv.end(), indirect_unsigned_sort_function);
		else
			sort(ind_vv.begin(), ind_vv.end(), indirect_signed_sort_function);
		}

	delete [] index_map;
	index_map = 0;

	// Now spin through ind_vv to read out the rearrangement.
	for ( i = 0; i < n; ++i )
		{
		int ind = ind_vv[i];
		result_v->Assign(i, new Val(ind, TYPE_COUNT));
		}

	return result_v;
	} // end of BifFunc::bro_order

#line 1419 "bro.bif"

#line 1432 "bro.bif"
Val* BifFunc::bro_cat(Frame* frame, val_list* BiF_ARGS)
	
#line 1433 "bro.bif"
{
#line 1433 "bro.bif"

	ODesc d;
	d.SetStyle(RAW_STYLE);

	loop_over_list((*BiF_ARGS), i)
		(*BiF_ARGS)[i]->Describe(&d);

	BroString* s = new BroString(1, d.TakeBytes(), d.Len());
	s->SetUseFreeToDelete(true);

	return new StringVal(s);
	} // end of BifFunc::bro_cat

#line 1444 "bro.bif"

#line 1459 "bro.bif"
Val* BifFunc::bro_cat_sep(Frame* frame, val_list* BiF_ARGS)
	
#line 1460 "bro.bif"
{
	if ( BiF_ARGS->length() < 2 )
		{
		reporter->Error("cat_sep() takes at least 2 argument(s)");
		return 0;
		}
	StringVal* sep = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* def = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 1460 "bro.bif"

	ODesc d;
	d.SetStyle(RAW_STYLE);

	int pre_size = 0;

	loop_over_list((*BiF_ARGS), i)
		{
		// Skip named parameters.
		if ( i < 2 )
			continue;

		if ( i > 2 )
			d.Add(sep->CheckString(), 0);

		Val* v = (*BiF_ARGS)[i];
		if ( v->Type()->Tag() == TYPE_STRING && ! v->AsString()->Len() )
			v = def;

		v->Describe(&d);
		}

	BroString* s = new BroString(1, d.TakeBytes(), d.Len());
	s->SetUseFreeToDelete(true);

	return new StringVal(s);
	} // end of BifFunc::bro_cat_sep

#line 1486 "bro.bif"

#line 1526 "bro.bif"
Val* BifFunc::bro_fmt(Frame* frame, val_list* BiF_ARGS)
	
#line 1527 "bro.bif"
{
#line 1527 "bro.bif"

	if ( BiF_ARGS->length() == 0 )
		return new StringVal("");

	Val* fmt_v = (*BiF_ARGS)[0];

	// Type of fmt_v will be string here, check_built_in_call() in Func.cc
	// checks that.

	const char* fmt = fmt_v->AsString()->CheckString();
	ODesc d;
	d.SetStyle(RAW_STYLE);

	int n = 0;

	while ( next_fmt(fmt, BiF_ARGS, &d, n) )
		;

	if ( n < BiF_ARGS->length() - 1 )
		{
		builtin_error("too many arguments for format", fmt_v);
		return new StringVal("");
		}

	else if ( n >= BiF_ARGS->length() )
		{
		builtin_error("too few arguments for format", fmt_v);
		return new StringVal("");
		}

	BroString* s = new BroString(1, d.TakeBytes(), d.Len());
	s->SetUseFreeToDelete(true);

	return new StringVal(s);
	} // end of BifFunc::bro_fmt

#line 1561 "bro.bif"

#line 1578 "bro.bif"
Val* BifFunc::bro_floor(Frame* frame, val_list* BiF_ARGS)
	
#line 1579 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("floor() takes exactly 1 argument(s)");
		return 0;
		}
	double d = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 1579 "bro.bif"

	return new Val(floor(d), TYPE_DOUBLE);
	} // end of BifFunc::bro_floor

#line 1581 "bro.bif"

#line 1590 "bro.bif"
Val* BifFunc::bro_sqrt(Frame* frame, val_list* BiF_ARGS)
	
#line 1591 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("sqrt() takes exactly 1 argument(s)");
		return 0;
		}
	double x = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 1591 "bro.bif"

	if ( x < 0 )
		{
		reporter->Error("negative sqrt argument");
		return new Val(-1.0, TYPE_DOUBLE);
		}

	return new Val(sqrt(x), TYPE_DOUBLE);
	} // end of BifFunc::bro_sqrt

#line 1599 "bro.bif"

#line 1608 "bro.bif"
Val* BifFunc::bro_exp(Frame* frame, val_list* BiF_ARGS)
	
#line 1609 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("exp() takes exactly 1 argument(s)");
		return 0;
		}
	double d = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 1609 "bro.bif"

	return new Val(exp(d), TYPE_DOUBLE);
	} // end of BifFunc::bro_exp

#line 1611 "bro.bif"

#line 1620 "bro.bif"
Val* BifFunc::bro_ln(Frame* frame, val_list* BiF_ARGS)
	
#line 1621 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("ln() takes exactly 1 argument(s)");
		return 0;
		}
	double d = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 1621 "bro.bif"

	return new Val(log(d), TYPE_DOUBLE);
	} // end of BifFunc::bro_ln

#line 1623 "bro.bif"

#line 1632 "bro.bif"
Val* BifFunc::bro_log10(Frame* frame, val_list* BiF_ARGS)
	
#line 1633 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("log10() takes exactly 1 argument(s)");
		return 0;
		}
	double d = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 1633 "bro.bif"

	return new Val(log10(d), TYPE_DOUBLE);
	} // end of BifFunc::bro_log10

#line 1635 "bro.bif"

#line 1651 "bro.bif"
Val* BifFunc::bro_is_external_connection(Frame* frame, val_list* BiF_ARGS) 
	
#line 1652 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_external_connection() takes exactly 1 argument(s)");
		return 0;
		}
	Connection* c = (Connection*) ((*BiF_ARGS)[0]->AsRecordVal()->GetOrigin());

#line 1652 "bro.bif"

	return new Val(c && c->IsExternal(), TYPE_BOOL);
	} // end of BifFunc::bro_is_external_connection

#line 1654 "bro.bif"

#line 1660 "bro.bif"
Val* BifFunc::bro_current_analyzer(Frame* frame, val_list* BiF_ARGS) 
	
#line 1661 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("current_analyzer() takes exactly 0 argument(s)");
		return 0;
		}

#line 1661 "bro.bif"

	return new Val(mgr.CurrentAnalyzer(), TYPE_COUNT);
	} // end of BifFunc::bro_current_analyzer

#line 1663 "bro.bif"

#line 1668 "bro.bif"
Val* BifFunc::bro_getpid(Frame* frame, val_list* BiF_ARGS) 
	
#line 1669 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("getpid() takes exactly 0 argument(s)");
		return 0;
		}

#line 1669 "bro.bif"

	return new Val(getpid(), TYPE_COUNT);
	} // end of BifFunc::bro_getpid

#line 1671 "bro.bif"

#line 1673 "bro.bif"

extern const char* bro_version();

#line 1680 "bro.bif"
Val* BifFunc::bro_bro_version(Frame* frame, val_list* BiF_ARGS)
	
#line 1681 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("bro_version() takes exactly 0 argument(s)");
		return 0;
		}

#line 1681 "bro.bif"

	return new StringVal(bro_version());
	} // end of BifFunc::bro_bro_version

#line 1683 "bro.bif"

#line 1691 "bro.bif"
Val* BifFunc::bro_record_type_to_vector(Frame* frame, val_list* BiF_ARGS)
	
#line 1692 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("record_type_to_vector() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* rt = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 1692 "bro.bif"

	VectorVal* result =
		new VectorVal(internal_type("string_vec")->AsVectorType());

	RecordType *type = internal_type(rt->CheckString())->AsRecordType();

	if ( type )
		{
		for ( int i = 0; i < type->NumFields(); ++i )
			{
			StringVal* val = new StringVal(type->FieldName(i));
			result->Assign(i+1, val);
			}
		}

	return result;
	} // end of BifFunc::bro_record_type_to_vector

#line 1708 "bro.bif"

#line 1715 "bro.bif"
Val* BifFunc::bro_type_name(Frame* frame, val_list* BiF_ARGS)
	
#line 1716 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("type_name() takes exactly 1 argument(s)");
		return 0;
		}
	Val* t = (Val*) ((*BiF_ARGS)[0]);

#line 1716 "bro.bif"

	ODesc d;
	t->Type()->Describe(&d);

	BroString* s = new BroString(1, d.TakeBytes(), d.Len());
	s->SetUseFreeToDelete(true);

	return new StringVal(s);
	} // end of BifFunc::bro_type_name

#line 1724 "bro.bif"

#line 1734 "bro.bif"
Val* BifFunc::bro_reading_live_traffic(Frame* frame, val_list* BiF_ARGS)
	
#line 1735 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("reading_live_traffic() takes exactly 0 argument(s)");
		return 0;
		}

#line 1735 "bro.bif"

	return new Val(reading_live, TYPE_BOOL);
	} // end of BifFunc::bro_reading_live_traffic

#line 1737 "bro.bif"

#line 1745 "bro.bif"
Val* BifFunc::bro_reading_traces(Frame* frame, val_list* BiF_ARGS)
	
#line 1746 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("reading_traces() takes exactly 0 argument(s)");
		return 0;
		}

#line 1746 "bro.bif"

	return new Val(reading_traces, TYPE_BOOL);
	} // end of BifFunc::bro_reading_traces

#line 1748 "bro.bif"

#line 1757 "bro.bif"
Val* BifFunc::bro_global_sizes(Frame* frame, val_list* BiF_ARGS)
	
#line 1758 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("global_sizes() takes exactly 0 argument(s)");
		return 0;
		}

#line 1758 "bro.bif"

	TableVal* sizes = new TableVal(var_sizes);
	PDict(ID)* globals = global_scope()->Vars();
	IterCookie* c = globals->InitForIteration();

	ID* id;
	while ( (id = globals->NextEntry(c)) )
		if ( id->HasVal() && ! id->IsInternalGlobal() )
			{
			Val* id_name = new StringVal(id->Name());
			Val* id_size = new Val(id->ID_Val()->MemoryAllocation(),
						TYPE_COUNT);
			sizes->Assign(id_name, id_size);
			Unref(id_name);
			}

	return sizes;
	} // end of BifFunc::bro_global_sizes

#line 1775 "bro.bif"

#line 1785 "bro.bif"
Val* BifFunc::bro_global_ids(Frame* frame, val_list* BiF_ARGS)
	
#line 1786 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("global_ids() takes exactly 0 argument(s)");
		return 0;
		}

#line 1786 "bro.bif"

	TableVal* ids = new TableVal(id_table);
	PDict(ID)* globals = global_scope()->Vars();
	IterCookie* c = globals->InitForIteration();

	ID* id;
	while ( (id = globals->NextEntry(c)) )
		{
		if ( id->IsInternalGlobal() )
			continue;

		RecordVal* rec = new RecordVal(script_id);
		rec->Assign(0, new StringVal(type_name(id->Type()->Tag())));
		rec->Assign(1, new Val(id->IsExport(), TYPE_BOOL));
		rec->Assign(2, new Val(id->IsConst(), TYPE_BOOL));
		rec->Assign(3, new Val(id->IsEnumConst(), TYPE_BOOL));
		rec->Assign(4, new Val(id->IsOption(), TYPE_BOOL));
		rec->Assign(5, new Val(id->IsRedefinable(), TYPE_BOOL));

		if ( id->HasVal() )
			{
			Val* val = id->ID_Val();
			Ref(val);
			rec->Assign(6, val);
			}

		Val* id_name = new StringVal(id->Name());
		ids->Assign(id_name, rec);
		Unref(id_name);
		}

	return ids;
	} // end of BifFunc::bro_global_ids

#line 1818 "bro.bif"

#line 1826 "bro.bif"
Val* BifFunc::bro_lookup_ID(Frame* frame, val_list* BiF_ARGS) 
	
#line 1827 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("lookup_ID() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* id = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 1827 "bro.bif"

	ID* i = global_scope()->Lookup(id->CheckString());
	if ( ! i )
		return new StringVal("<unknown id>");

	if ( ! i->ID_Val() )
		return new StringVal("<no ID value>");

	return i->ID_Val()->Ref();
	} // end of BifFunc::bro_lookup_ID

#line 1836 "bro.bif"

#line 1845 "bro.bif"
Val* BifFunc::bro_record_fields(Frame* frame, val_list* BiF_ARGS)
	
#line 1846 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("record_fields() takes exactly 1 argument(s)");
		return 0;
		}
	Val* rec = (Val*) ((*BiF_ARGS)[0]);

#line 1846 "bro.bif"

	TableVal* fields = new TableVal(record_field_table);

	RecordVal* rv = rec->AsRecordVal();
	RecordType* rt = rv->Type()->AsRecordType();

	if ( rt->Tag() != TYPE_RECORD )
		{
		reporter->Error("non-record passed to record_fields");
		return fields;
		}

	for ( int i = 0; i < rt->NumFields(); ++i )
		{
		BroType* ft = rt->FieldType(i);
		TypeDecl* fd = rt->FieldDecl(i);
		Val* fv = rv->Lookup(i);

		if ( fv )
			Ref(fv);

		bool logged = (fd->attrs && fd->FindAttr(ATTR_LOG) != 0);

		RecordVal* nr = new RecordVal(record_field);
		nr->Assign(0, new StringVal(type_name(rt->Tag())));
		nr->Assign(1, new Val(logged, TYPE_BOOL));
		nr->Assign(2, fv);
		nr->Assign(3, rt->FieldDefault(i));

		Val* field_name = new StringVal(rt->FieldName(i));
		fields->Assign(field_name, nr);
		Unref(field_name);
		}

	return fields;
	} // end of BifFunc::bro_record_fields

#line 1881 "bro.bif"

#line 1899 "bro.bif"
Val* BifFunc::bro_do_profiling(Frame* frame, val_list* BiF_ARGS) 
	
#line 1900 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("do_profiling() takes exactly 0 argument(s)");
		return 0;
		}

#line 1900 "bro.bif"

	if ( profiling_logger )
		profiling_logger->Log();

	return 0;
	} // end of BifFunc::bro_do_profiling

#line 1905 "bro.bif"

#line 1912 "bro.bif"
Val* BifFunc::bro_is_local_interface(Frame* frame, val_list* BiF_ARGS) 
	
#line 1913 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_local_interface() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* ip = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 1913 "bro.bif"

	if ( ip->AsAddr().IsLoopback() )
		return new Val(1, TYPE_BOOL);

	list<IPAddr> addrs;

	char host[MAXHOSTNAMELEN];

	strcpy(host, "localhost");
	gethostname(host, MAXHOSTNAMELEN);
	host[MAXHOSTNAMELEN-1] = '\0';

	struct hostent* ent = gethostbyname2(host, AF_INET);

	if ( ent )
		{
		for ( unsigned int len = 0; ent->h_addr_list[len]; ++len )
			addrs.push_back(IPAddr(IPv4, (uint32*)ent->h_addr_list[len],
			                       IPAddr::Network));
		}

	ent = gethostbyname2(host, AF_INET6);

	if ( ent )
		{
		for ( unsigned int len = 0; ent->h_addr_list[len]; ++len )
			addrs.push_back(IPAddr(IPv6, (uint32*)ent->h_addr_list[len],
			                       IPAddr::Network));
		}

	list<IPAddr>::const_iterator it;
	for ( it = addrs.begin(); it != addrs.end(); ++it )
		{
		if ( *it == ip->AsAddr() )
			return new Val(1, TYPE_BOOL);
		}

	return new Val(0, TYPE_BOOL);
	} // end of BifFunc::bro_is_local_interface

#line 1951 "bro.bif"

#line 1961 "bro.bif"
Val* BifFunc::bro_dump_rule_stats(Frame* frame, val_list* BiF_ARGS)
	
#line 1962 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("dump_rule_stats() takes exactly 1 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());

#line 1962 "bro.bif"

	if ( rule_matcher )
		rule_matcher->DumpStats(f);

	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_dump_rule_stats

#line 1967 "bro.bif"

#line 1974 "bro.bif"
Val* BifFunc::bro_bro_is_terminating(Frame* frame, val_list* BiF_ARGS)
	
#line 1975 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("bro_is_terminating() takes exactly 0 argument(s)");
		return 0;
		}

#line 1975 "bro.bif"

	return new Val(terminating, TYPE_BOOL);
	} // end of BifFunc::bro_bro_is_terminating

#line 1977 "bro.bif"

#line 1982 "bro.bif"
Val* BifFunc::bro_gethostname(Frame* frame, val_list* BiF_ARGS) 
	
#line 1983 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("gethostname() takes exactly 0 argument(s)");
		return 0;
		}

#line 1983 "bro.bif"

	char buffer[MAXHOSTNAMELEN];
	if ( gethostname(buffer, MAXHOSTNAMELEN) < 0 )
		strcpy(buffer, "<unknown>");

	buffer[MAXHOSTNAMELEN-1] = '\0';
	return new StringVal(buffer);
	} // end of BifFunc::bro_gethostname

#line 1990 "bro.bif"

#line 1997 "bro.bif"
Val* BifFunc::bro_is_v4_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 1998 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_v4_addr() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 1998 "bro.bif"

	if ( a->AsAddr().GetFamily() == IPv4 )
		return new Val(1, TYPE_BOOL);
	else
		return new Val(0, TYPE_BOOL);
	} // end of BifFunc::bro_is_v4_addr

#line 2003 "bro.bif"

#line 2010 "bro.bif"
Val* BifFunc::bro_is_v6_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 2011 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_v6_addr() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 2011 "bro.bif"

	if ( a->AsAddr().GetFamily() == IPv6 )
		return new Val(1, TYPE_BOOL);
	else
		return new Val(0, TYPE_BOOL);
	} // end of BifFunc::bro_is_v6_addr

#line 2016 "bro.bif"

#line 2023 "bro.bif"
Val* BifFunc::bro_is_v4_subnet(Frame* frame, val_list* BiF_ARGS)
	
#line 2024 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_v4_subnet() takes exactly 1 argument(s)");
		return 0;
		}
	SubNetVal* s = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());

#line 2024 "bro.bif"

	if ( s->AsSubNet().Prefix().GetFamily() == IPv4 )
		return new Val(1, TYPE_BOOL);
	else
		return new Val(0, TYPE_BOOL);
	} // end of BifFunc::bro_is_v4_subnet

#line 2029 "bro.bif"

#line 2036 "bro.bif"
Val* BifFunc::bro_is_v6_subnet(Frame* frame, val_list* BiF_ARGS)
	
#line 2037 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_v6_subnet() takes exactly 1 argument(s)");
		return 0;
		}
	SubNetVal* s = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());

#line 2037 "bro.bif"

	if ( s->AsSubNet().Prefix().GetFamily() == IPv6 )
		return new Val(1, TYPE_BOOL);
	else
		return new Val(0, TYPE_BOOL);
	} // end of BifFunc::bro_is_v6_subnet

#line 2042 "bro.bif"

#line 2058 "bro.bif"
Val* BifFunc::bro_routing0_data_to_addrs(Frame* frame, val_list* BiF_ARGS)
	
#line 2059 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("routing0_data_to_addrs() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2059 "bro.bif"

	VectorVal* rval = new VectorVal(internal_type("addr_vec")->AsVectorType());

	int len = s->Len();
	const u_char* bytes = s->Bytes();
	bytes += 4; // go past 32-bit reserved field
	len -= 4;

	if ( ( len % 16 ) != 0 )
		reporter->Warning("Bad ip6_routing data length: %d", s->Len());

	while ( len > 0 )
		{
		IPAddr a(IPv6, (const uint32*) bytes, IPAddr::Network);
		rval->Assign(rval->Size(), new AddrVal(a));
		bytes += 16;
		len -= 16;
		}

	return rval;
	} // end of BifFunc::bro_routing0_data_to_addrs

#line 2079 "bro.bif"

#line 2089 "bro.bif"
Val* BifFunc::bro_addr_to_counts(Frame* frame, val_list* BiF_ARGS)
	
#line 2090 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("addr_to_counts() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 2090 "bro.bif"

	VectorVal* rval = new VectorVal(internal_type("index_vec")->AsVectorType());
	const uint32* bytes;
	int len = a->AsAddr().GetBytes(&bytes);

	for ( int i = 0; i < len; ++i )
		rval->Assign(i, new Val(ntohl(bytes[i]), TYPE_COUNT));

	return rval;
	} // end of BifFunc::bro_addr_to_counts

#line 2099 "bro.bif"

#line 2109 "bro.bif"
Val* BifFunc::bro_counts_to_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 2110 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("counts_to_addr() takes exactly 1 argument(s)");
		return 0;
		}
	Val* v = (Val*) ((*BiF_ARGS)[0]);

#line 2110 "bro.bif"

	if ( v->AsVector()->size() == 1 )
		{
		return new AddrVal(htonl((*v->AsVector())[0]->AsCount()));
		}
	else if ( v->AsVector()->size() == 4 )
		{
		uint32 bytes[4];
		for ( int i = 0; i < 4; ++i )
			bytes[i] = htonl((*v->AsVector())[i]->AsCount());
		return new AddrVal(bytes);
		}
	else
		{
		builtin_error("invalid vector size", (*BiF_ARGS)[0]);
		uint32 bytes[4];
		memset(bytes, 0, sizeof(bytes));
		return new AddrVal(bytes);
		}
	} // end of BifFunc::bro_counts_to_addr

#line 2129 "bro.bif"

#line 2136 "bro.bif"
Val* BifFunc::bro_enum_to_int(Frame* frame, val_list* BiF_ARGS)
	
#line 2137 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("enum_to_int() takes exactly 1 argument(s)");
		return 0;
		}
	Val* e = (Val*) ((*BiF_ARGS)[0]);

#line 2137 "bro.bif"

	if ( e->Type()->Tag() != TYPE_ENUM )
		{
		builtin_error("enum_to_int() requires enum value");
		return new Val(-1, TYPE_INT);
		}

	return new Val(e->AsEnum(), TYPE_INT);
	} // end of BifFunc::bro_enum_to_int

#line 2145 "bro.bif"

#line 2154 "bro.bif"
Val* BifFunc::bro_to_int(Frame* frame, val_list* BiF_ARGS)
	
#line 2155 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_int() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2155 "bro.bif"

	const char* s = str->CheckString();
	char* end_s;

	bro_int_t i = strtoll(s, &end_s, 10);

#if 0
	// Not clear we should complain.  For example, is " 205 "
	// a legal conversion?
	if ( s[0] == '\0' || end_s[0] != '\0' )
		builtin_error("bad conversion to integer", (*BiF_ARGS)[0]);
#endif

	return new Val(i, TYPE_INT);
	} // end of BifFunc::bro_to_int

#line 2169 "bro.bif"

#line 2177 "bro.bif"
Val* BifFunc::bro_int_to_count(Frame* frame, val_list* BiF_ARGS)
	
#line 2178 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("int_to_count() takes exactly 1 argument(s)");
		return 0;
		}
	bro_int_t n = (bro_int_t) ((*BiF_ARGS)[0]->AsInt());

#line 2178 "bro.bif"

	if ( n < 0 )
		{
		builtin_error("bad conversion to count", (*BiF_ARGS)[0]);
		n = 0;
		}
	return new Val(n, TYPE_COUNT);
	} // end of BifFunc::bro_int_to_count

#line 2185 "bro.bif"

#line 2194 "bro.bif"
Val* BifFunc::bro_double_to_count(Frame* frame, val_list* BiF_ARGS)
	
#line 2195 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("double_to_count() takes exactly 1 argument(s)");
		return 0;
		}
	double d = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 2195 "bro.bif"

	if ( d < 0.0 )
		builtin_error("bad conversion to count", (*BiF_ARGS)[0]);

	return new Val(bro_uint_t(rint(d)), TYPE_COUNT);
	} // end of BifFunc::bro_double_to_count

#line 2200 "bro.bif"

#line 2210 "bro.bif"
Val* BifFunc::bro_to_count(Frame* frame, val_list* BiF_ARGS)
	
#line 2211 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_count() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2211 "bro.bif"

	const char* s = str->CheckString();
	char* end_s;

	uint64 u = (uint64) strtoull(s, &end_s, 10);

	if ( s[0] == '\0' || end_s[0] != '\0' )
    	{
		builtin_error("bad conversion to count", (*BiF_ARGS)[0]);
        u = 0;
        }

	return new Val(u, TYPE_COUNT);
	} // end of BifFunc::bro_to_count

#line 2224 "bro.bif"

#line 2233 "bro.bif"
Val* BifFunc::bro_interval_to_double(Frame* frame, val_list* BiF_ARGS)
	
#line 2234 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("interval_to_double() takes exactly 1 argument(s)");
		return 0;
		}
	double i = (double) ((*BiF_ARGS)[0]->AsInterval());

#line 2234 "bro.bif"

	return new Val(i, TYPE_DOUBLE);
	} // end of BifFunc::bro_interval_to_double

#line 2236 "bro.bif"

#line 2245 "bro.bif"
Val* BifFunc::bro_time_to_double(Frame* frame, val_list* BiF_ARGS)
	
#line 2246 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("time_to_double() takes exactly 1 argument(s)");
		return 0;
		}
	double t = (double) ((*BiF_ARGS)[0]->AsTime());

#line 2246 "bro.bif"

	return new Val(t, TYPE_DOUBLE);
	} // end of BifFunc::bro_time_to_double

#line 2248 "bro.bif"

#line 2257 "bro.bif"
Val* BifFunc::bro_double_to_time(Frame* frame, val_list* BiF_ARGS)
	
#line 2258 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("double_to_time() takes exactly 1 argument(s)");
		return 0;
		}
	double d = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 2258 "bro.bif"

	return new Val(d, TYPE_TIME);
	} // end of BifFunc::bro_double_to_time

#line 2260 "bro.bif"

#line 2269 "bro.bif"
Val* BifFunc::bro_double_to_interval(Frame* frame, val_list* BiF_ARGS)
	
#line 2270 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("double_to_interval() takes exactly 1 argument(s)");
		return 0;
		}
	double d = (double) ((*BiF_ARGS)[0]->AsDouble());

#line 2270 "bro.bif"

	return new Val(d, TYPE_INTERVAL);
	} // end of BifFunc::bro_double_to_interval

#line 2272 "bro.bif"

#line 2281 "bro.bif"
Val* BifFunc::bro_port_to_count(Frame* frame, val_list* BiF_ARGS)
	
#line 2282 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("port_to_count() takes exactly 1 argument(s)");
		return 0;
		}
	PortVal* p = (PortVal*) ((*BiF_ARGS)[0]->AsPortVal());

#line 2282 "bro.bif"

	return new Val(p->Port(), TYPE_COUNT);
	} // end of BifFunc::bro_port_to_count

#line 2284 "bro.bif"

#line 2295 "bro.bif"
Val* BifFunc::bro_count_to_port(Frame* frame, val_list* BiF_ARGS)
	
#line 2296 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("count_to_port() takes exactly 2 argument(s)");
		return 0;
		}
	bro_uint_t num = (bro_uint_t) ((*BiF_ARGS)[0]->AsCount());
	Val* proto = (Val*) ((*BiF_ARGS)[1]);

#line 2296 "bro.bif"

	return port_mgr->Get(num, (TransportProto)proto->AsEnum());
	} // end of BifFunc::bro_count_to_port

#line 2298 "bro.bif"

#line 2309 "bro.bif"
Val* BifFunc::bro_to_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 2310 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_addr() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* ip = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2310 "bro.bif"

	char* s = ip->AsString()->Render();
	Val* ret = new AddrVal(s);
	delete [] s;
	return ret;
	} // end of BifFunc::bro_to_addr

#line 2315 "bro.bif"

#line 2326 "bro.bif"
Val* BifFunc::bro_to_subnet(Frame* frame, val_list* BiF_ARGS)
	
#line 2327 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_subnet() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* sn = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2327 "bro.bif"

	char* s = sn->AsString()->Render();
	Val* ret = new SubNetVal(s);
	delete [] s;
	return ret;
	} // end of BifFunc::bro_to_subnet

#line 2332 "bro.bif"

#line 2341 "bro.bif"
Val* BifFunc::bro_addr_to_subnet(Frame* frame, val_list* BiF_ARGS)
	
#line 2342 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("addr_to_subnet() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 2342 "bro.bif"

	int width = (a->AsAddr().GetFamily() == IPv4 ? 32 : 128);
	return new SubNetVal(a->AsAddr(), width);
	} // end of BifFunc::bro_addr_to_subnet

#line 2345 "bro.bif"

#line 2355 "bro.bif"
Val* BifFunc::bro_subnet_to_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 2356 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("subnet_to_addr() takes exactly 1 argument(s)");
		return 0;
		}
	SubNetVal* sn = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());

#line 2356 "bro.bif"

	return new AddrVal(sn->Prefix());
	} // end of BifFunc::bro_subnet_to_addr

#line 2358 "bro.bif"

#line 2367 "bro.bif"
Val* BifFunc::bro_subnet_width(Frame* frame, val_list* BiF_ARGS)
	
#line 2368 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("subnet_width() takes exactly 1 argument(s)");
		return 0;
		}
	SubNetVal* sn = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());

#line 2368 "bro.bif"

	return new Val(sn->Width(), TYPE_COUNT);
	} // end of BifFunc::bro_subnet_width

#line 2370 "bro.bif"

#line 2379 "bro.bif"
Val* BifFunc::bro_to_double(Frame* frame, val_list* BiF_ARGS)
	
#line 2380 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_double() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2380 "bro.bif"

	const char* s = str->CheckString();
	char* end_s;

	double d = strtod(s, &end_s);

	if ( s[0] == '\0' || end_s[0] != '\0' )
		{
		builtin_error("bad conversion to double", (*BiF_ARGS)[0]);
		d = 0;
		}

	return new Val(d, TYPE_DOUBLE);
	} // end of BifFunc::bro_to_double

#line 2393 "bro.bif"

#line 2402 "bro.bif"
Val* BifFunc::bro_count_to_v4_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 2403 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("count_to_v4_addr() takes exactly 1 argument(s)");
		return 0;
		}
	bro_uint_t ip = (bro_uint_t) ((*BiF_ARGS)[0]->AsCount());

#line 2403 "bro.bif"

	if ( ip > 4294967295LU )
		{
		builtin_error("conversion of non-IPv4 count to addr", (*BiF_ARGS)[0]);
		return new AddrVal(uint32(0));
		}

	return new AddrVal(htonl(uint32(ip)));
	} // end of BifFunc::bro_count_to_v4_addr

#line 2411 "bro.bif"

#line 2422 "bro.bif"
Val* BifFunc::bro_raw_bytes_to_v4_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 2423 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("raw_bytes_to_v4_addr() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* b = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2423 "bro.bif"

	uint32 a = 0;

	if ( b->Len() < 4 )
		builtin_error("too short a string as input to raw_bytes_to_v4_addr()");

	else
		{
		const u_char* bp = b->Bytes();
		a = (bp[0] << 24) | (bp[1] << 16) | (bp[2] << 8) | bp[3];
		}

	return new AddrVal(htonl(a));
	} // end of BifFunc::bro_raw_bytes_to_v4_addr

#line 2436 "bro.bif"

#line 2445 "bro.bif"
Val* BifFunc::bro_to_port(Frame* frame, val_list* BiF_ARGS)
    
#line 2446 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_port() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2446 "bro.bif"

    int port = 0;
    if ( s->Len() < 10 )
        {
        char* slash;
        errno = 0;
        port = strtol(s->CheckString(), &slash, 10);
        if ( ! errno )
            {
            ++slash;
            if ( streq(slash, "tcp") )
                return port_mgr->Get(port, TRANSPORT_TCP);
            else if ( streq(slash, "udp") )
                return port_mgr->Get(port, TRANSPORT_UDP);
            else if ( streq(slash, "icmp") )
                return port_mgr->Get(port, TRANSPORT_ICMP);
            }
        }

    builtin_error("wrong port format, must be /[0-9]{1,5}\\/(tcp|udp|icmp)/");
    return port_mgr->Get(port, TRANSPORT_UNKNOWN);
	} // end of BifFunc::bro_to_port

#line 2467 "bro.bif"

#line 2476 "bro.bif"
Val* BifFunc::bro_bytestring_to_double(Frame* frame, val_list* BiF_ARGS)
	
#line 2477 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("bytestring_to_double() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2477 "bro.bif"

	if ( s->Len() != sizeof(double) )
		{
		builtin_error("bad conversion to double");
		return new Val(0.0, TYPE_DOUBLE);
		}

	// See #908 for a discussion of portability.
	double d;
	memcpy(&d, s->Bytes(), sizeof(double));
	return new Val(ntohd(d), TYPE_DOUBLE);
	} // end of BifFunc::bro_bytestring_to_double

#line 2488 "bro.bif"

#line 2498 "bro.bif"
Val* BifFunc::bro_bytestring_to_count(Frame* frame, val_list* BiF_ARGS)
	
#line 2499 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("bytestring_to_count() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	int is_le = (int) ((*BiF_ARGS)[1]->AsBool());

#line 2499 "bro.bif"

#ifdef HOST_BIGENDIAN
	static const bool host_bigendian = true;
#else
	static const bool host_bigendian = false;
#endif
	const u_char *p = s->Bytes();
	unsigned int i;

	switch ( s->Len() ) {
	case sizeof(uint8):
		{
		uint8 value = 0;
		memcpy(&value, p, sizeof(uint8));
		return new Val(value, TYPE_COUNT);
		}

	case sizeof(uint16):
		{
		uint16 value = 0;

		if ( (host_bigendian && is_le) || (! host_bigendian && ! is_le) )
			{
			char buf[sizeof(uint16)];
			char *d = &buf[sizeof(uint16)-1];

			for ( i = 0; i < sizeof(uint16); i++ )
				*d-- = *p++;

			memcpy(&value, buf, sizeof(uint16));
			}
		else
			memcpy(&value, p, sizeof(uint16));

		return new Val(value, TYPE_COUNT);
		}

	case sizeof(uint32):
		{
		uint32 value = 0;

		if ( (host_bigendian && is_le) || (! host_bigendian && ! is_le) )
			{
			char buf[sizeof(uint32)];
			char *d = &buf[sizeof(uint32)-1];

			for ( i = 0; i < sizeof(uint32); i++ )
				*d-- = *p++;

			memcpy(&value, buf, sizeof(uint32));
			}
		else
			memcpy(&value, p, sizeof(uint32));

		return new Val(value, TYPE_COUNT);
		}

	case sizeof(uint64):
		{
		uint64 value = 0;

		if ( (host_bigendian && is_le) || (! host_bigendian && ! is_le) )
			{
			char buf[sizeof(uint64)];
			char *d = &buf[sizeof(uint64)-1];

			for ( i = 0; i < sizeof(uint64); i++ )
				*d-- = *p++;

			memcpy(&value, buf, sizeof(uint64));
			}
		else
			memcpy(&value, p, sizeof(uint64));

		return new Val(value, TYPE_COUNT);
		}
	}

	builtin_error("unsupported byte length for bytestring_to_count");
	return new Val(0, TYPE_COUNT);
	} // end of BifFunc::bro_bytestring_to_count

#line 2579 "bro.bif"

#line 2589 "bro.bif"
Val* BifFunc::bro_ptr_name_to_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 2590 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("ptr_name_to_addr() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2590 "bro.bif"

	if ( s->Len() != 72 )
		{
		int a[4];
		uint32 addr;
		char ss[13]; // this will contain "in-addr.arpa"

		if ( sscanf(s->CheckString(),
			"%d.%d.%d.%d.%12s",
			a, a+1, a+2, a+3, ss) != 5
			|| strcmp(ss, "in-addr.arpa") != 0 )
			{
			builtin_error("bad PTR name", (*BiF_ARGS)[0]);
			addr = 0;
			}
		else
			addr = (a[3] << 24) | (a[2] << 16) | (a[1] << 8) | a[0];

		return new AddrVal(htonl(addr));
		}
	else
		{
		uint32 addr6[4];
		uint32 b[32];
		char ss[9]; // this will contain "ip6.arpa"
		if ( sscanf(s->CheckString(),
			"%1x.%1x.%1x.%1x.%1x.%1x.%1x.%1x."
			"%1x.%1x.%1x.%1x.%1x.%1x.%1x.%1x."
			"%1x.%1x.%1x.%1x.%1x.%1x.%1x.%1x."
			"%1x.%1x.%1x.%1x.%1x.%1x.%1x.%1x.%8s",
			b+31, b+30, b+29, b+28, b+27, b+26, b+25, b+24,
			b+23, b+22, b+21, b+20, b+19, b+18, b+17, b+16,
			b+15, b+14, b+13, b+12, b+11, b+10, b+9, b+8,
			b+7, b+6, b+5, b+4, b+3, b+2, b+1, b, ss) != 33
			|| strcmp(ss, "ip6.arpa") != 0 )
			{
			builtin_error("bad PTR name", (*BiF_ARGS)[0]);
			memset(addr6, 0, sizeof addr6);
			}
		else
			{
			for ( unsigned int i = 0; i < 4; ++i )
				{
				uint32 a = 0;
				for ( unsigned int j = 1; j <= 8; ++j )
					a |= b[8*i+j-1] << (32-j*4);

				addr6[i] = htonl(a);
				}
			}

		return new AddrVal(addr6);
		}
	} // end of BifFunc::bro_ptr_name_to_addr

#line 2643 "bro.bif"

#line 2653 "bro.bif"
Val* BifFunc::bro_addr_to_ptr_name(Frame* frame, val_list* BiF_ARGS)
	
#line 2654 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("addr_to_ptr_name() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 2654 "bro.bif"

	return new StringVal(a->AsAddr().PtrName().c_str());
	} // end of BifFunc::bro_addr_to_ptr_name

#line 2656 "bro.bif"

#line 2666 "bro.bif"
Val* BifFunc::bro_bytestring_to_hexstr(Frame* frame, val_list* BiF_ARGS)
	
#line 2667 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("bytestring_to_hexstr() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* bytestring = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2667 "bro.bif"

	bro_uint_t len = bytestring->AsString()->Len();
	const u_char* bytes = bytestring->AsString()->Bytes();
	char hexstr[(2 * len) + 1];

	hexstr[0] = 0;
	for ( bro_uint_t i = 0; i < len; ++i )
		snprintf(hexstr + (2 * i), 3, "%.2hhx", bytes[i]);

	return new StringVal(hexstr);
	} // end of BifFunc::bro_bytestring_to_hexstr

#line 2677 "bro.bif"

#line 2690 "bro.bif"
Val* BifFunc::bro_hexstr_to_bytestring(Frame* frame, val_list* BiF_ARGS)
	
#line 2691 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("hexstr_to_bytestring() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* hexstr = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2691 "bro.bif"

	bro_uint_t len = hexstr->AsString()->Len();
	if ( len % 2 != 0 )
		{
		reporter->Error("Hex string '%s' has invalid length (not divisible by 2)", hexstr->CheckString());
		return new StringVal("");
		}

	const char* bytes = hexstr->AsString()->CheckString();
	int outlen = (len/2);
	char bytestring[outlen];
	memset(bytestring, 0, outlen);

	for ( bro_uint_t i = 0; i < len/2; ++i )
		{
		int res = sscanf(bytes + (2*i), "%2hhx", &bytestring[i]);

		if ( res == EOF )
			{
			reporter->Error("Hex string %s contains invalid input: %s", hexstr->CheckString(), strerror(errno));
			return new StringVal("");
			}

		else if ( res != 1 )
			{
			reporter->Error("Could not read hex element from input %s", hexstr->CheckString());
			return new StringVal("");
			}

		}

	return new StringVal(outlen, bytestring);
	} // end of BifFunc::bro_hexstr_to_bytestring

#line 2723 "bro.bif"

#line 2735 "bro.bif"
Val* BifFunc::bro_encode_base64(Frame* frame, val_list* BiF_ARGS)
	
#line 2736 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("encode_base64() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* a = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 2736 "bro.bif"

	BroString* t = encode_base64(s->AsString(), a->AsString());
	if ( t )
		return new StringVal(t);
	else
		{
		reporter->Error("error in encoding string %s", s->CheckString());
		return new StringVal("");
		}
	} // end of BifFunc::bro_encode_base64

#line 2745 "bro.bif"

#line 2758 "bro.bif"
Val* BifFunc::bro_encode_base64_custom(Frame* frame, val_list* BiF_ARGS) 
#line 2759 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("encode_base64_custom() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* a = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 2759 "bro.bif"

	BroString* t = encode_base64(s->AsString(), a->AsString());
	if ( t )
		return new StringVal(t);
	else
		{
		reporter->Error("error in encoding string %s", s->CheckString());
		return new StringVal("");
		}
	} // end of BifFunc::bro_encode_base64_custom

#line 2768 "bro.bif"

#line 2780 "bro.bif"
Val* BifFunc::bro_decode_base64(Frame* frame, val_list* BiF_ARGS)
	
#line 2781 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("decode_base64() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* a = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 2781 "bro.bif"

	BroString* t = decode_base64(s->AsString(), a->AsString());
	if ( t )
		return new StringVal(t);
	else
		{
		reporter->Error("error in decoding string %s", s->CheckString());
		return new StringVal("");
		}
	} // end of BifFunc::bro_decode_base64

#line 2790 "bro.bif"

#line 2806 "bro.bif"
Val* BifFunc::bro_decode_base64_conn(Frame* frame, val_list* BiF_ARGS)
	
#line 2807 "bro.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("decode_base64_conn() takes exactly 3 argument(s)");
		return 0;
		}
	Val* cid = (Val*) ((*BiF_ARGS)[0]);
	StringVal* s = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());
	StringVal* a = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());

#line 2807 "bro.bif"

	Connection* conn = sessions->FindConnection(cid);
	if ( ! conn )
		{
		builtin_error("connection ID not a known connection", cid);
		return new StringVal("");
		}

	BroString* t = decode_base64(s->AsString(), a->AsString(), conn);
	if ( t )
		return new StringVal(t);
	else
		{
		reporter->Error("error in decoding string %s", s->CheckString());
		return new StringVal("");
		}
	} // end of BifFunc::bro_decode_base64_conn

#line 2823 "bro.bif"

#line 2835 "bro.bif"
Val* BifFunc::bro_decode_base64_custom(Frame* frame, val_list* BiF_ARGS) 
#line 2836 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("decode_base64_custom() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* a = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 2836 "bro.bif"

	BroString* t = decode_base64(s->AsString(), a->AsString());
	if ( t )
		return new StringVal(t);
	else
		{
		reporter->Error("error in decoding string %s", s->CheckString());
		return new StringVal("");
		}
	} // end of BifFunc::bro_decode_base64_custom

#line 2845 "bro.bif"

#line 2847 "bro.bif"

typedef struct {
	uint32 time_low;
	uint16 time_mid;
	uint16 time_hi_and_version;
	uint8 clock_seq_hi_and_reserved;
	uint8 clock_seq_low;
	uint8 node[6];
} bro_uuid_t;

#line 2866 "bro.bif"
Val* BifFunc::bro_uuid_to_string(Frame* frame, val_list* BiF_ARGS)
	
#line 2867 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("uuid_to_string() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* uuid = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2867 "bro.bif"

	if ( uuid->Len() != 16 )
		return new StringVal("<Invalid UUID>");

	bro_uuid_t* id = (bro_uuid_t*) uuid->Bytes();

	static char s[1024];
	char* sp = s;

	sp += snprintf(sp, s + sizeof(s) - sp,
		"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
		id->time_low, id->time_mid, id->time_hi_and_version,
		id->clock_seq_hi_and_reserved, id->clock_seq_low,
		id->node[0],
		id->node[1],
		id->node[2],
		id->node[3],
		id->node[4],
		id->node[5]);

	return new StringVal(s);
	} // end of BifFunc::bro_uuid_to_string

#line 2888 "bro.bif"

#line 2904 "bro.bif"
Val* BifFunc::bro_merge_pattern(Frame* frame, val_list* BiF_ARGS)
	
#line 2905 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("merge_pattern() takes exactly 2 argument(s)");
		return 0;
		}
	RE_Matcher* p1 = (RE_Matcher*) ((*BiF_ARGS)[0]->AsPattern());
	RE_Matcher* p2 = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());

#line 2905 "bro.bif"

	if ( bro_start_network_time != 0.0 )
		{
		builtin_error("merge_pattern can only be called at init time");
		return 0;
		}

	RE_Matcher* re = new RE_Matcher();
	re->AddPat(p1->PatternText());
	re->AddPat(p2->PatternText());
	re->Compile();
	return new PatternVal(re);
	} // end of BifFunc::bro_merge_pattern

#line 2917 "bro.bif"

#line 2919 "bro.bif"

char* to_pat_str(int sn, const char* ss)
	{
	const char special_re_char[] = "^$-:\"\\/|*+?.(){}[]";

	char* pat = new char[sn * 4 + 1];
	int pat_len = 0;

	for ( int i = 0; i < sn; ++i )
		{
		if ( ! strchr(special_re_char, ss[i]) )
			pat[pat_len++] = ss[i];
		else
			{
			pat[pat_len++] = '\\';
			pat[pat_len++] = ss[i];
			}
		}
	pat[pat_len] = '\0';
	return pat;
	}

#line 2953 "bro.bif"
Val* BifFunc::bro_convert_for_pattern(Frame* frame, val_list* BiF_ARGS)
	
#line 2954 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("convert_for_pattern() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 2954 "bro.bif"

	char* t = to_pat_str(s->Len(), (const char*)(s->Bytes()));
	StringVal* ret = new StringVal(t);
	delete [] t;
	return ret;
	} // end of BifFunc::bro_convert_for_pattern

#line 2959 "bro.bif"

#line 2977 "bro.bif"
Val* BifFunc::bro_string_to_pattern(Frame* frame, val_list* BiF_ARGS)
	
#line 2978 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("string_to_pattern() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	int convert = (int) ((*BiF_ARGS)[1]->AsBool());

#line 2978 "bro.bif"

	if ( bro_start_network_time != 0.0 )
		{
		builtin_error("string_to_pattern can only be called at init time");
		return 0;
		}

	const char* ss = (const char*) (s->Bytes());
	int sn = s->Len();
	char* pat;

	if ( convert )
		pat = to_pat_str(sn, ss);
	else
		{
		pat = new char[sn+1];
		memcpy(pat, ss, sn);
		pat[sn] = '\0';
		}

	RE_Matcher* re = new RE_Matcher(pat);
	delete [] pat;
	re->Compile();
	return new PatternVal(re);
	} // end of BifFunc::bro_string_to_pattern

#line 3002 "bro.bif"

#line 3011 "bro.bif"
Val* BifFunc::bro_strftime(Frame* frame, val_list* BiF_ARGS) 
	
#line 3012 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("strftime() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* fmt = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	double d = (double) ((*BiF_ARGS)[1]->AsTime());

#line 3012 "bro.bif"

	static char buffer[128];

	time_t timeval = time_t(d);
	struct tm t;

	if ( ! localtime_r(&timeval, &t) ||
	     ! strftime(buffer, 128, fmt->CheckString(), &t) )
		return new StringVal("<strftime error>");

	return new StringVal(buffer);
	} // end of BifFunc::bro_strftime

#line 3023 "bro.bif"

#line 3034 "bro.bif"
Val* BifFunc::bro_strptime(Frame* frame, val_list* BiF_ARGS) 
	
#line 3035 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("strptime() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* fmt = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* d = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 3035 "bro.bif"

	const time_t timeval = time_t();
	struct tm t;

	if ( ! localtime_r(&timeval, &t) || 
	     ! strptime(d->CheckString(), fmt->CheckString(), &t) )
		{
		reporter->Warning("strptime conversion failed: fmt:%s d:%s", fmt->CheckString(), d->CheckString());
		return new Val(0.0, TYPE_TIME);
		}

	double ret = mktime(&t);
	return new Val(ret, TYPE_TIME);
	} // end of BifFunc::bro_strptime

#line 3048 "bro.bif"

#line 3068 "bro.bif"
Val* BifFunc::bro_mask_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 3069 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("mask_addr() takes exactly 2 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	bro_uint_t top_bits_to_keep = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());

#line 3069 "bro.bif"

	return new SubNetVal(a->AsAddr(), top_bits_to_keep);
	} // end of BifFunc::bro_mask_addr

#line 3071 "bro.bif"

#line 3090 "bro.bif"
Val* BifFunc::bro_remask_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 3091 "bro.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("remask_addr() takes exactly 3 argument(s)");
		return 0;
		}
	AddrVal* a1 = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	AddrVal* a2 = (AddrVal*) ((*BiF_ARGS)[1]->AsAddrVal());
	bro_uint_t top_bits_from_a1 = (bro_uint_t) ((*BiF_ARGS)[2]->AsCount());

#line 3091 "bro.bif"

	IPAddr addr1(a1->AsAddr());
	addr1.Mask(top_bits_from_a1);
	IPAddr addr2(a2->AsAddr());
	addr2.ReverseMask(top_bits_from_a1);
	return new AddrVal(addr1|addr2);
	} // end of BifFunc::bro_remask_addr

#line 3097 "bro.bif"

#line 3106 "bro.bif"
Val* BifFunc::bro_is_tcp_port(Frame* frame, val_list* BiF_ARGS)
	
#line 3107 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_tcp_port() takes exactly 1 argument(s)");
		return 0;
		}
	PortVal* p = (PortVal*) ((*BiF_ARGS)[0]->AsPortVal());

#line 3107 "bro.bif"

	return new Val(p->IsTCP(), TYPE_BOOL);
	} // end of BifFunc::bro_is_tcp_port

#line 3109 "bro.bif"

#line 3118 "bro.bif"
Val* BifFunc::bro_is_udp_port(Frame* frame, val_list* BiF_ARGS)
	
#line 3119 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_udp_port() takes exactly 1 argument(s)");
		return 0;
		}
	PortVal* p = (PortVal*) ((*BiF_ARGS)[0]->AsPortVal());

#line 3119 "bro.bif"

	return new Val(p->IsUDP(), TYPE_BOOL);
	} // end of BifFunc::bro_is_udp_port

#line 3121 "bro.bif"

#line 3130 "bro.bif"
Val* BifFunc::bro_is_icmp_port(Frame* frame, val_list* BiF_ARGS)
	
#line 3131 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_icmp_port() takes exactly 1 argument(s)");
		return 0;
		}
	PortVal* p = (PortVal*) ((*BiF_ARGS)[0]->AsPortVal());

#line 3131 "bro.bif"

	return new Val(p->IsICMP(), TYPE_BOOL);
	} // end of BifFunc::bro_is_icmp_port

#line 3133 "bro.bif"

#line 3135 "bro.bif"

EnumVal* map_conn_type(TransportProto tp)
	{
	switch ( tp ) {
	case TRANSPORT_UNKNOWN:
		return new EnumVal(0, transport_proto);
		break;

	case TRANSPORT_TCP:
		return new EnumVal(1, transport_proto);
		break;

	case TRANSPORT_UDP:
		return new EnumVal(2, transport_proto);
		break;

	case TRANSPORT_ICMP:
		return new EnumVal(3, transport_proto);
		break;

	default:
		reporter->InternalError("bad connection type in map_conn_type()");
	}

	// Cannot be reached;
	assert(false);
	return 0; // Make compiler happy.
	}

#line 3173 "bro.bif"
Val* BifFunc::bro_get_conn_transport_proto(Frame* frame, val_list* BiF_ARGS)
	
#line 3174 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("get_conn_transport_proto() takes exactly 1 argument(s)");
		return 0;
		}
	Val* cid = (Val*) ((*BiF_ARGS)[0]);

#line 3174 "bro.bif"

	Connection* c = sessions->FindConnection(cid);
	if ( ! c )
		{
		builtin_error("unknown connection id in get_conn_transport_proto()", cid);
		return new EnumVal(0, transport_proto);
		}

	return map_conn_type(c->ConnTransport());
	} // end of BifFunc::bro_get_conn_transport_proto

#line 3183 "bro.bif"

#line 3193 "bro.bif"
Val* BifFunc::bro_get_port_transport_proto(Frame* frame, val_list* BiF_ARGS)
	
#line 3194 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("get_port_transport_proto() takes exactly 1 argument(s)");
		return 0;
		}
	PortVal* p = (PortVal*) ((*BiF_ARGS)[0]->AsPortVal());

#line 3194 "bro.bif"

	return map_conn_type(p->PortType());
	} // end of BifFunc::bro_get_port_transport_proto

#line 3196 "bro.bif"

#line 3205 "bro.bif"
Val* BifFunc::bro_connection_exists(Frame* frame, val_list* BiF_ARGS)
	
#line 3206 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("connection_exists() takes exactly 1 argument(s)");
		return 0;
		}
	Val* c = (Val*) ((*BiF_ARGS)[0]);

#line 3206 "bro.bif"

	if ( sessions->FindConnection(c) )
		return new Val(1, TYPE_BOOL);
	else
		return new Val(0, TYPE_BOOL);
	} // end of BifFunc::bro_connection_exists

#line 3211 "bro.bif"

#line 3222 "bro.bif"
Val* BifFunc::bro_lookup_connection(Frame* frame, val_list* BiF_ARGS)
	
#line 3223 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("lookup_connection() takes exactly 1 argument(s)");
		return 0;
		}
	Val* cid = (Val*) ((*BiF_ARGS)[0]);

#line 3223 "bro.bif"

	Connection* conn = sessions->FindConnection(cid);
	if ( conn )
		return conn->BuildConnVal();

	builtin_error("connection ID not a known connection", cid);

	// Return a dummy connection record.
	RecordVal* c = new RecordVal(connection_type);

	RecordVal* id_val = new RecordVal(conn_id);
	id_val->Assign(0, new AddrVal((unsigned int) 0));
	id_val->Assign(1, port_mgr->Get(ntohs(0), TRANSPORT_UDP));
	id_val->Assign(2, new AddrVal((unsigned int) 0));
	id_val->Assign(3, port_mgr->Get(ntohs(0), TRANSPORT_UDP));
	c->Assign(0, id_val);

	RecordVal* orig_endp = new RecordVal(endpoint);
	orig_endp->Assign(0, new Val(0, TYPE_COUNT));
	orig_endp->Assign(1, new Val(int(0), TYPE_COUNT));

	RecordVal* resp_endp = new RecordVal(endpoint);
	resp_endp->Assign(0, new Val(0, TYPE_COUNT));
	resp_endp->Assign(1, new Val(int(0), TYPE_COUNT));

	c->Assign(1, orig_endp);
	c->Assign(2, resp_endp);

	c->Assign(3, new Val(network_time, TYPE_TIME));
	c->Assign(4, new Val(0.0, TYPE_INTERVAL));
	c->Assign(5, new TableVal(string_set));	// service
	c->Assign(6, new StringVal(""));	// history

	return c;
	} // end of BifFunc::bro_lookup_connection

#line 3257 "bro.bif"

#line 3259 "bro.bif"

const char* conn_id_string(Val* c)
	{
	Val* id = (*(c->AsRecord()))[0];
	const val_list* vl = id->AsRecord();

	const IPAddr& orig_h = (*vl)[0]->AsAddr();
	uint32 orig_p = (*vl)[1]->AsPortVal()->Port();
	const IPAddr& resp_h = (*vl)[2]->AsAddr();
	uint32 resp_p = (*vl)[3]->AsPortVal()->Port();

	return fmt("%s/%u -> %s/%u\n", orig_h.AsString().c_str(), orig_p,
	                               resp_h.AsString().c_str(), resp_p);
	}

#line 3282 "bro.bif"
Val* BifFunc::bro_dump_current_packet(Frame* frame, val_list* BiF_ARGS) 
	
#line 3283 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("dump_current_packet() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* file_name = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 3283 "bro.bif"

	const Packet* pkt;

	if ( ! current_pktsrc ||
	     ! current_pktsrc->GetCurrentPacket(&pkt) )
		return new Val(0, TYPE_BOOL);

	if ( ! addl_pkt_dumper )
		addl_pkt_dumper = iosource_mgr->OpenPktDumper(file_name->CheckString(), true);

	if ( addl_pkt_dumper )
		{
		addl_pkt_dumper->Dump(pkt);
		}

	return new Val( addl_pkt_dumper && ! addl_pkt_dumper->IsError(), TYPE_BOOL);
	} // end of BifFunc::bro_dump_current_packet

#line 3299 "bro.bif"

#line 3307 "bro.bif"
Val* BifFunc::bro_get_current_packet(Frame* frame, val_list* BiF_ARGS) 
	
#line 3308 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("get_current_packet() takes exactly 0 argument(s)");
		return 0;
		}

#line 3308 "bro.bif"

	const Packet* p;
	RecordVal* pkt = new RecordVal(pcap_packet);

	if ( ! current_pktsrc ||
	     ! current_pktsrc->GetCurrentPacket(&p) )
		{
		pkt->Assign(0, new Val(0, TYPE_COUNT));
		pkt->Assign(1, new Val(0, TYPE_COUNT));
		pkt->Assign(2, new Val(0, TYPE_COUNT));
		pkt->Assign(3, new Val(0, TYPE_COUNT));
		pkt->Assign(4, new StringVal(""));
		pkt->Assign(5, new EnumVal(BifEnum::LINK_UNKNOWN, BifType::Enum::link_encap));
		return pkt;
		}

	pkt->Assign(0, new Val(uint32(p->ts.tv_sec), TYPE_COUNT));
	pkt->Assign(1, new Val(uint32(p->ts.tv_usec), TYPE_COUNT));
	pkt->Assign(2, new Val(p->cap_len, TYPE_COUNT));
	pkt->Assign(3, new Val(p->len, TYPE_COUNT));
	pkt->Assign(4, new StringVal(p->cap_len, (const char*)p->data));
	pkt->Assign(5, new EnumVal(p->link_type, BifType::Enum::link_encap));

	return pkt;
	} // end of BifFunc::bro_get_current_packet

#line 3332 "bro.bif"

#line 3340 "bro.bif"
Val* BifFunc::bro_get_current_packet_header(Frame* frame, val_list* BiF_ARGS) 
	
#line 3341 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("get_current_packet_header() takes exactly 0 argument(s)");
		return 0;
		}

#line 3341 "bro.bif"

	const Packet* p;

	if ( current_pktsrc &&
	     current_pktsrc->GetCurrentPacket(&p) )
		{
		return p->BuildPktHdrVal();
		}

	RecordVal* hdr = new RecordVal(raw_pkt_hdr_type);
	return hdr;
	} // end of BifFunc::bro_get_current_packet_header

#line 3352 "bro.bif"

#line 3363 "bro.bif"
Val* BifFunc::bro_dump_packet(Frame* frame, val_list* BiF_ARGS) 
	
#line 3364 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("dump_packet() takes exactly 2 argument(s)");
		return 0;
		}
	Val* pkt = (Val*) ((*BiF_ARGS)[0]);
	StringVal* file_name = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 3364 "bro.bif"

	if ( ! addl_pkt_dumper )
		addl_pkt_dumper = iosource_mgr->OpenPktDumper(file_name->CheckString(), true);

	if ( addl_pkt_dumper )
		{
		pkt_timeval ts;
		uint32 caplen, len, link_type;
		u_char *data;

		const val_list* pkt_vl = pkt->AsRecord();

		ts.tv_sec = (*pkt_vl)[0]->AsCount();
		ts.tv_usec = (*pkt_vl)[1]->AsCount();
		caplen = (*pkt_vl)[2]->AsCount();
		len = (*pkt_vl)[3]->AsCount();
		data = (*pkt_vl)[4]->AsString()->Bytes();
		link_type = (*pkt_vl)[5]->AsEnum();
		Packet p(link_type, &ts, caplen, len, data, true);

		addl_pkt_dumper->Dump(&p);
		}

	return new Val(addl_pkt_dumper && ! addl_pkt_dumper->IsError(), TYPE_BOOL);
	} // end of BifFunc::bro_dump_packet

#line 3388 "bro.bif"

#line 3390 "bro.bif"

#include "DNS_Mgr.h"
#include "Trigger.h"

class LookupHostCallback : public DNS_Mgr::LookupCallback {
public:
	LookupHostCallback(Trigger* arg_trigger, const CallExpr* arg_call,
				bool arg_lookup_name)
		{
		Ref(arg_trigger);
		trigger = arg_trigger;
		call = arg_call;
		lookup_name = arg_lookup_name;
		}

	~LookupHostCallback()
		{
		Unref(trigger);
		}

	// Overridden from DNS_Mgr:Lookup:Callback.
	virtual void Resolved(const char* name)
		{
		Val* result = new StringVal(name);
		trigger->Cache(call, result);
		Unref(result);
		trigger->Release();
		}

	virtual void Resolved(TableVal* addrs)
		{
		// No Ref() for addrs.
		trigger->Cache(call, addrs);
		trigger->Release();
		}

	virtual void Timeout()
		{
		if ( lookup_name )
			{
			Val* result = new StringVal("<\?\?\?>");
			trigger->Cache(call, result);
			Unref(result);
			}

		else
			{
			ListVal* lv = new ListVal(TYPE_ADDR);
			lv->Append(new AddrVal("0.0.0.0"));
			Val* result = lv->ConvertToSet();
			trigger->Cache(call, result);
			Unref(result);
			Unref(lv);
			}

		trigger->Release();
		}

private:
	Trigger* trigger;
	const CallExpr* call;
	bool lookup_name;
};

#line 3464 "bro.bif"
Val* BifFunc::bro_lookup_addr(Frame* frame, val_list* BiF_ARGS) 
	
#line 3465 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("lookup_addr() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* host = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 3465 "bro.bif"

	// FIXME: It should be easy to adapt the function to synchronous
	// lookups if we're reading a trace.
	Trigger* trigger = frame->GetTrigger();

	if ( ! trigger)
		{
		builtin_error("lookup_addr() can only be called inside a when-condition");
		return new StringVal("<error>");
		}

	frame->SetDelayed();
	trigger->Hold();

	dns_mgr->AsyncLookupAddr(host->AsAddr(),
			new LookupHostCallback(trigger, frame->GetCall(), true));
	return 0;
	} // end of BifFunc::bro_lookup_addr

#line 3482 "bro.bif"

#line 3493 "bro.bif"
Val* BifFunc::bro_lookup_hostname_txt(Frame* frame, val_list* BiF_ARGS) 
	
#line 3494 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("lookup_hostname_txt() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* host = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 3494 "bro.bif"

	// FIXME: Is should be easy to adapt the function to synchronous
	// lookups if we're reading a trace.
	Trigger* trigger = frame->GetTrigger();

	if ( ! trigger)
		{
		builtin_error("lookup_hostname_txt() can only be called inside a when-condition");
		return new StringVal("<error>");
		}

	frame->SetDelayed();
	trigger->Hold();

	dns_mgr->AsyncLookupNameText(host->CheckString(),
				 new LookupHostCallback(trigger, frame->GetCall(), true));
	return 0;
	} // end of BifFunc::bro_lookup_hostname_txt

#line 3511 "bro.bif"

#line 3522 "bro.bif"
Val* BifFunc::bro_lookup_hostname(Frame* frame, val_list* BiF_ARGS) 
	
#line 3523 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("lookup_hostname() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* host = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 3523 "bro.bif"

	// FIXME: Is should be easy to adapt the function to synchronous
	// lookups if we're reading a trace.
	Trigger* trigger = frame->GetTrigger();

	if ( ! trigger)
		{
		builtin_error("lookup_hostname() can only be called inside a when-condition");
		return new StringVal("<error>");
		}

	frame->SetDelayed();
	trigger->Hold();

	dns_mgr->AsyncLookupName(host->CheckString(),
			new LookupHostCallback(trigger, frame->GetCall(), false));
	return 0;
	} // end of BifFunc::bro_lookup_hostname

#line 3540 "bro.bif"

#line 3542 "bro.bif"

#ifdef USE_GEOIP
extern "C" {
#include <GeoIPCity.h>
}

static GeoIP* open_geoip_db(GeoIPDBTypes type)
	{
	GeoIP* geoip = 0;

	if ( GeoIP_db_avail(type) )
		geoip = GeoIP_open_type(type, GEOIP_MEMORY_CACHE);

	return geoip;
	}

static GeoIP* open_geoip_city_db()
	{
	GeoIP* geoip = open_geoip_db(GEOIP_CITY_EDITION_REV0);

	if ( ! geoip )
		geoip = open_geoip_db(GEOIP_CITY_EDITION_REV1);

	if ( ! geoip )
		{
		string rev0_path = GeoIPDBFileName[GEOIP_CITY_EDITION_REV0];
		string rev1_path = GeoIPDBFileName[GEOIP_CITY_EDITION_REV1];
		string db_path = rev0_path;

		// Maybe in the future the revisions won't share a common default path.
		if ( rev0_path != rev1_path )
			db_path = rev0_path + " or " + rev1_path;

		reporter->Info("Failed to open GeoIP City database: %s",
		               db_path.c_str());
		}

	return geoip;
	}

static GeoIP* open_geoip_city_db_v6()
	{
	GeoIP* geoip = 0;

	// Both city edition revisions for IPv6 show up in libGeoIP 1.4.7.
#ifdef HAVE_GEOIP_CITY_EDITION_REV0_V6
	geoip = open_geoip_db(GEOIP_CITY_EDITION_REV0_V6);

	if ( ! geoip )
		geoip = open_geoip_db(GEOIP_CITY_EDITION_REV1_V6);

	if ( ! geoip )
		{
		string rev0_path = GeoIPDBFileName[GEOIP_CITY_EDITION_REV0_V6];
		string rev1_path = GeoIPDBFileName[GEOIP_CITY_EDITION_REV1_V6];
		string db_path = rev0_path;

		// Maybe in the future the revisions won't share a common default path.
		if ( rev0_path != rev1_path )
			db_path = rev0_path + " or " + rev1_path;

		reporter->Info("Failed to open GeoIP Cityv6 database: %s",
		               db_path.c_str());
		}
#endif

	return geoip;
	}

#endif

#line 3622 "bro.bif"
Val* BifFunc::bro_lookup_location(Frame* frame, val_list* BiF_ARGS) 
	
#line 3623 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("lookup_location() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 3623 "bro.bif"

	RecordVal* location = new RecordVal(geo_location);

#ifdef USE_GEOIP
	static bool geoip_initialized = false;
	static GeoIP* geoip = 0;
	static GeoIP* geoip_v6 = 0;
	static bool have_city_db = false;
	static bool have_cityv6_db = false;
	GeoIPRecord* gir = 0;
	const char* cc = 0;

	if ( ! geoip_initialized )
		{
		geoip_initialized = true;
		geoip = open_geoip_city_db();

		if ( ! geoip )
			{
			geoip = open_geoip_db(GEOIP_COUNTRY_EDITION);
			string db_path = GeoIPDBFileName[GEOIP_COUNTRY_EDITION];

			if ( ! geoip )
				builtin_error(fmt("Failed fall back to GeoIP Country "
				                  "database: %s",
				                  GeoIPDBFileName[GEOIP_COUNTRY_EDITION]));
			else
				reporter->Info("Fell back to GeoIP Country database");
			}
		else
			have_city_db = true;

		geoip_v6 = open_geoip_city_db_v6();

		if ( geoip_v6 )
			have_cityv6_db = true;

#ifdef HAVE_GEOIP_COUNTRY_EDITION_V6
		if ( ! geoip_v6 )
			{
			geoip_v6 = open_geoip_db(GEOIP_COUNTRY_EDITION_V6);

			if ( ! geoip_v6 )
				reporter->Info("Failed to open GeoIPv6 Country database: %s",
				               GeoIPDBFileName[GEOIP_COUNTRY_EDITION_V6]);
			}
#endif

		if ( ! geoip_v6 )
			builtin_error("Can't open GeoIPv6 City/Country database");
		}

#ifdef HAVE_GEOIP_COUNTRY_EDITION_V6
	if ( geoip_v6 && a->AsAddr().GetFamily() == IPv6 )
		{
		geoipv6_t ga;
		a->AsAddr().CopyIPv6(&ga);
		if ( have_cityv6_db )
			gir = GeoIP_record_by_ipnum_v6(geoip_v6, ga);
		else
			cc = GeoIP_country_code_by_ipnum_v6(geoip_v6, ga);
		}
	else
#endif

	if ( geoip && a->AsAddr().GetFamily() == IPv4 )
		{
		const uint32* bytes;
		a->AsAddr().GetBytes(&bytes);
		if ( have_city_db )
			gir = GeoIP_record_by_ipnum(geoip, ntohl(*bytes));
		else
			cc = GeoIP_country_code_by_ipnum(geoip, ntohl(*bytes));
		}

	if ( gir )
		{
		if ( gir->country_code )
			location->Assign(0, new StringVal(gir->country_code));

		if ( gir->region )
			location->Assign(1, new StringVal(gir->region));

		if ( gir->city )
			location->Assign(2, new StringVal(gir->city));

		if ( gir->latitude )
			location->Assign(3, new Val(gir->latitude,
							TYPE_DOUBLE));

		if ( gir->longitude )
			location->Assign(4, new Val(gir->longitude,
						TYPE_DOUBLE));

		GeoIPRecord_delete(gir);

		return location;
		}

	else if ( cc )
		{
		location->Assign(0, new StringVal(cc));
		return location;
		}

#else // not USE_GEOIP
	static int missing_geoip_reported = 0;

	if ( ! missing_geoip_reported )
		{
		builtin_error("Bro was not configured for GeoIP support");
		missing_geoip_reported = 1;
		}
#endif

	// We can get here even if we have GeoIP support if we weren't
	// able to initialize it or it didn't return any information for
	// the address.

	return location;
	} // end of BifFunc::bro_lookup_location

#line 3743 "bro.bif"

#line 3753 "bro.bif"
Val* BifFunc::bro_lookup_asn(Frame* frame, val_list* BiF_ARGS) 
	
#line 3754 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("lookup_asn() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 3754 "bro.bif"

#ifdef USE_GEOIP
	static GeoIP* geoip_asn = 0;
	static bool geoip_asn_initialized = false;
	char* gir = 0;

	if ( ! geoip_asn_initialized )
		{
		geoip_asn_initialized = true;
		geoip_asn = open_geoip_db(GEOIP_ASNUM_EDITION);

		if ( ! geoip_asn )
			builtin_error(fmt("Can't open GeoIP ASNUM database: %s",
			                  GeoIPDBFileName[GEOIP_ASNUM_EDITION]));
		}

	if ( geoip_asn )
		{
// IPv6 support showed up in 1.4.5.
#ifdef HAVE_GEOIP_COUNTRY_EDITION_V6
		if ( a->AsAddr().GetFamily() == IPv6 )
			{
			geoipv6_t ga;
			a->AsAddr().CopyIPv6(&ga);
			gir = GeoIP_name_by_ipnum_v6(geoip_asn, ga);
			}
		else
#endif

		if ( a->AsAddr().GetFamily() == IPv4 )
			{
			const uint32* bytes;
			a->AsAddr().GetBytes(&bytes);
			gir = GeoIP_name_by_ipnum(geoip_asn, ntohl(*bytes));
			}
		}

	if ( gir )
		{
		// Move the pointer +2 so we don't return
		// the first two characters: "AS".
		return new Val(atoi(gir+2), TYPE_COUNT);
		}

#else // not USE_GEOIP
	static int missing_geoip_reported = 0;

	if ( ! missing_geoip_reported )
		{
		builtin_error("Bro was not configured for GeoIP ASN support");
		missing_geoip_reported = 1;
		}
#endif

	// We can get here even if we have GeoIP support, if we weren't
	// able to initialize it or it didn't return any information for
	// the address.
	return new Val(0, TYPE_COUNT);
	} // end of BifFunc::bro_lookup_asn

#line 3812 "bro.bif"

#line 3830 "bro.bif"
Val* BifFunc::bro_haversine_distance(Frame* frame, val_list* BiF_ARGS)
	
#line 3831 "bro.bif"
{
	if ( BiF_ARGS->length() != 4 )
		{
		reporter->Error("haversine_distance() takes exactly 4 argument(s)");
		return 0;
		}
	double lat1 = (double) ((*BiF_ARGS)[0]->AsDouble());
	double long1 = (double) ((*BiF_ARGS)[1]->AsDouble());
	double lat2 = (double) ((*BiF_ARGS)[2]->AsDouble());
	double long2 = (double) ((*BiF_ARGS)[3]->AsDouble());

#line 3831 "bro.bif"

	const double PI = 3.14159;
	const double RADIUS = 3958.8;  // Earth's radius in miles.

	double s1 = sin((lat2 - lat1) * PI/360);
	double s2 = sin((long2 - long1) * PI/360);
	double a = s1 * s1 + cos(lat1 * PI/180) * cos(lat2 * PI/180) * s2 * s2;
	double distance = 2 * RADIUS * asin(sqrt(a));

	return new Val(distance, TYPE_DOUBLE);
	} // end of BifFunc::bro_haversine_distance

#line 3841 "bro.bif"

#line 3849 "bro.bif"
Val* BifFunc::bro_file_mode(Frame* frame, val_list* BiF_ARGS)
	
#line 3850 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("file_mode() takes exactly 1 argument(s)");
		return 0;
		}
	bro_uint_t mode = (bro_uint_t) ((*BiF_ARGS)[0]->AsCount());

#line 3850 "bro.bif"

	char str[12];
	char *p = str;

	/* usr */
	if (mode & S_IRUSR)
		*p++ = 'r';
	else
		*p++ = '-';

	if (mode & S_IWUSR)
		*p++ = 'w';
	else
		*p++ = '-';

	switch (mode & (S_IXUSR | S_ISUID)) {
	case 0:
		*p++ = '-';
		break;
	case S_IXUSR:
		*p++ = 'x';
		break;
	case S_ISUID:
		*p++ = 'S';
		break;
	case S_IXUSR | S_ISUID:
		*p++ = 's';
		break;
	}

	/* group */
	if (mode & S_IRGRP)
		*p++ = 'r';
	else
		*p++ = '-';
	if (mode & S_IWGRP)
		*p++ = 'w';
	else
		*p++ = '-';

	switch (mode & (S_IXGRP | S_ISGID)) {
	case 0:
		*p++ = '-';
		break;
	case S_IXGRP:
		*p++ = 'x';
		break;
	case S_ISGID:
		*p++ = 'S';
		break;
	case S_IXGRP | S_ISGID:
		*p++ = 's';
		break;
	}

	/* other */
	if (mode & S_IROTH)
		*p++ = 'r';
	else
		*p++ = '-';
	if (mode & S_IWOTH)
		*p++ = 'w';
	else
		*p++ = '-';

	switch (mode & (S_IXOTH | S_ISVTX)) {
	case 0:
		*p++ = '-';
		break;
	case S_IXOTH:
		*p++ = 'x';
		break;
	case S_ISVTX:
		*p++ = 'T';
		break;
	case S_IXOTH | S_ISVTX:
		*p++ = 't';
		break;
	}

	*p = '\0';

	return new StringVal(str);
	} // end of BifFunc::bro_file_mode

#line 3933 "bro.bif"

#line 3941 "bro.bif"

#include "analyzer/Manager.h"

#line 3956 "bro.bif"
Val* BifFunc::bro_disable_analyzer(Frame* frame, val_list* BiF_ARGS) 
	
#line 3957 "bro.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("disable_analyzer() takes exactly 3 argument(s)");
		return 0;
		}
	Val* cid = (Val*) ((*BiF_ARGS)[0]);
	bro_uint_t aid = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	int err_if_no_conn = (int) ((*BiF_ARGS)[2]->AsBool());

#line 3957 "bro.bif"

	Connection* c = sessions->FindConnection(cid);
	if ( ! c )
		{
		reporter->Error("cannot find connection");
		return new Val(0, TYPE_BOOL);
		}

	analyzer::Analyzer* a = c->FindAnalyzer(aid);
	if ( ! a )
		{
		if ( err_if_no_conn )
			reporter->Error("connection does not have analyzer specified to disable");
		return new Val(0, TYPE_BOOL);
		}

	a->Remove();
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_disable_analyzer

#line 3975 "bro.bif"

#line 3991 "bro.bif"
Val* BifFunc::bro_skip_further_processing(Frame* frame, val_list* BiF_ARGS)
	
#line 3992 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("skip_further_processing() takes exactly 1 argument(s)");
		return 0;
		}
	Val* cid = (Val*) ((*BiF_ARGS)[0]);

#line 3992 "bro.bif"

	Connection* c = sessions->FindConnection(cid);
	if ( ! c )
		return new Val(0, TYPE_BOOL);

	c->SetSkip(1);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_skip_further_processing

#line 3999 "bro.bif"

#line 4021 "bro.bif"
Val* BifFunc::bro_set_record_packets(Frame* frame, val_list* BiF_ARGS)
	
#line 4022 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("set_record_packets() takes exactly 2 argument(s)");
		return 0;
		}
	Val* cid = (Val*) ((*BiF_ARGS)[0]);
	int do_record = (int) ((*BiF_ARGS)[1]->AsBool());

#line 4022 "bro.bif"

	Connection* c = sessions->FindConnection(cid);
	if ( ! c )
		return new Val(0, TYPE_BOOL);

	c->SetRecordPackets(do_record);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_set_record_packets

#line 4029 "bro.bif"

#line 4039 "bro.bif"
Val* BifFunc::bro_set_inactivity_timeout(Frame* frame, val_list* BiF_ARGS)
	
#line 4040 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("set_inactivity_timeout() takes exactly 2 argument(s)");
		return 0;
		}
	Val* cid = (Val*) ((*BiF_ARGS)[0]);
	double t = (double) ((*BiF_ARGS)[1]->AsInterval());

#line 4040 "bro.bif"

	Connection* c = sessions->FindConnection(cid);
	if ( ! c )
		return new Val(0, TYPE_INTERVAL);

	double old_timeout = c->InactivityTimeout();
	c->SetInactivityTimeout(t);

	return new Val(old_timeout, TYPE_INTERVAL);
	} // end of BifFunc::bro_set_inactivity_timeout

#line 4049 "bro.bif"

#line 4067 "bro.bif"
Val* BifFunc::bro_open(Frame* frame, val_list* BiF_ARGS)
	
#line 4068 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("open() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* f = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4068 "bro.bif"

	const char* file = f->CheckString();

	if ( streq(file, "-") )
		return new Val(new BroFile(stdout, "-", "w"));
	else
		return new Val(new BroFile(file, "w"));
	} // end of BifFunc::bro_open

#line 4075 "bro.bif"

#line 4087 "bro.bif"
Val* BifFunc::bro_open_for_append(Frame* frame, val_list* BiF_ARGS)
	
#line 4088 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("open_for_append() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* f = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4088 "bro.bif"

	return new Val(new BroFile(f->CheckString(), "a"));
	} // end of BifFunc::bro_open_for_append

#line 4090 "bro.bif"

#line 4101 "bro.bif"
Val* BifFunc::bro_close(Frame* frame, val_list* BiF_ARGS)
	
#line 4102 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("close() takes exactly 1 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());

#line 4102 "bro.bif"

	return new Val(f->Close(), TYPE_BOOL);
	} // end of BifFunc::bro_close

#line 4104 "bro.bif"

#line 4117 "bro.bif"
Val* BifFunc::bro_write_file(Frame* frame, val_list* BiF_ARGS)
	
#line 4118 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("write_file() takes exactly 2 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());
	StringVal* data = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 4118 "bro.bif"

	if ( ! f )
		return new Val(0, TYPE_BOOL);

	return new Val(f->Write((const char*) data->Bytes(), data->Len()),
			TYPE_BOOL);
	} // end of BifFunc::bro_write_file

#line 4124 "bro.bif"

#line 4138 "bro.bif"
Val* BifFunc::bro_set_buf(Frame* frame, val_list* BiF_ARGS)
	
#line 4139 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("set_buf() takes exactly 2 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());
	int buffered = (int) ((*BiF_ARGS)[1]->AsBool());

#line 4139 "bro.bif"

	f->SetBuf(buffered);
	return new Val(0, TYPE_VOID);
	} // end of BifFunc::bro_set_buf

#line 4142 "bro.bif"

#line 4151 "bro.bif"
Val* BifFunc::bro_flush_all(Frame* frame, val_list* BiF_ARGS)
	
#line 4152 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("flush_all() takes exactly 0 argument(s)");
		return 0;
		}

#line 4152 "bro.bif"

	return new Val(fflush(0) == 0, TYPE_BOOL);
	} // end of BifFunc::bro_flush_all

#line 4154 "bro.bif"

#line 4166 "bro.bif"
Val* BifFunc::bro_mkdir(Frame* frame, val_list* BiF_ARGS)
	
#line 4167 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("mkdir() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* f = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4167 "bro.bif"

	const char* filename = f->CheckString();

	if ( mkdir(filename, 0777) < 0 )
		{
		int error = errno;
		struct stat filestat;
		// check if already exists and is directory.
		if ( errno == EEXIST && stat(filename, &filestat) == 0
		     && S_ISDIR(filestat.st_mode) )
			return new Val(1, TYPE_BOOL);

		builtin_error(fmt("cannot create directory '%s': %s", filename,
		                  strerror(error)));
		return new Val(0, TYPE_BOOL);
		}
	else
		return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_mkdir

#line 4185 "bro.bif"

#line 4198 "bro.bif"
Val* BifFunc::bro_rmdir(Frame* frame, val_list* BiF_ARGS)
	
#line 4199 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("rmdir() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* d = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4199 "bro.bif"

	const char* dirname = d->CheckString();

	if ( rmdir(dirname) < 0 )
		{
		builtin_error(fmt("cannot remove directory '%s': %s", dirname,
		                  strerror(errno)));
		return new Val(0, TYPE_BOOL);
		}
	else
		return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_rmdir

#line 4210 "bro.bif"

#line 4222 "bro.bif"
Val* BifFunc::bro_unlink(Frame* frame, val_list* BiF_ARGS)
	
#line 4223 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("unlink() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* f = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4223 "bro.bif"

	const char* filename = f->CheckString();

	if ( unlink(filename) < 0 )
		{
		builtin_error(fmt("cannot unlink file '%s': %s", filename,
		                  strerror(errno)));
		return new Val(0, TYPE_BOOL);
		}
	else
		return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_unlink

#line 4234 "bro.bif"

#line 4247 "bro.bif"
Val* BifFunc::bro_rename(Frame* frame, val_list* BiF_ARGS)
	
#line 4248 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("rename() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* src_f = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* dst_f = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 4248 "bro.bif"

	const char* src_filename = src_f->CheckString();
	const char* dst_filename = dst_f->CheckString();

	if ( rename(src_filename, dst_filename) < 0 )
		{
		builtin_error(fmt("cannot rename file '%s' to '%s': %s", src_filename,
		                  dst_filename, strerror(errno)));
		return new Val(0, TYPE_BOOL);
		}
	else
		return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_rename

#line 4260 "bro.bif"

#line 4269 "bro.bif"
Val* BifFunc::bro_active_file(Frame* frame, val_list* BiF_ARGS)
	
#line 4270 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("active_file() takes exactly 1 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());

#line 4270 "bro.bif"

	return new Val(f->IsOpen(), TYPE_BOOL);
	} // end of BifFunc::bro_active_file

#line 4272 "bro.bif"

#line 4281 "bro.bif"
Val* BifFunc::bro_get_file_name(Frame* frame, val_list* BiF_ARGS)
	
#line 4282 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("get_file_name() takes exactly 1 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());

#line 4282 "bro.bif"

	if ( ! f )
		return new StringVal("");

	return new StringVal(f->Name());
	} // end of BifFunc::bro_get_file_name

#line 4287 "bro.bif"

#line 4297 "bro.bif"
Val* BifFunc::bro_rotate_file(Frame* frame, val_list* BiF_ARGS)
	
#line 4298 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("rotate_file() takes exactly 1 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());

#line 4298 "bro.bif"

	RecordVal* info = f->Rotate();
	if ( info )
		return info;

	// Record indicating error.
	info = new RecordVal(rotate_info);
	info->Assign(0, new StringVal(""));
	info->Assign(1, new StringVal(""));
	info->Assign(2, new Val(0, TYPE_TIME));
	info->Assign(3, new Val(0, TYPE_TIME));

	return info;
	} // end of BifFunc::bro_rotate_file

#line 4311 "bro.bif"

#line 4321 "bro.bif"
Val* BifFunc::bro_rotate_file_by_name(Frame* frame, val_list* BiF_ARGS)
	
#line 4322 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("rotate_file_by_name() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* f = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4322 "bro.bif"

	RecordVal* info = new RecordVal(rotate_info);

	bool is_pkt_dumper = false;
	bool is_addl_pkt_dumper = false;

	// Special case: one of current dump files.
	if ( pkt_dumper && streq(pkt_dumper->Path().c_str(), f->CheckString()) )
		{
		is_pkt_dumper = true;
		pkt_dumper->Close();
		}

	if ( addl_pkt_dumper &&
	     streq(addl_pkt_dumper->Path().c_str(), f->CheckString()) )
		{
		is_addl_pkt_dumper = true;
		addl_pkt_dumper->Close();
		}

	FILE* file = rotate_file(f->CheckString(), info);
	if ( ! file )
		{
		// Record indicating error.
		info->Assign(0, new StringVal(""));
		info->Assign(1, new StringVal(""));
		info->Assign(2, new Val(0, TYPE_TIME));
		info->Assign(3, new Val(0, TYPE_TIME));
		return info;
		}

	fclose(file);

	if ( is_pkt_dumper )
		{
		info->Assign(2, new Val(pkt_dumper->OpenTime(), TYPE_TIME));
		pkt_dumper->Open();
		}

	if ( is_addl_pkt_dumper )
		info->Assign(2, new Val(addl_pkt_dumper->OpenTime(), TYPE_TIME));

	return info;
	} // end of BifFunc::bro_rotate_file_by_name

#line 4365 "bro.bif"

#line 4375 "bro.bif"
Val* BifFunc::bro_calc_next_rotate(Frame* frame, val_list* BiF_ARGS) 
	
#line 4376 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("calc_next_rotate() takes exactly 1 argument(s)");
		return 0;
		}
	double i = (double) ((*BiF_ARGS)[0]->AsInterval());

#line 4376 "bro.bif"

	const char* base_time = log_rotate_base_time ?
		log_rotate_base_time->AsString()->CheckString() : 0;

	double base = parse_rotate_base_time(base_time);
	return new Val(calc_next_rotate(network_time, i, base), TYPE_INTERVAL);
	} // end of BifFunc::bro_calc_next_rotate

#line 4382 "bro.bif"

#line 4389 "bro.bif"
Val* BifFunc::bro_file_size(Frame* frame, val_list* BiF_ARGS) 
	
#line 4390 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("file_size() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* f = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4390 "bro.bif"

	struct stat s;

	if ( stat(f->CheckString(), &s) < 0 )
		return new Val(-1.0, TYPE_DOUBLE);

	return new Val(double(s.st_size), TYPE_DOUBLE);
	} // end of BifFunc::bro_file_size

#line 4397 "bro.bif"

#line 4409 "bro.bif"
Val* BifFunc::bro_disable_print_hook(Frame* frame, val_list* BiF_ARGS)
	
#line 4410 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("disable_print_hook() takes exactly 1 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());

#line 4410 "bro.bif"

	f->DisablePrintHook();
	return 0;
	} // end of BifFunc::bro_disable_print_hook

#line 4413 "bro.bif"

#line 4421 "bro.bif"
Val* BifFunc::bro_enable_raw_output(Frame* frame, val_list* BiF_ARGS)
	
#line 4422 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("enable_raw_output() takes exactly 1 argument(s)");
		return 0;
		}
	BroFile* f = (BroFile*) ((*BiF_ARGS)[0]->AsFile());

#line 4422 "bro.bif"

	f->EnableRawOutput();
	return 0;
	} // end of BifFunc::bro_enable_raw_output

#line 4425 "bro.bif"

#line 4459 "bro.bif"
Val* BifFunc::bro_install_src_addr_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4460 "bro.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("install_src_addr_filter() takes exactly 3 argument(s)");
		return 0;
		}
	AddrVal* ip = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	bro_uint_t tcp_flags = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	double prob = (double) ((*BiF_ARGS)[2]->AsDouble());

#line 4460 "bro.bif"

	sessions->GetPacketFilter()->AddSrc(ip->AsAddr(), tcp_flags, prob);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_install_src_addr_filter

#line 4463 "bro.bif"

#line 4489 "bro.bif"
Val* BifFunc::bro_install_src_net_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4490 "bro.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("install_src_net_filter() takes exactly 3 argument(s)");
		return 0;
		}
	SubNetVal* snet = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());
	bro_uint_t tcp_flags = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	double prob = (double) ((*BiF_ARGS)[2]->AsDouble());

#line 4490 "bro.bif"

	sessions->GetPacketFilter()->AddSrc(snet, tcp_flags, prob);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_install_src_net_filter

#line 4493 "bro.bif"

#line 4511 "bro.bif"
Val* BifFunc::bro_uninstall_src_addr_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4512 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("uninstall_src_addr_filter() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* ip = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 4512 "bro.bif"

	return new Val(sessions->GetPacketFilter()->RemoveSrc(ip->AsAddr()), TYPE_BOOL);
	} // end of BifFunc::bro_uninstall_src_addr_filter

#line 4514 "bro.bif"

#line 4532 "bro.bif"
Val* BifFunc::bro_uninstall_src_net_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4533 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("uninstall_src_net_filter() takes exactly 1 argument(s)");
		return 0;
		}
	SubNetVal* snet = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());

#line 4533 "bro.bif"

	return new Val(sessions->GetPacketFilter()->RemoveSrc(snet), TYPE_BOOL);
	} // end of BifFunc::bro_uninstall_src_net_filter

#line 4535 "bro.bif"

#line 4564 "bro.bif"
Val* BifFunc::bro_install_dst_addr_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4565 "bro.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("install_dst_addr_filter() takes exactly 3 argument(s)");
		return 0;
		}
	AddrVal* ip = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	bro_uint_t tcp_flags = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	double prob = (double) ((*BiF_ARGS)[2]->AsDouble());

#line 4565 "bro.bif"

	sessions->GetPacketFilter()->AddDst(ip->AsAddr(), tcp_flags, prob);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_install_dst_addr_filter

#line 4568 "bro.bif"

#line 4594 "bro.bif"
Val* BifFunc::bro_install_dst_net_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4595 "bro.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("install_dst_net_filter() takes exactly 3 argument(s)");
		return 0;
		}
	SubNetVal* snet = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());
	bro_uint_t tcp_flags = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	double prob = (double) ((*BiF_ARGS)[2]->AsDouble());

#line 4595 "bro.bif"

	sessions->GetPacketFilter()->AddDst(snet, tcp_flags, prob);
	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_install_dst_net_filter

#line 4598 "bro.bif"

#line 4616 "bro.bif"
Val* BifFunc::bro_uninstall_dst_addr_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4617 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("uninstall_dst_addr_filter() takes exactly 1 argument(s)");
		return 0;
		}
	AddrVal* ip = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());

#line 4617 "bro.bif"

	return new Val(sessions->GetPacketFilter()->RemoveDst(ip->AsAddr()), TYPE_BOOL);
	} // end of BifFunc::bro_uninstall_dst_addr_filter

#line 4619 "bro.bif"

#line 4637 "bro.bif"
Val* BifFunc::bro_uninstall_dst_net_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 4638 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("uninstall_dst_net_filter() takes exactly 1 argument(s)");
		return 0;
		}
	SubNetVal* snet = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());

#line 4638 "bro.bif"

	return new Val(sessions->GetPacketFilter()->RemoveDst(snet), TYPE_BOOL);
	} // end of BifFunc::bro_uninstall_dst_net_filter

#line 4640 "bro.bif"

#line 4651 "bro.bif"
Val* BifFunc::bro_enable_communication(Frame* frame, val_list* BiF_ARGS)
	
#line 4652 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("enable_communication() takes exactly 0 argument(s)");
		return 0;
		}

#line 4652 "bro.bif"

	if ( bro_start_network_time != 0.0 )
		{
		builtin_error("communication must be enabled in bro_init");
		return 0;
		}

	if ( using_communication )
		// Ignore duplicate calls.
		return 0;

	using_communication = 1;
	remote_serializer->Enable();
	return 0;
	} // end of BifFunc::bro_enable_communication

#line 4666 "bro.bif"

#line 4675 "bro.bif"
Val* BifFunc::bro_checkpoint_state(Frame* frame, val_list* BiF_ARGS) 
	
#line 4676 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("checkpoint_state() takes exactly 0 argument(s)");
		return 0;
		}

#line 4676 "bro.bif"

	return new Val(persistence_serializer->WriteState(true), TYPE_BOOL);
	} // end of BifFunc::bro_checkpoint_state

#line 4678 "bro.bif"

#line 4687 "bro.bif"
Val* BifFunc::bro_rescan_state(Frame* frame, val_list* BiF_ARGS) 
	
#line 4688 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("rescan_state() takes exactly 0 argument(s)");
		return 0;
		}

#line 4688 "bro.bif"

	return new Val(persistence_serializer->ReadAll(false, true), TYPE_BOOL);
	} // end of BifFunc::bro_rescan_state

#line 4690 "bro.bif"

#line 4700 "bro.bif"
Val* BifFunc::bro_capture_events(Frame* frame, val_list* BiF_ARGS) 
	
#line 4701 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("capture_events() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* filename = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4701 "bro.bif"

	if ( ! event_serializer )
		event_serializer = new FileSerializer();
	else
		event_serializer->Close();

	return new Val(event_serializer->Open(
		(const char*) filename->CheckString()), TYPE_BOOL);
	} // end of BifFunc::bro_capture_events

#line 4709 "bro.bif"

#line 4719 "bro.bif"
Val* BifFunc::bro_capture_state_updates(Frame* frame, val_list* BiF_ARGS) 
	
#line 4720 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("capture_state_updates() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* filename = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 4720 "bro.bif"

	if ( ! state_serializer )
		state_serializer = new FileSerializer();
	else
		state_serializer->Close();

	return new Val(state_serializer->Open(
		(const char*) filename->CheckString()), TYPE_BOOL);
	} // end of BifFunc::bro_capture_state_updates

#line 4728 "bro.bif"

#line 4761 "bro.bif"
Val* BifFunc::bro_connect(Frame* frame, val_list* BiF_ARGS) 
	
#line 4762 "bro.bif"
{
	if ( BiF_ARGS->length() != 6 )
		{
		reporter->Error("connect() takes exactly 6 argument(s)");
		return 0;
		}
	AddrVal* ip = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	StringVal* zone_id = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());
	PortVal* p = (PortVal*) ((*BiF_ARGS)[2]->AsPortVal());
	StringVal* our_class = (StringVal*) ((*BiF_ARGS)[3]->AsStringVal());
	double retry = (double) ((*BiF_ARGS)[4]->AsInterval());
	int ssl = (int) ((*BiF_ARGS)[5]->AsBool());

#line 4762 "bro.bif"

	return new Val(uint32(remote_serializer->Connect(ip->AsAddr(),
	               zone_id->CheckString(), p->Port(), our_class->CheckString(),
	               retry, ssl)),
			TYPE_COUNT);
	} // end of BifFunc::bro_connect

#line 4767 "bro.bif"

#line 4776 "bro.bif"
Val* BifFunc::bro_disconnect(Frame* frame, val_list* BiF_ARGS) 
    
#line 4777 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("disconnect() takes exactly 1 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);

#line 4777 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->CloseConnection(id), TYPE_BOOL);
	} // end of BifFunc::bro_disconnect

#line 4780 "bro.bif"

#line 4794 "bro.bif"
Val* BifFunc::bro_request_remote_events(Frame* frame, val_list* BiF_ARGS) 
	
#line 4795 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("request_remote_events() takes exactly 2 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);
	RE_Matcher* handlers = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());

#line 4795 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->RequestEvents(id, handlers),
			TYPE_BOOL);
	} // end of BifFunc::bro_request_remote_events

#line 4799 "bro.bif"

#line 4813 "bro.bif"
Val* BifFunc::bro_request_remote_sync(Frame* frame, val_list* BiF_ARGS) 
	
#line 4814 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("request_remote_sync() takes exactly 2 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);
	int auth = (int) ((*BiF_ARGS)[1]->AsBool());

#line 4814 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->RequestSync(id, auth), TYPE_BOOL);
	} // end of BifFunc::bro_request_remote_sync

#line 4817 "bro.bif"

#line 4827 "bro.bif"
Val* BifFunc::bro_request_remote_logs(Frame* frame, val_list* BiF_ARGS) 
	
#line 4828 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("request_remote_logs() takes exactly 1 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);

#line 4828 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->RequestLogs(id), TYPE_BOOL);
	} // end of BifFunc::bro_request_remote_logs

#line 4831 "bro.bif"

#line 4844 "bro.bif"
Val* BifFunc::bro_set_accept_state(Frame* frame, val_list* BiF_ARGS) 
	
#line 4845 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("set_accept_state() takes exactly 2 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);
	int accept = (int) ((*BiF_ARGS)[1]->AsBool());

#line 4845 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->SetAcceptState(id, accept),
			TYPE_BOOL);
	} // end of BifFunc::bro_set_accept_state

#line 4849 "bro.bif"

#line 4861 "bro.bif"
Val* BifFunc::bro_set_compression_level(Frame* frame, val_list* BiF_ARGS) 
	
#line 4862 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("set_compression_level() takes exactly 2 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);
	bro_uint_t level = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());

#line 4862 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->SetCompressionLevel(id, level),
			TYPE_BOOL);
	} // end of BifFunc::bro_set_compression_level

#line 4866 "bro.bif"

#line 4888 "bro.bif"
Val* BifFunc::bro_listen(Frame* frame, val_list* BiF_ARGS) 
	
#line 4889 "bro.bif"
{
	if ( BiF_ARGS->length() != 6 )
		{
		reporter->Error("listen() takes exactly 6 argument(s)");
		return 0;
		}
	AddrVal* ip = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	PortVal* p = (PortVal*) ((*BiF_ARGS)[1]->AsPortVal());
	int ssl = (int) ((*BiF_ARGS)[2]->AsBool());
	int ipv6 = (int) ((*BiF_ARGS)[3]->AsBool());
	StringVal* zone_id = (StringVal*) ((*BiF_ARGS)[4]->AsStringVal());
	double retry_interval = (double) ((*BiF_ARGS)[5]->AsInterval());

#line 4889 "bro.bif"

	return new Val(remote_serializer->Listen(ip->AsAddr(), p->Port(), ssl, ipv6, zone_id->CheckString(), retry_interval), TYPE_BOOL);
	} // end of BifFunc::bro_listen

#line 4891 "bro.bif"

#line 4896 "bro.bif"
Val* BifFunc::bro_is_remote_event(Frame* frame, val_list* BiF_ARGS) 
	
#line 4897 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("is_remote_event() takes exactly 0 argument(s)");
		return 0;
		}

#line 4897 "bro.bif"

	return new Val(mgr.CurrentSource() != SOURCE_LOCAL, TYPE_BOOL);
	} // end of BifFunc::bro_is_remote_event

#line 4899 "bro.bif"

#line 4908 "bro.bif"
Val* BifFunc::bro_send_state(Frame* frame, val_list* BiF_ARGS) 
	
#line 4909 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("send_state() takes exactly 1 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);

#line 4909 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(persistence_serializer->SendState(id, true), TYPE_BOOL);
	} // end of BifFunc::bro_send_state

#line 4912 "bro.bif"

#line 4924 "bro.bif"
Val* BifFunc::bro_send_id(Frame* frame, val_list* BiF_ARGS) 
	
#line 4925 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("send_id() takes exactly 2 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);
	StringVal* id = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 4925 "bro.bif"

	RemoteSerializer::PeerID pid = p->AsRecordVal()->Lookup(0)->AsCount();

	ID* i = global_scope()->Lookup(id->CheckString());
	if ( ! i )
		{
		reporter->Error("send_id: no global id %s", id->CheckString());
		return new Val(0, TYPE_BOOL);
		}

	SerialInfo info(remote_serializer);
	return new Val(remote_serializer->SendID(&info, pid, *i), TYPE_BOOL);
	} // end of BifFunc::bro_send_id

#line 4937 "bro.bif"

#line 4943 "bro.bif"
Val* BifFunc::bro_terminate_communication(Frame* frame, val_list* BiF_ARGS) 
	
#line 4944 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("terminate_communication() takes exactly 0 argument(s)");
		return 0;
		}

#line 4944 "bro.bif"

	return new Val(remote_serializer->Terminate(), TYPE_BOOL);
	} // end of BifFunc::bro_terminate_communication

#line 4946 "bro.bif"

#line 4954 "bro.bif"
Val* BifFunc::bro_complete_handshake(Frame* frame, val_list* BiF_ARGS) 
	
#line 4955 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("complete_handshake() takes exactly 1 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);

#line 4955 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->CompleteHandshake(id), TYPE_BOOL);
	} // end of BifFunc::bro_complete_handshake

#line 4958 "bro.bif"

#line 4971 "bro.bif"
Val* BifFunc::bro_send_ping(Frame* frame, val_list* BiF_ARGS) 
	
#line 4972 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("send_ping() takes exactly 2 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);
	bro_uint_t seq = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());

#line 4972 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->SendPing(id, seq), TYPE_BOOL);
	} // end of BifFunc::bro_send_ping

#line 4975 "bro.bif"

#line 4985 "bro.bif"
Val* BifFunc::bro_send_current_packet(Frame* frame, val_list* BiF_ARGS) 
	
#line 4986 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("send_current_packet() takes exactly 1 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);

#line 4986 "bro.bif"

	const Packet* pkt;

	if ( ! current_pktsrc ||
	     ! current_pktsrc->GetCurrentPacket(&pkt) )
		return new Val(0, TYPE_BOOL);

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();

	SerialInfo info(remote_serializer);
	return new Val(remote_serializer->SendPacket(&info, id, *pkt), TYPE_BOOL);
	} // end of BifFunc::bro_send_current_packet

#line 4997 "bro.bif"

#line 5004 "bro.bif"
Val* BifFunc::bro_get_event_peer(Frame* frame, val_list* BiF_ARGS) 
	
#line 5005 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("get_event_peer() takes exactly 0 argument(s)");
		return 0;
		}

#line 5005 "bro.bif"

	SourceID src = mgr.CurrentSource();

	if ( src == SOURCE_LOCAL )
		{
		RecordVal* p = mgr.GetLocalPeerVal();
		Ref(p);
		return p;
		}

	if ( ! remote_serializer )
		reporter->InternalError("remote_serializer not initialized");

	Val* v = remote_serializer->GetPeerVal(src);
	if ( ! v )
		{
		reporter->Error("peer %d does not exist anymore", int(src));
		RecordVal* p = mgr.GetLocalPeerVal();
		Ref(p);
		return p;
		}

	return v;
	} // end of BifFunc::bro_get_event_peer

#line 5028 "bro.bif"

#line 5035 "bro.bif"
Val* BifFunc::bro_get_local_event_peer(Frame* frame, val_list* BiF_ARGS) 
	
#line 5036 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("get_local_event_peer() takes exactly 0 argument(s)");
		return 0;
		}

#line 5036 "bro.bif"

	RecordVal* p = mgr.GetLocalPeerVal();
	Ref(p);
	return p;
	} // end of BifFunc::bro_get_local_event_peer

#line 5040 "bro.bif"

#line 5051 "bro.bif"
Val* BifFunc::bro_send_capture_filter(Frame* frame, val_list* BiF_ARGS) 
	
#line 5052 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("send_capture_filter() takes exactly 2 argument(s)");
		return 0;
		}
	Val* p = (Val*) ((*BiF_ARGS)[0]);
	StringVal* s = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 5052 "bro.bif"

	RemoteSerializer::PeerID id = p->AsRecordVal()->Lookup(0)->AsCount();
	return new Val(remote_serializer->SendCaptureFilter(id, s->CheckString()), TYPE_BOOL);
	} // end of BifFunc::bro_send_capture_filter

#line 5055 "bro.bif"

#line 5062 "bro.bif"
Val* BifFunc::bro_suspend_processing(Frame* frame, val_list* BiF_ARGS) 
	
#line 5063 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("suspend_processing() takes exactly 0 argument(s)");
		return 0;
		}

#line 5063 "bro.bif"

	net_suspend_processing();
	return 0;
	} // end of BifFunc::bro_suspend_processing

#line 5066 "bro.bif"

#line 5071 "bro.bif"
Val* BifFunc::bro_continue_processing(Frame* frame, val_list* BiF_ARGS) 
	
#line 5072 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("continue_processing() takes exactly 0 argument(s)");
		return 0;
		}

#line 5072 "bro.bif"

	net_continue_processing();
	return 0;
	} // end of BifFunc::bro_continue_processing

#line 5075 "bro.bif"

#line 5080 "bro.bif"
Val* BifFunc::bro_suspend_state_updates(Frame* frame, val_list* BiF_ARGS) 
	
#line 5081 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("suspend_state_updates() takes exactly 0 argument(s)");
		return 0;
		}

#line 5081 "bro.bif"

	if ( remote_serializer )
		remote_serializer->SuspendStateUpdates();
	return 0;
	} // end of BifFunc::bro_suspend_state_updates

#line 5085 "bro.bif"

#line 5090 "bro.bif"
Val* BifFunc::bro_resume_state_updates(Frame* frame, val_list* BiF_ARGS) 
	
#line 5091 "bro.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("resume_state_updates() takes exactly 0 argument(s)");
		return 0;
		}

#line 5091 "bro.bif"

	if ( remote_serializer )
		remote_serializer->ResumeStateUpdates();
	return 0;
	} // end of BifFunc::bro_resume_state_updates

#line 5095 "bro.bif"

#line 5105 "bro.bif"
Val* BifFunc::bro_match_signatures(Frame* frame, val_list* BiF_ARGS) 
	
#line 5108 "bro.bif"
{
	if ( BiF_ARGS->length() != 7 )
		{
		reporter->Error("match_signatures() takes exactly 7 argument(s)");
		return 0;
		}
	Connection* c = (Connection*) ((*BiF_ARGS)[0]->AsRecordVal()->GetOrigin());
	bro_int_t pattern_type = (bro_int_t) ((*BiF_ARGS)[1]->AsInt());
	StringVal* s = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());
	int bol = (int) ((*BiF_ARGS)[3]->AsBool());
	int eol = (int) ((*BiF_ARGS)[4]->AsBool());
	int from_orig = (int) ((*BiF_ARGS)[5]->AsBool());
	int clear = (int) ((*BiF_ARGS)[6]->AsBool());

#line 5108 "bro.bif"

	if ( ! rule_matcher )
		return new Val(0, TYPE_BOOL);

	c->Match((Rule::PatternType) pattern_type, s->Bytes(), s->Len(),
			from_orig, bol, eol, clear);

	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_match_signatures

#line 5116 "bro.bif"

#line 5126 "bro.bif"

#include "Anon.h"

#line 5139 "bro.bif"
Val* BifFunc::bro_preserve_prefix(Frame* frame, val_list* BiF_ARGS)
	
#line 5140 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("preserve_prefix() takes exactly 2 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	bro_uint_t width = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());

#line 5140 "bro.bif"

	AnonymizeIPAddr* ip_anon = ip_anonymizer[PREFIX_PRESERVING_A50];
	if ( ip_anon )
		{
		if ( a->AsAddr().GetFamily() == IPv6 )
			builtin_error("preserve_prefix() not supported for IPv6 addresses");
		else
			{
			const uint32* bytes;
			a->AsAddr().GetBytes(&bytes);
			ip_anon->PreservePrefix(*bytes, width);
			}
		}


	return 0;
	} // end of BifFunc::bro_preserve_prefix

#line 5156 "bro.bif"

#line 5165 "bro.bif"
Val* BifFunc::bro_preserve_subnet(Frame* frame, val_list* BiF_ARGS)
	
#line 5166 "bro.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("preserve_subnet() takes exactly 1 argument(s)");
		return 0;
		}
	SubNetVal* a = (SubNetVal*) ((*BiF_ARGS)[0]->AsSubNetVal());

#line 5166 "bro.bif"

	DEBUG_MSG("%s/%d\n", a->Prefix().AsString().c_str(), a->Width());
	AnonymizeIPAddr* ip_anon = ip_anonymizer[PREFIX_PRESERVING_A50];
	if ( ip_anon )
		{
		if ( a->AsSubNet().Prefix().GetFamily() == IPv6 )
			builtin_error("preserve_subnet() not supported for IPv6 addresses");
		else
			{
			const uint32* bytes;
			a->AsSubNet().Prefix().GetBytes(&bytes);
			ip_anon->PreservePrefix(*bytes, a->AsSubNet().Length());
			}
		}

	return 0;
	} // end of BifFunc::bro_preserve_subnet

#line 5182 "bro.bif"

#line 5201 "bro.bif"
Val* BifFunc::bro_anonymize_addr(Frame* frame, val_list* BiF_ARGS)
	
#line 5202 "bro.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("anonymize_addr() takes exactly 2 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	Val* cl = (Val*) ((*BiF_ARGS)[1]);

#line 5202 "bro.bif"

	int anon_class = cl->InternalInt();
	if ( anon_class < 0 || anon_class >= NUM_ADDR_ANONYMIZATION_CLASSES )
		builtin_error("anonymize_addr(): invalid ip addr anonymization class");

	if ( a->AsAddr().GetFamily() == IPv6 )
		{
		builtin_error("anonymize_addr() not supported for IPv6 addresses");
		return 0;
		}
	else
		{
		const uint32* bytes;
		a->AsAddr().GetBytes(&bytes);
		return new AddrVal(anonymize_ip(*bytes,
			(enum ip_addr_anonymization_class_t) anon_class));
		}
	} // end of BifFunc::bro_anonymize_addr

#line 5219 "bro.bif"
